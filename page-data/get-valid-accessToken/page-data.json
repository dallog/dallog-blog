{"componentChunkName":"component---src-templates-post-jsx","path":"/get-valid-accessToken/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"623f9105-974d-51b9-84c7-f6298a8d1c19","excerpt":"이 글은 우테코 달록팀 크루 나인이 작성했습니다. 😂로그인이 너무 짧아요 달록 서비스를 배포하고 사용자들로부터 많은 피드백과 QA를 받았어요. 덕분에 빠른 시간 내에 많은 문제점들을 해결할 수 있었어요. 그 중에서 로그인이 너무 짧다는 의견이 있었어요. 아무래도 달력은 매일 확인하는 도메인이다보니, 매일 다시 로그인해야하는 번거로움이 사용자들에게는 좋지 …","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 <a href=\"https://github.com/jhy979\">나인</a>이 작성했습니다.</p>\n</blockquote>\n<h2>😂로그인이 너무 짧아요</h2>\n<p><a href=\"https://dallog.me\">달록 서비스</a>를 배포하고 사용자들로부터 많은 피드백과 QA를 받았어요. 덕분에 빠른 시간 내에 많은 문제점들을 해결할 수 있었어요.</p>\n<blockquote>\n<p>그 중에서 로그인이 너무 짧다는 의견이 있었어요.</p>\n</blockquote>\n<p>아무래도 달력은 매일 확인하는 도메인이다보니, 매일 다시 로그인해야하는 번거로움이 사용자들에게는 좋지 않은 경험을 제공했던 것이죠.</p>\n<p>물론 구글 아이디로 로그인을 해서 터치 한 번이면 로그인이 되긴 하지만 <code class=\"language-text\">이조차도 굉장히 귀찮은 일이죠.</code></p>\n<hr>\n<h2>어떻게 할까</h2>\n<blockquote>\n<p>로그인 연장 태스크를 맡은 백엔드 팀원과 이야기를 나누어봤어요.</p>\n</blockquote>\n<h3>🤯 문제 상황 정의</h3>\n<blockquote>\n<p>현재 accessToken의 유효기간이 1일이예요.</p>\n</blockquote>\n<p>1일이 지나면 accessToken은 쓸모가 없어지고 다시 로그인을 해야하는 상황이 발생해요. 이 기간이 너무 짧다는 것이 문제임을 인지했습니다.</p>\n<hr>\n<h2>🔨 해결 방법</h2>\n<h3>1. accessToken의 유효기간을 길게?</h3>\n<blockquote>\n<p>가장 먼저 떠오른 \"방법은 accessToken의 유효기간을 늘린다\" 였습니다.</p>\n</blockquote>\n<p>기간을 더 늘리면 당연히 해결되는 문제죠. <code class=\"language-text\">하지만 문제가 있습니다.</code></p>\n<p>😂 accessToken은 api 요청 시 header에 굉장히 많이 사용되는 정보예요. 그러다보니 탈취될 가능성도 더 높다고 할 수 있겠죠.</p>\n<ul>\n<li>accessToken의 기간을 만약 한 달로 늘린다고 가정해봅시다. </li>\n<li>악성 이용자가 한 달짜리 accessToken을 탈취했다면 한 달간 해당 accessToken으로 무슨 짓이든 할 수 있겠죠?</li>\n</ul>\n<p>🤦‍♂️ 결론적으로 accessToken의 유효기간을 늘리는 것은 위험한 일이라고 할 수 있어요.</p>\n<p><strong>이 방식은 아니다~</strong></p>\n<h3>2. 매번 재검증 로직</h3>\n<blockquote>\n<p>accessToken이 필요한 api 요청들을 처리하기 전에 \"accessToken의 유효성을 검사하는 재검증 요청을 먼저 진행하자\" 라는 의견이 나왔어요.</p>\n</blockquote>\n<p>재검증 로직에서 만약 유효하지 않은 accessToken이라면 refreshToken을 기반으로 새로운 accessToken을 발급한다는 해결 방안입니다.</p>\n<p>하지만 이게 정말 괜찮은 방식일까요?</p>\n<p>아래는 달록의 rest docs입니다.\n<img src='https://velog.velcdn.com/images/jhy979/post/643a0d38-8131-422d-ad8f-64b2780c6277/image.png' width='700'></p>\n<p>accessToken을 필요로 하는 api가 20개나 되는데요, 이 요청들의 안전성을 보장하기 위해 매번 재검증 요청을 보낸다...?</p>\n<p>😅 이 방식은 <code class=\"language-text\">배보다 배꼽이 더 크다고 생각했어요.</code></p>\n<ul>\n<li>하루에 한 번 발생하는 재로그인 때문에 매번 네트워크 요청을 한 번씩 더하는 것이 어불성설이라고 느꼈거든요.</li>\n</ul>\n<p><strong>너도 나가라~</strong></p>\n<h3>3. 에러 응답 코드로 판별하자</h3>\n<blockquote>\n<p>매번 요청을 보내지 말고 특정 에러 응답코드(invalid accessToken)가 올 때만 accessToken을 재발급 받으면 되지 않을까?</p>\n</blockquote>\n<p>저희 달록은 accessToken이 유용하지 않을때 401 응답코드를 보내주고 있어요.\n<img src='https://velog.velcdn.com/images/jhy979/post/5ed347d5-bd05-4a75-a156-fc6e35303dc0/image.png' width='300'></p>\n<p>그렇다면 401 status code를 받았을때 후속 처리로 refreshToken으로 accessToken을 받으면 되지 않을까요?</p>\n<p>그렇다면 2번째 해결방법처럼 불필요한 네트워크 요청도 필요없을 것 같아요.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// accessToken 재발급을 위한 react-query문</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> mutate <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useLoginAgain</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// react-query queryClient의 전역 onError</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">onError</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>error<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  \t<span class=\"token comment\">// 401 에러가 발생했을 경우</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">AxiosError</span> <span class=\"token operator\">&amp;&amp;</span> error<span class=\"token punctuation\">.</span>response<span class=\"token operator\">?.</span>status <span class=\"token operator\">===</span> <span class=\"token constant\">RESPONSE</span><span class=\"token punctuation\">.</span><span class=\"token constant\">STATUS</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNAUTHORIZED</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// refreshToken으로 accessToken을 재발급해주세요!</span>\n      <span class=\"token function\">mutate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이런 식으로 전역 queryClient에 onError 로직을 달아주었어요. 그렇다면 달록의 모든 요청 중에서 <code class=\"language-text\">401 에러가 발생하는 경우에 대해 재발급 요청이 가능하겠죠?</code></p>\n<p>🥵 하지만 이 방식도 우아하지 않았어요...</p>\n<p>아래는 달록의 달력 페이지 접속 시 요청하는 api들이예요.\n<img src='https://velog.velcdn.com/images/jhy979/post/7410a969-d29f-4457-baa2-8f897df2475a/image.png' width='500'></p>\n<ul>\n<li>총 5개의 네트워크 요청이 발생하는데요, 이 중에서 <code class=\"language-text\">4개가 accessToken이 필요한 요청들입니다.</code></li>\n<li>만약 accessToken이 유효하지 않게 된다면 401 에러가 4개 발생하게 될 거예요.</li>\n</ul>\n<p>🤔 전역으로 onError를 달아두었기 때문에 <code class=\"language-text\">accessToken 재발급 요청도 반복적으로 4번 발생하게 됩니다.</code></p>\n<p>재발급 요청을 한 번만 요청하면 되는데 무려 4번이나 보내고 있네요. 접근 방식은 좋았으나 이 트러블도 해결해야겠어요.</p>\n<h3>4. 에러 응답 코드 + 반복 발생하는 재발급 쿼리 무시</h3>\n<blockquote>\n<p>재발급 쿼리가 진행중이라면 이를 무시해야겠어요.</p>\n</blockquote>\n<p>여태까지 Mutation 작업에 키값을 적용하지 않았었는데요, 이제야 MutateKey값을 달아야할 필요성이 생겼네요.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// accessToken 재발급을 위한 react-query문</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> mutate <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useLoginAgain</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 🙌 accessToken 재발급 mutate가 진행중인가요?</span>\n<span class=\"token keyword\">const</span> isMutatingLoginAgain <span class=\"token operator\">=</span> <span class=\"token function\">useIsMutating</span><span class=\"token punctuation\">(</span><span class=\"token constant\">CACHE_KEY</span><span class=\"token punctuation\">.</span><span class=\"token constant\">LOGIN_AGAIN</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// react-query queryClient의 전역 onError</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">onError</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>error<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">AxiosError</span> <span class=\"token operator\">&amp;&amp;</span> error<span class=\"token punctuation\">.</span>response<span class=\"token operator\">?.</span>status <span class=\"token operator\">===</span> <span class=\"token constant\">RESPONSE</span><span class=\"token punctuation\">.</span><span class=\"token constant\">STATUS</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UNAUTHORIZED</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// ✋ 재발급 중이 아닐때에만 재발급 요청 보내주세요. (재발급 중이면 mutate 무시)</span>\n      <span class=\"token operator\">!</span>isMutatingLoginAgain <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">mutate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>😉 실제로 재발급 요청이 한 번만 가는지 확인해볼까요?</p>\n<img src='https://velog.velcdn.com/images/jhy979/post/4d764f96-c622-4903-a2d3-8708a879cf67/image.png' width='500'>\n<p><code class=\"language-text\">access</code>가 accessToken을 재발급하는 요청이예요. 볼 수 있듯이 딱 한번만 요청이 가고 있음을 확인할 수 있네요. 아주 굿~</p>\n<hr>\n<h2>😛 더 나아가기</h2>\n<h3>실패했던 요청들까지 처리</h3>\n<blockquote>\n<p>더 나아가 401로 실패했던 요청들을 다시 실행시켜줄 수 있을 것 같아요.</p>\n</blockquote>\n<ol>\n<li>mutation 키 값을 기준으로 401 <code class=\"language-text\">에러가 발생했던 요청들에 대해서 저장</code>한 다음 </li>\n<li>accessToken을 재발급 받아 <code class=\"language-text\">유효성을 확신시</code>하고</li>\n<li>저장했던 (에러가 났던) 요청들을 다시 (유효한 accessToken으로) 실행시켜줄 수 있을 것 같네요.</li>\n</ol>\n<h3>만약 react-query를 쓰지 않았다면?</h3>\n<blockquote>\n<p>🤯 현재는 react-query를 쓰고 있어서 이런 mutating 과정을 제가 체크할 수 있었는데요 그렇지 않은 경우라면 어떻게 해결할 수 있었을까요?</p>\n</blockquote>\n<p>라이브러리를 사용하지 않는다고 해도 <code class=\"language-text\">비슷한 방식으로 커스텀훅을 만들 것 같아요.</code></p>\n<p>예를 들면 <code class=\"language-text\">useFetch</code> 라는 훅을 만들어서 <code class=\"language-text\">onError</code> 공통 로직을 주입하여 에러 핸들링을 진행할 것 같습니다.</p>\n<p>401 에러가 발생하는지 status code를 확인하여 accessToken을 재발급하는 과정을 진행해야겠죠?</p>","frontmatter":{"title":"refreshToken으로 accessToken 재발급하기","date":"October 31, 2022","update":null,"tags":["trouble-shooting"],"series":null},"fields":{"slug":"/get-valid-accessToken/","readingTime":{"minutes":8.72}}},"seriesList":{"edges":[{"node":{"id":"a621dc7b-8590-5ec6-9b52-3d9e5182486d","fields":{"slug":"/appearance-background-of-jpa/"},"frontmatter":{"title":"JPA 등장배경"}}},{"node":{"id":"9d2a87b6-2b9c-5b87-b790-3426d17c2d8e","fields":{"slug":"/intellij-final-keyword/"},"frontmatter":{"title":"IntelliJ에서 메소드 추출한 메소드의 파라미터에 final 키워드 자동 추가하기"}}},{"node":{"id":"251e9767-1c92-5cf5-9cef-2c4a42c10df2","fields":{"slug":"/git-branch-strategy/"},"frontmatter":{"title":"달록팀의 git 브랜치 전략을 소개합니다."}}},{"node":{"id":"5090cce3-0c1f-5376-badc-1d25e44c1bd9","fields":{"slug":"/infinite-scroll/"},"frontmatter":{"title":"React에서 무한 스크롤 구현하기"}}},{"node":{"id":"bcb53ba5-0286-5d10-96c2-fdcb88e2cc60","fields":{"slug":"/package-structure/"},"frontmatter":{"title":"달록에 적절한 패키지 구조 고민하기"}}},{"node":{"id":"a7fc89de-f37c-596e-a81d-3d4fe5a795b8","fields":{"slug":"/data-jpa-slice-page/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"e1ba92ee-0cf0-50c8-80bd-5da5075df8d1","fields":{"slug":"/data-jpa-auditing/"},"frontmatter":{"title":"Spring Data JPA의 Auditing"}}},{"node":{"id":"3e036508-c916-504e-9e8d-89f69332471e","fields":{"slug":"/separated-interface/"},"frontmatter":{"title":"외부와 의존성 분리하기"}}},{"node":{"id":"cade544a-16ef-58a3-b97c-824986a8395f","fields":{"slug":"/apply-rest-docs/"},"frontmatter":{"title":"MockMvc를 사용한 Spring RestDocs"}}},{"node":{"id":"87649d54-d59e-58a6-afd5-8491eb4113a8","fields":{"slug":"/properties-to-object/"},"frontmatter":{"title":"properties 객체로 다루기"}}},{"node":{"id":"eb380f6d-5a00-5a9e-a916-003fb292cc8a","fields":{"slug":"/test-fixture-constant/"},"frontmatter":{"title":"테스트에서 Entity 객체를 상수로 두면 안 되는 이유"}}},{"node":{"id":"9734e30a-b430-5922-919d-f53808a56eb9","fields":{"slug":"/what_is_nginx/"},"frontmatter":{"title":"NGINX 란?"}}},{"node":{"id":"9ebc6e21-2a76-5d42-be33-c2dae8c849b2","fields":{"slug":"/ssl_protocol/"},"frontmatter":{"title":"SSL을 통한 HTTPS통신 과정"}}},{"node":{"id":"fa5ad595-1f81-5a20-a884-2da69adee3c5","fields":{"slug":"/integration-test-slice-test/"},"frontmatter":{"title":"통합 테스트와 슬라이스 테스트"}}},{"node":{"id":"d8c66823-bb05-5e83-a6a1-2fd9af450b6f","fields":{"slug":"/query-invalidation/"},"frontmatter":{"title":"React-Query에서의 데이터 최신화 (Query Invalidation)"}}},{"node":{"id":"f5187517-342f-52a1-9092-d12c1a80d132","fields":{"slug":"/seperate-components/"},"frontmatter":{"title":"컴포넌트 분리 기준"}}},{"node":{"id":"d6249c8b-bea6-5c91-8477-d3dd15ad9b39","fields":{"slug":"/test-isolation/"},"frontmatter":{"title":"테스트 격리"}}},{"node":{"id":"98e390ef-fb19-5d01-a3ef-d14bc0e65176","fields":{"slug":"/dallog-jacoco/"},"frontmatter":{"title":"달록의 Jacoco 적용기 (feat. Gradle)"}}},{"node":{"id":"33d19946-de0c-5b41-bfa0-d7c3fd80f10b","fields":{"slug":"/google-refresh-token/"},"frontmatter":{"title":"Google은 Refresh Token을 쉽게 내주지 않는다."}}},{"node":{"id":"8168857d-a82c-5608-bd40-cea4b917d17d","fields":{"slug":"/submodule/"},"frontmatter":{"title":"달록 서브모듈 도입기"}}},{"node":{"id":"836fc724-7e2f-5c7a-a42b-c0cc9163167a","fields":{"slug":"/dallog-flyway/"},"frontmatter":{"title":"달록의 데이터베이스 마이그레이션을 위한 Flyway 적용기"}}},{"node":{"id":"7a3bde6d-746b-56fd-8d91-0d8059ebf1f8","fields":{"slug":"/json-property-json-naming/"},"frontmatter":{"title":"@JsonProperty, @JsonNaming"}}},{"node":{"id":"50673f5c-f835-5982-b70c-b77e5a352a2c","fields":{"slug":"/servlet-life-cycle/"},"frontmatter":{"title":"서블릿 생명주기와 직접만든 톰캣을 통한 의문점"}}},{"node":{"id":"61e7f4d1-7b3a-5968-bfe8-c3f6efb88748","fields":{"slug":"/preparing-for-performance-test/"},"frontmatter":{"title":"톰캣 튜닝을 위한 달록의 서버 성능 테스트 준비 과정"}}},{"node":{"id":"9272061d-68c6-5f82-a961-0e2efe0fd6be","fields":{"slug":"/cyclic-dependency/"},"frontmatter":{"title":"cyclic dependency"}}},{"node":{"id":"6e779308-f266-58af-bfcc-e9fee6d39a98","fields":{"slug":"/multi-datasource-issue-with-osiv/"},"frontmatter":{"title":"대체 왜 DataSource 라우팅이 안되는거야!? (feat. OSIV)"}}},{"node":{"id":"0e63245e-c52c-5977-9f60-f94ee0fd00fc","fields":{"slug":"/hikari-cp-theory/"},"frontmatter":{"title":"HikariCP와 적절한 풀 사이즈 고민하기 (이론편)"}}},{"node":{"id":"c7bea043-345c-5f78-ae53-796a83812961","fields":{"slug":"/react-query-useMutation-trouble-shooting/"},"frontmatter":{"title":"react-query useMutation onSuccess 안 되는줄 알았던 트러블 슈팅"}}},{"node":{"id":"cf403487-1c48-5ca7-b5c2-ef0d8fefe3c4","fields":{"slug":"/jenkins-distributed-build-architecture/"},"frontmatter":{"title":"젠킨스 분산 빌드 아키텍처 구축"}}},{"node":{"id":"24c152c7-4e94-5b84-aaea-a5a9a8357693","fields":{"slug":"/zero-downtime-deployment/"},"frontmatter":{"title":"달록 무중단 배포 도입기"}}},{"node":{"id":"623f9105-974d-51b9-84c7-f6298a8d1c19","fields":{"slug":"/get-valid-accessToken/"},"frontmatter":{"title":"refreshToken으로 accessToken 재발급하기"}}}]},"previous":{"fields":{"slug":"/zero-downtime-deployment/"},"frontmatter":{"title":"달록 무중단 배포 도입기"}},"next":null},"pageContext":{"id":"623f9105-974d-51b9-84c7-f6298a8d1c19","series":null,"previousPostId":"24c152c7-4e94-5b84-aaea-a5a9a8357693","nextPostId":null}},"staticQueryHashes":[]}