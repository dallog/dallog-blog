{"componentChunkName":"component---src-templates-post-jsx","path":"/react-query-useMutation-trouble-shooting/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"c7bea043-345c-5f78-ae53-796a83812961","excerpt":"이 글은 우테코 달록팀 크루 나인이 작성했습니다. 달록 프로젝트를 진행하던도중 예상하지 못한 에러가 발생했어요. 달록에서는 를 사용하고 있습니다.\n을 활용하여 데이터의 변경을 일으키는 작업을 수행하고 있죠!\n(예를들면  같은 작업들이 있겠죠.) 🤦‍♂️ 그런데 간헐적으로 데이터가 변경(delete,patch,post)된 후 다시 데이터를 갱신(get)하는 작업…","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 <a href=\"https://github.com/jhy979\">나인</a>이 작성했습니다.</p>\n</blockquote>\n<img src='https://velog.velcdn.com/images/jhy979/post/60cffbe1-a0bb-4f53-aa8f-e08ee092d038/image.png'>\n<blockquote>\n<p>달록 프로젝트를 진행하던도중 예상하지 못한 에러가 발생했어요.</p>\n</blockquote>\n<p>달록에서는 <code class=\"language-text\">react-query</code>를 사용하고 있습니다.\n<code class=\"language-text\">useMutation</code>을 활용하여 데이터의 변경을 일으키는 작업을 수행하고 있죠!\n(예를들면 <code class=\"language-text\">Delete, Patch, Post</code> 같은 작업들이 있겠죠.)</p>\n<p>🤦‍♂️ 그런데 간헐적으로 데이터가 변경(delete,patch,post)된 후 다시 데이터를 갱신(get)하는 작업에서 변경된 데이터가 들어오지 않는 이슈가 발생했습니다.</p>\n<p>더욱 더 문제는 Mac을 사용하는 사용자들은 이런 에러가 발생하지 않았는데 Window 이용자들만 이런 에러가 발생했던 것입니다...</p>\n<p>🤯 Wow... 이 문제를 직면하고 나서 React-Query가 OS에 따라서 동작이 다른가 의심이 들 정도로 문제의 핀트를 잡지 못했습니다</p>\n<hr>\n<blockquote>\n<p>에러가 발생한 시나리오는 다음과 같아요. 한 번 볼까요?</p>\n</blockquote>\n<h3>1. 일정 추가</h3>\n<p>다음과 같이 일정을 추가했습니다.\n이 때는 다행히도 새롭게 추가된 일정이 바로 get하는 response에 반영이 되어있네요.\n<img src='https://velog.velcdn.com/images/jhy979/post/22dd80f0-fe58-4edd-99a3-7530f366d9b7/image.png' width='500'></p>\n<h3>2. 일정 삭제</h3>\n<p>이제 일정을 삭제해볼까요?\n<img src='https://velog.velcdn.com/images/jhy979/post/68e631e1-bfaf-4e16-b6a3-2075022eea91/image.png' width='500'></p>\n<p>개발자 도구의 네트워크 탭을 열어서 확인해봤어요.</p>\n<img src='https://velog.velcdn.com/images/jhy979/post/30df7bb6-115f-4227-a4cd-18ba91a7c799/image.png'>\n<p><code class=\"language-text\">427</code>은 삭제 요청이고\n<code class=\"language-text\">schedules?startDateTime...</code>은 다시 일정을 get하는 요청입니다.</p>\n<p>보니깐 <code class=\"language-text\">delete</code> 이후에 다시 <code class=\"language-text\">get</code> 하는 작업이 이루어지고 있음을 확인할 수 있었어요.</p>\n<p>🔨 코드를 잠깐 살펴보면</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">useDeleteSchedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> scheduleId<span class=\"token punctuation\">,</span> onSuccess <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> UseDeleteScheduleParams<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> accessToken <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useRecoilValue</span><span class=\"token punctuation\">(</span>userState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> queryClient <span class=\"token operator\">=</span> <span class=\"token function\">useQueryClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> mutate <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">useMutation</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>AxiosResponse<span class=\"token punctuation\">,</span> AxiosError<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> scheduleApi<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>accessToken<span class=\"token punctuation\">,</span> scheduleId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n      <span class=\"token function-variable function\">onSuccess</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// ✋ 삭제가 성공하면 일정을 다시 get해주세요!!!</span>\n        queryClient<span class=\"token punctuation\">.</span><span class=\"token function\">invalidateQueries</span><span class=\"token punctuation\">(</span><span class=\"token constant\">CACHE_KEY</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SCHEDULES</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        onSuccess <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">onSuccess</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> mutate <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>delete useMutation에서 <code class=\"language-text\">onSuccess</code>안에 일정을 get하는 쿼리를 <code class=\"language-text\">invalidation</code>해주었기 때문에 당연히 삭제가 성공하고 나서 일정을 다시 가져오는 줄 알았습니다.</p>\n<p>실제로도 네트워크탭에서 보시다시피 <code class=\"language-text\">427</code> 다음에 일정을 다시 get하고 있으니까요!</p>\n<h3>3. 대참사</h3>\n<p>하지만 결과는 다음처럼 삭제가 되지 않고 그대로 남아 있었습니다😂 <del>(이게 말이되냐고)</del></p>\n<img src='https://velog.velcdn.com/images/jhy979/post/22dd80f0-fe58-4edd-99a3-7530f366d9b7/image.png' width='500'>\n<blockquote>\n<p><code class=\"language-text\">새로고침</code>을 해서 아예 get 쿼리 요청을 다시 해야 삭제가 된채로 response가 왔어요. 하.. 이거 리렌더링을 일부러 발생시켜줘야하나? ㅋㅋㅋ큐ㅠㅠ</p>\n</blockquote>\n<hr>\n<h2>삽질</h2>\n<h3>1. DB 시점 문제일까?</h3>\n<blockquote>\n<p>가장 먼저 든 생각은 DB에서 일정이 삭제되지 않은채로 get 요청이 진행되지 않았을까였습니다.</p>\n</blockquote>\n<p>삭제가 성공했다고 <code class=\"language-text\">응답코드 204</code>를 주었지만 실제로 DB에는 반영이 되지 않은채로 바로 데이터를 가지고 오는건 아닐까?</p>\n<p>백엔드 팀원들은 절대 절대 그런 일이 발생할 수는 없다고 하더라구요. 그럼에도 불구하고 직접 로그를 출력하여 확인해준 우리 팀원들 너무 감사합니다..😀😀</p>\n<p>자 그럼 프론트엔드쪽에서의 문제겠죠?</p>\n<hr>\n<h3>2. useMutation의 onSuccess의 문제일까?</h3>\n<p>달록 프로젝트에서는 <code class=\"language-text\">react-query</code>를 사용하고 있어요. 깃허브 star가 <code class=\"language-text\">✨30.1k</code>가 찍힐만큼 인기 많은 라이브러리죠.</p>\n<p>하지만 최근 프로젝트에서 상태 관리 라이브러리로 <code class=\"language-text\">recoil</code>을 사용하던 도중 특정 메서드가 실행되지 않는 에러가 있었던 적이 있었어요.</p>\n<p>🥵 이 이후로 아무리 공신력있는 라이브러리라도 맹신하지 않겠다고 다짐했었어요.</p>\n<p>호옥시 호옥시 <code class=\"language-text\">react-query useMutation의 onSuccess</code>가 mutate 작업이 확실히 성공된 후에 실행이 되는 것이 맞을까? 의심해봤어요.</p>\n<p>관련해서 <code class=\"language-text\">react-query</code>의 깃허브 이슈 목록들을 전부 찾아봤지만... 없더라구요.</p>\n<p>그렇다면 이건 문제가 아니라고 생각이 들더라구요.</p>\n<hr>\n<h3>3. 그럼 문제는 단 하나죠. react-query를 잘못 쓰고 있다!</h3>\n<blockquote>\n<p>돌고 돌아 다시 네트워크 탭에 들어가 요청이 실행되는 시점을 비교해봤어요.</p>\n</blockquote>\n<p>이번엔 더 자세한 요청 시간을 보기 위해서 <code class=\"language-text\">Timing 탭까지 들어가서 확인해봤어요.</code></p>\n<p>😀 삭제 요청 큐에 들어가고 실행되는 시점입니다.</p>\n<img src='https://velog.velcdn.com/images/jhy979/post/8bf786cb-77e4-4090-81c6-83e340e07025/image.png' width='600'>\n<ul>\n<li>1.62초에 실행되고 삭제 성공까지 0.039정도 걸리네요.</li>\n<li>그럼 성공시에 다음 로직은 1.66초 정도에 시작되어야할 것 같은데요! 놀라운 일이 발생합니다. 아래를 보시죠.</li>\n</ul>\n<p>😀 삭제 요청 이후 Get 요청이 큐에 들어가고 실행되는 시점입니다.\n<img src='https://velog.velcdn.com/images/jhy979/post/bc3bdc64-074c-4810-8cc7-503100c47350/image.png' width='600'></p>\n<ul>\n<li>엥? 시작 시점이 1.63초? 비상!!!!! 초비상!!!!!</li>\n<li>삭제가 성공한 시점은 (1.66초)인데 get 요청이 (1.63초)에 실행된다니 말이 안되죠.</li>\n</ul>\n<blockquote>\n<p>결론이 나왔습니다. </p>\n</blockquote>\n<ol>\n<li>DB문제도 아니고 </li>\n<li>onSuccess의 문제도 아니다. (실행되는 Timing을 보니 onSuccess가 제대로 실행되고 있지 않다.)</li>\n<li><code class=\"language-text\">저 get</code> 요청은 다른 이유로 실행되고 있다!!!\n(조금 더 보태어 설명하자면 <code class=\"language-text\">저 get</code> 요청이 <code class=\"language-text\">onSuccess의 get</code>요청이 실행될 시점에 이미 실행되고 있기 때문에 <code class=\"language-text\">onSuccess의 get</code> 요청이 무시되었던 거죠.)</li>\n</ol>\n<p>그럼 왜 때문에 저 get요청이 실행되고 있는지 파악해야겠죠.</p>\n<hr>\n<h2>해결</h2>\n<blockquote>\n<p>React Query는 데이터 Fetching, 캐싱, 동기화, 서버 쪽 데이터 업데이트 등을 쉽게 만들어 주는 React 라이브러리입니다.</p>\n</blockquote>\n<ul>\n<li>네 맞죠, 저희는 리액트쿼리를 <code class=\"language-text\">캐싱</code>을 가장 큰 목적으로 사용하고자 했습니다.</li>\n<li>하지만 프로젝트에서 queryClient의 <code class=\"language-text\">staleTime, cacheTime, refetchOnWindowFocus, refetchOnMount</code> 등을 지정해주지 않은채로 <code class=\"language-text\">default Option으로 그대로</code> 사용하고 있었어요.</li>\n</ul>\n<p><code class=\"language-text\">refetchOnWindowFocus</code> : 데이터가 stale 상태일 경우 포커스될 때 refetch를 실행하는 옵션</p>\n<p><code class=\"language-text\">refetchOnMount</code> : 데이터가 stale 상태일 경우 마운트 시 마다 refetch를 실행하는 옵션</p>\n<blockquote>\n<p>그리고 중요한 것은.. staleTime의 default 값은 0이라는 점이죠!</p>\n</blockquote>\n<p>🥵 staleTime이 0이므로 항상 데이터가 오염된 상태로 인식을 했고 </p>\n<p>그러니 해당 컴포넌트가 마운트되거나 포커스되었을때 get요청을 계속계속계속 했던 것이죠. 으아... 문제 발견 발견!!!</p>\n<p>🤯 삭제 후에 반영되지 않은채로 온 것 같은 response는 사실 삭제 후의 응답이 아니라 <code class=\"language-text\">마운트 혹은 포커스로 인해 발생한 get 요청</code>였던거죠ㅠㅠ</p>\n<p>이 사실을 알고 다시 네트워크 요청의 waterfall을 살펴보니 더 명확해졌습니다.</p>\n<p>아까 봤던 그림인데 이슈를 알고보니 바로 보이는군요.. <del>(참 야속하네요ㅠㅠ)</del></p>\n<img src='https://velog.velcdn.com/images/jhy979/post/30df7bb6-115f-4227-a4cd-18ba91a7c799/image.png'>\n<p>좌측 연두색 바를 살펴보니 <code class=\"language-text\">427 delete 요청</code>과 <code class=\"language-text\">schedule?startDateTime... get 요청</code>이 같은 시점에 queue에 들어가고 있군요😂😂</p>\n<p>바로 staleTime을 지정해줬어요.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> queryClient <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">QueryClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    defaultOptions<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      queries<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        retry<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        retryDelay<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n        onError<span class=\"token punctuation\">,</span>\n        <span class=\"token comment\">// 1분으로 staleTime 지정하기</span>\n        staleTime<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token operator\">*</span> <span class=\"token number\">60</span> <span class=\"token operator\">*</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      mutations<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        retry<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        retryDelay<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n        onError<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>참고로 refetchOnMount, refetchOnWindowFocus는 true 설정해줘야 stale해졌을때 제대로 데이터를 가져올 것이라고 판단하여 true인 기본 옵션값으로 건드리지 않았어요.</p>\n<hr>\n<h2>확인</h2>\n<blockquote>\n<p>해결되었는지 확인해봅시다. 삭제 후 onSuccess 내부 로직인 일정 get 요청이 되는지 확인해볼까요?</p>\n</blockquote>\n<img src='https://velog.velcdn.com/images/jhy979/post/4376e31b-b5d8-4b86-bff0-bb3b759c76b9/image.png' width='800'>\n<p>🌈드디어 <code class=\"language-text\">238 삭제 요청</code>이 성공하고 <code class=\"language-text\">schedules?startDateTime... get 요청</code>이 시점에 맞게 들어오네요. </p>\n<p>🌈 오른쪽 waterfall 연두색 바가 보이시죠? 이게 맞지!</p>\n<hr>\n<h2>결론</h2>\n<p>🤦‍♂️ 이번 트러블 슈팅을 통해 라이브러리를 사용하는 의도를 명확히 파악해야한다는 것을 느꼈어요.</p>\n<ul>\n<li>React-Query를 도입한 이유의 가장 큰 이유는 <code class=\"language-text\">캐싱에서의 이점</code>이었는데 이 부분을 개발할 때 크게 생각하지 않고 default option값들을 사용하면 될 줄 알았던 것이 문제였어요.</li>\n<li>간헐적으로 발생해서 오랜 시간동안 에러를 해결하지 못했으나 덕분에 <code class=\"language-text\">라이브러리를 도입할 때 명확한 의도에 맞게</code> 사용해야한다는 점을 뼈저리게 느끼게 되었어요.</li>\n</ul>","frontmatter":{"title":"react-query useMutation onSuccess 안 되는줄 알았던 트러블 슈팅","date":"October 18, 2022","update":null,"tags":["react","react-query","trouble-shooting"],"series":null},"fields":{"slug":"/react-query-useMutation-trouble-shooting/","readingTime":{"minutes":11.205}}},"seriesList":{"edges":[{"node":{"id":"a621dc7b-8590-5ec6-9b52-3d9e5182486d","fields":{"slug":"/appearance-background-of-jpa/"},"frontmatter":{"title":"JPA 등장배경"}}},{"node":{"id":"9d2a87b6-2b9c-5b87-b790-3426d17c2d8e","fields":{"slug":"/intellij-final-keyword/"},"frontmatter":{"title":"IntelliJ에서 메소드 추출한 메소드의 파라미터에 final 키워드 자동 추가하기"}}},{"node":{"id":"251e9767-1c92-5cf5-9cef-2c4a42c10df2","fields":{"slug":"/git-branch-strategy/"},"frontmatter":{"title":"달록팀의 git 브랜치 전략을 소개합니다."}}},{"node":{"id":"5090cce3-0c1f-5376-badc-1d25e44c1bd9","fields":{"slug":"/infinite-scroll/"},"frontmatter":{"title":"React에서 무한 스크롤 구현하기"}}},{"node":{"id":"bcb53ba5-0286-5d10-96c2-fdcb88e2cc60","fields":{"slug":"/package-structure/"},"frontmatter":{"title":"달록에 적절한 패키지 구조 고민하기"}}},{"node":{"id":"a7fc89de-f37c-596e-a81d-3d4fe5a795b8","fields":{"slug":"/data-jpa-slice-page/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"e1ba92ee-0cf0-50c8-80bd-5da5075df8d1","fields":{"slug":"/data-jpa-auditing/"},"frontmatter":{"title":"Spring Data JPA의 Auditing"}}},{"node":{"id":"3e036508-c916-504e-9e8d-89f69332471e","fields":{"slug":"/separated-interface/"},"frontmatter":{"title":"외부와 의존성 분리하기"}}},{"node":{"id":"cade544a-16ef-58a3-b97c-824986a8395f","fields":{"slug":"/apply-rest-docs/"},"frontmatter":{"title":"MockMvc를 사용한 Spring RestDocs"}}},{"node":{"id":"87649d54-d59e-58a6-afd5-8491eb4113a8","fields":{"slug":"/properties-to-object/"},"frontmatter":{"title":"properties 객체로 다루기"}}},{"node":{"id":"eb380f6d-5a00-5a9e-a916-003fb292cc8a","fields":{"slug":"/test-fixture-constant/"},"frontmatter":{"title":"테스트에서 Entity 객체를 상수로 두면 안 되는 이유"}}},{"node":{"id":"9734e30a-b430-5922-919d-f53808a56eb9","fields":{"slug":"/what_is_nginx/"},"frontmatter":{"title":"NGINX 란?"}}},{"node":{"id":"9ebc6e21-2a76-5d42-be33-c2dae8c849b2","fields":{"slug":"/ssl_protocol/"},"frontmatter":{"title":"SSL을 통한 HTTPS통신 과정"}}},{"node":{"id":"fa5ad595-1f81-5a20-a884-2da69adee3c5","fields":{"slug":"/integration-test-slice-test/"},"frontmatter":{"title":"통합 테스트와 슬라이스 테스트"}}},{"node":{"id":"d8c66823-bb05-5e83-a6a1-2fd9af450b6f","fields":{"slug":"/query-invalidation/"},"frontmatter":{"title":"React-Query에서의 데이터 최신화 (Query Invalidation)"}}},{"node":{"id":"f5187517-342f-52a1-9092-d12c1a80d132","fields":{"slug":"/seperate-components/"},"frontmatter":{"title":"컴포넌트 분리 기준"}}},{"node":{"id":"d6249c8b-bea6-5c91-8477-d3dd15ad9b39","fields":{"slug":"/test-isolation/"},"frontmatter":{"title":"테스트 격리"}}},{"node":{"id":"98e390ef-fb19-5d01-a3ef-d14bc0e65176","fields":{"slug":"/dallog-jacoco/"},"frontmatter":{"title":"달록의 Jacoco 적용기 (feat. Gradle)"}}},{"node":{"id":"33d19946-de0c-5b41-bfa0-d7c3fd80f10b","fields":{"slug":"/google-refresh-token/"},"frontmatter":{"title":"Google은 Refresh Token을 쉽게 내주지 않는다."}}},{"node":{"id":"8168857d-a82c-5608-bd40-cea4b917d17d","fields":{"slug":"/submodule/"},"frontmatter":{"title":"달록 서브모듈 도입기"}}},{"node":{"id":"836fc724-7e2f-5c7a-a42b-c0cc9163167a","fields":{"slug":"/dallog-flyway/"},"frontmatter":{"title":"달록의 데이터베이스 마이그레이션을 위한 Flyway 적용기"}}},{"node":{"id":"7a3bde6d-746b-56fd-8d91-0d8059ebf1f8","fields":{"slug":"/json-property-json-naming/"},"frontmatter":{"title":"@JsonProperty, @JsonNaming"}}},{"node":{"id":"50673f5c-f835-5982-b70c-b77e5a352a2c","fields":{"slug":"/servlet-life-cycle/"},"frontmatter":{"title":"서블릿 생명주기와 직접만든 톰캣을 통한 의문점"}}},{"node":{"id":"61e7f4d1-7b3a-5968-bfe8-c3f6efb88748","fields":{"slug":"/preparing-for-performance-test/"},"frontmatter":{"title":"톰캣 튜닝을 위한 달록의 서버 성능 테스트 준비 과정"}}},{"node":{"id":"9272061d-68c6-5f82-a961-0e2efe0fd6be","fields":{"slug":"/cyclic-dependency/"},"frontmatter":{"title":"cyclic dependency"}}},{"node":{"id":"6e779308-f266-58af-bfcc-e9fee6d39a98","fields":{"slug":"/multi-datasource-issue-with-osiv/"},"frontmatter":{"title":"대체 왜 DataSource 라우팅이 안되는거야!? (feat. OSIV)"}}},{"node":{"id":"0e63245e-c52c-5977-9f60-f94ee0fd00fc","fields":{"slug":"/hikari-cp-theory/"},"frontmatter":{"title":"HikariCP와 적절한 풀 사이즈 고민하기 (이론편)"}}},{"node":{"id":"c7bea043-345c-5f78-ae53-796a83812961","fields":{"slug":"/react-query-useMutation-trouble-shooting/"},"frontmatter":{"title":"react-query useMutation onSuccess 안 되는줄 알았던 트러블 슈팅"}}}]},"previous":{"fields":{"slug":"/hikari-cp-theory/"},"frontmatter":{"title":"HikariCP와 적절한 풀 사이즈 고민하기 (이론편)"}},"next":null},"pageContext":{"id":"c7bea043-345c-5f78-ae53-796a83812961","series":null,"previousPostId":"0e63245e-c52c-5977-9f60-f94ee0fd00fc","nextPostId":null}},"staticQueryHashes":[]}