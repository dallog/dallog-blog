{"componentChunkName":"component---src-templates-post-jsx","path":"/ssl_protocol/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"9ebc6e21-2a76-5d42-be33-c2dae8c849b2","excerpt":"이 글은 우테코 달록팀 크루 '리버'가 작성했습니다. 글을 쓰게 된 계기 우아한테크코스 레벨3 프로젝트를 진행하면서 클라이언트와 서버의 통신에 SSL 인증서를 적용하여 HTTPS 통신을 하도록 하였다.\nHTTPS의 통신과정에 대한 이해를 공유하기 위해 글을 작성하고자 한다. HTTPS 는 SSL(Secure Sokect Layer) 위에 를 얹어서 보안이…","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 '<a href=\"https://github.com/gudonghee2000\">리버</a>'가 작성했습니다.</p>\n</blockquote>\n<h2>글을 쓰게 된 계기</h2>\n<p>우아한테크코스 레벨3 프로젝트를 진행하면서 클라이언트와 서버의 통신에 SSL 인증서를 적용하여 HTTPS 통신을 하도록 하였다.\nHTTPS의 통신과정에 대한 이해를 공유하기 위해 글을 작성하고자 한다.</p>\n<h2>HTTPS</h2>\n<p><code class=\"language-text\">HTTPS</code>는 SSL(Secure Sokect Layer) 위에 <code class=\"language-text\">HTTP</code>를 얹어서 보안이 보장된 통신을 하고자하는 프로토콜이다.</p>\n<h2>SSL 인증서</h2>\n<p>클라이언트와 웹 서버간의 통신을 제3자가 보증해주는 전자문서이다.\n클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 <code class=\"language-text\">SLL 인증서</code>를 전달한다.\n클라이언트는 신뢰 할 수 있는 인증서인지 검증한 후 서버와 통신을 진행한다.\n(밑에서 자세히 설명)</p>\n<h2>SSL 인증서 사용이유</h2>\n<p>왜 HTTP 통신에 굳이 SSL 인증 과정을 붙혓을까? 이유는 다음과 같다.</p>\n<ul>\n<li>통신 내용이 악의적인 목적을 가진 사람에게 노출되는 것 을 막을 수 있다.</li>\n<li>클라이언트가 접속하는 서버가 신뢰할 수 있는 서버인지 판단 할 수 있다.</li>\n<li>통신 내용의 악의적인 변경을 방지 할 수 있다.</li>\n</ul>\n<p>SSL 통신과정은 꽤나 복잡하다.\n그래서 SSL 프로토콜을 이해하려면 우선 <code class=\"language-text\">암호화/복호화</code>와 <code class=\"language-text\">키(대칭키, 공개키)</code>에 대해 이해할 필요가 있다.</p>\n<h2>암호화, 복호화, 키</h2>\n<p>어떤 정보를 외부에 노출시키지 않기 위해 변형하는 것을 <code class=\"language-text\">암호화</code> 라고한다.\n반대로 암호화된 데이터를 원본으로 복원하는것을 <code class=\"language-text\">복호화</code>라고 한다.\n암호화와 복호화에서 데이터 변형을 위해 사용하는것을 <code class=\"language-text\">키</code>라고 한다.</p>\n<p>이렇게 키를 사용하여 <code class=\"language-text\">암호화/복호화</code> 하는 방식에는 <code class=\"language-text\">대칭키 방식</code>과 <code class=\"language-text\">공개키 방식</code>이 있다.\n두 방식 모두 <code class=\"language-text\">SSL 통신</code>에 사용되기 때문에 이해할 필요가 있다.</p>\n<h2>대칭키 방식</h2>\n<p>대칭키는 동일한 키로 <code class=\"language-text\">암호화</code>와 <code class=\"language-text\">복호화</code>를 같이 할 수 잇는 방식의 암호화 기법을 의미한다.\n<code class=\"language-text\">암호화</code>와 <code class=\"language-text\">복호화</code>를 위해 양쪽이 같은 키를 가져야 한다는 점에서 이 키를 <code class=\"language-text\">대칭키</code>라고 한다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/01b1f9b4-66ed-46d6-87d4-b18948611b80/image.JPG\"></p>\n<p>전쟁상황을 가정해서 살펴보자. <code class=\"language-text\">A진영</code>과 <code class=\"language-text\">B진영</code>이 전쟁 중일 때, 적군에게 정보를 노출하지 않으려면 <code class=\"language-text\">서로 같은 키(대칭키)</code>를 가지고 정보를 암호화 해서 전달 할 수 있을 것이다.</p>\n<p>그런데, <code class=\"language-text\">대칭키</code>는 하나의 큰 단점을 가진다. 바로 <code class=\"language-text\">대칭키</code>를 <code class=\"language-text\">A진영</code>에서 <code class=\"language-text\">B진영</code> 또는 <code class=\"language-text\">B진영</code>에서 <code class=\"language-text\">A진영</code>으로 전달 할 때,\n<code class=\"language-text\">대칭키</code>가 탈취 된다면 적군도 정보를 복호화 할 수 있다는 것이다.</p>\n<p>이런 배경에서 나온 암호화 방식이 <code class=\"language-text\">공개키 방식</code>이다.</p>\n<h2>공개키 방식</h2>\n<p><code class=\"language-text\">공개키</code>는 키가 두개가 있다.\nA키로 암호화 하면 B키로 복호화 할 수 있고 B키로 암호화 하면 A키로 복호화 하는 방식이다.</p>\n<p>이 방식에 착안해서 두개의 키 중 하나를 공개키, 하나를 비공개 키로 지정한다. </p>\n<p>그림을 통해 자세히 살펴보자.</p>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/58d5be37-7ee5-4d8f-aacb-8ea66c23ecda/image.JPG\"></p>\n<p><code class=\"language-text\">A진영</code>은 <code class=\"language-text\">공개키</code>를 <code class=\"language-text\">B진영</code>에게 전달한다.\n그리고 <code class=\"language-text\">B진영</code>은 <code class=\"language-text\">A진영</code>의 <code class=\"language-text\">공개키</code>를 통해 정보를 암호화 한 후 <code class=\"language-text\">A진영</code>에 전달한다.\n<code class=\"language-text\">A진영</code>은 <code class=\"language-text\">비공개키</code>를 통해 전달 받은 정보를 복호화한다.</p>\n<p><code class=\"language-text\">A진영</code>의 공개키가 탈취되거나 <code class=\"language-text\">B진영</code>이 전달한 정보가 탈취되어도 <code class=\"language-text\">비공개키</code>가 없으면 복호화가 불가능 하기 때문에 <code class=\"language-text\">대칭키 방식</code>의 단점을 극복 할 수 있다.</p>\n<p><code class=\"language-text\">공개키 방식</code>은 이렇게 응용 할 수 있다.\n<code class=\"language-text\">A진영</code>이 <code class=\"language-text\">비공개키</code>를 이용해서 정보를 암호화 한 후에 공개키와 함께 암호화된 정보를 <code class=\"language-text\">B진영</code>에 전달한다.</p>\n<p>그런데, 이런 응용방식은 중간에 <code class=\"language-text\">공개키</code>와 <code class=\"language-text\">암호화된 정보</code>를 탈취 당하면 적군에게 정보를 노출 당할 수 있는 문제를 가져온다.</p>\n<p>그런데 <code class=\"language-text\">SSL 통신</code>에서는 이런 응용방식을 사용한다. 그 이유가 무엇일까?</p>\n<h2>SSL 통신이 공개키 응용방식을 사용하는 이유</h2>\n<p>그 이유는 <code class=\"language-text\">공개키 응용방식</code>이 데이터 보호 목적이 아니기 때문이다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/bdfe5ab8-c202-4d3a-bd6a-34b1e46b37c3/image.JPG\"></p>\n<p><code class=\"language-text\">A진영</code>이 전달한 정보를 <code class=\"language-text\">A진영의 공개키</code>로 복호화 할 수 있다면, 정보가 <code class=\"language-text\">A진영</code>이 전달한 정보임을 신뢰 할 수 있다.</p>\n<p>즉, 공개키가 정보를 전달한 사람의 신원을 보장해주는 것이다. 이것을 전자 서명이라고 하고 <code class=\"language-text\">SSL 통신</code>에서 서버의 신원 확인을 위해 사용한다.</p>\n<h2>SSL 용어 정리</h2>\n<p>이제 SSL 통신에 사용되는 <code class=\"language-text\">대칭키 방식</code>, <code class=\"language-text\">공개키 방식</code>, <code class=\"language-text\">공개키 응용방식</code>을 살펴보았으니 SSL을 통한 통신에 대해 자세히 살펴보자.\n우선, SSL과 관련된 용어를 정리해보자.</p>\n<h3>CA</h3>\n<p>SSL 인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할을 한다.\n이 역할을 하는 민간기업들이 있는데 이런 기업들을 <code class=\"language-text\">CA(Certificate authority)</code> 라고한다.</p>\n<h3>SSL 인증서 내용</h3>\n<p><code class=\"language-text\">SSL 인증서</code>에는 다음과 같은 정보가 포함되어 있다.</p>\n<ul>\n<li>서비스의 정보 (인증서를 발급한 CA, 서비스의 도메인 등등)</li>\n<li>서버 측 공개키 (공개키의 내용, 공개키의 암호화 방법)</li>\n</ul>\n<h2>SSL 통신 과정</h2>\n<p>이제 <code class=\"language-text\">키를 사용한 3가지 통신 방법</code>을 살펴보았으니 SSL 통신과정을 이해해보자.</p>\n<p><code class=\"language-text\">SSL 통신과정</code>에서 가장 이상적인 방법은 <code class=\"language-text\">공개키 방식</code>이다.(공개키 응용방식 아님)\n<img src=\"https://velog.velcdn.com/images/gudonghee2000/post/b528a5c7-9515-4a8b-a4d8-f1341abf57d2/image.JPG\"></p>\n<p><code class=\"language-text\">클라이언트</code>와 <code class=\"language-text\">서버</code>는 각각의 <code class=\"language-text\">비공개키, 공개키</code>를 가지고\n자신의 <code class=\"language-text\">공개키</code>를 서로에게 전달한다. 이때, <code class=\"language-text\">공개키</code>는 탈취되어도 <code class=\"language-text\">비공개키</code>가 없으면 복호화가 불가능하기 때문에 보안에 취약점이 없다.</p>\n<p>그리고, <code class=\"language-text\">클라이언트</code>는 <code class=\"language-text\">서버</code>의 <code class=\"language-text\">공개키</code>로 정보를 암호화 해서 전달하고 <code class=\"language-text\">서버</code>는 전달 받은 정보를 자신의 <code class=\"language-text\">비공개키(서버 비공개키)</code>로 복호화한 뒤 정보를 처리한다.</p>\n<p>마지막으로 <code class=\"language-text\">서버</code>는 <code class=\"language-text\">클라이언트의 공개키</code>로 응답해줄 정보를 암호화해서 다시 클라이언트에게 전달한다.</p>\n<p>그런데, <code class=\"language-text\">공개키 방식</code>은 컴퓨팅 파워를 많이 쓴다고한다.(컴퓨팅 파워를 많이쓰는 정확한 이유는 모름) 그래서 성능측면에서 비효율적이다.</p>\n<p>결론적으로, <code class=\"language-text\">SSL 통신</code>은 <code class=\"language-text\">공개키 방식 + 대칭키 방식</code>을 사용하여 보안과성능 두가지 측면을 보장한다.</p>\n<p>이제 SSL 통신과정을 천천히 자세하게 살펴보자.</p>\n<blockquote>\n<p>HandShake -> 통신 -> 통신종료</p>\n</blockquote>\n<p>간단하게, SSL 통신은 위 세가지 과정으로 이루어진다.\n순서대로 하나씩 살펴보자.</p>\n<h3>HandShake(악수)</h3>\n<p>SSL 통신은 데이터를 주고 받기전에 <code class=\"language-text\">어떻게 데이터를 암호화 할지</code>, <code class=\"language-text\">믿을 만한 서버인지</code> 등에 대해 이 과정에서 확인한다.</p>\n<ol>\n<li>\n<p>클라이언트가 서버에 접속한다. 이 단계를 <code class=\"language-text\">Client Hello</code>라고 한다. 이 단계에서 주고 받는 정보는 아래와 같다.</p>\n<ul>\n<li>클라이언트 측에서 생성한 <code class=\"language-text\">랜덤 데이터</code> (밑에서 설명)</li>\n<li>클라이언트가 지원하는 암호화 방식들 => 클라이언트가 가능한 암호화 방식을 서버에 알려주기 위함</li>\n</ul>\n</li>\n<li>\n<p>서버는 <code class=\"language-text\">Client Hello</code>에 대한 응답으로 <code class=\"language-text\">Server Hello</code>를 하게 된다. 이 단계에서 주고 받는 정보는 아래와 같다.</p>\n<ul>\n<li>서버 측에서 생성한 랜덤 데이터 (밑에서 설명)</li>\n<li>서버가 선택한 클라이언트의 암호화 방식 => 선택한 암호화 방식을 클라이언트에게 알려주기 위함</li>\n<li>인증서</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">클라이언트</code>는 <code class=\"language-text\">서버의 인증서</code>가 <code class=\"language-text\">CA</code>에 의해 발급된 것인지 확인한다.\n이때, <code class=\"language-text\">클라이언트</code>에 내장된 <code class=\"language-text\">CA리스트와 CA의 공개키</code>를 사용해서 인증서를 복호화 한다. </p>\n<blockquote>\n<p>  💡 참고\n위에서 말한 공개키 응용방식의 활용\n그리고, 클라이언트(브라우저)는 CA 종류와 CA의 공개키가 내장되있음</p>\n</blockquote>\n</li>\n</ol>\n<p>  성공적으로 인증서가 복호화 됬다면, <code class=\"language-text\">서버</code>가 전달한 인증서가 <code class=\"language-text\">CA의 개인키</code>로 암호화된 문서임이 보증된 것이다.\n**  즉, 올바른 서버임을 신뢰 할수 있게된다.**</p>\n<p>  서버를 신뢰할수 있으므로 클라이언트는 <code class=\"language-text\">서버가 생성한 랜덤 데이터</code>와 <code class=\"language-text\">클라이언트가 생성한 랜덤 데이터</code>를 조합하여 <code class=\"language-text\">pre master secret</code>이라는 키를 생성한다. </p>\n<p> 이때, <code class=\"language-text\">pre master secret</code>키는 대칭키 방식으로 사용 할 것이다.\n클라이언트와 서버가 동일하게 가지고 데이터를 암호화/복호화 하는데 사용한다는 것이다.</p>\n<p> 그런데 대칭키 방식의 단점에서 살펴봤듯이 <code class=\"language-text\">pre master secret</code>를 그대로 서버에 전달하면 중간에 탈취당해 악용될수 있다.</p>\n<p> 이때, 사용하는 방법이 <code class=\"language-text\">공개키 방식</code>이다.\n<code class=\"language-text\">서버의 공개키(서버가 전달해준 인증서 내부에 들어있었음)</code>로 <code class=\"language-text\">pre master secret</code>를 암호화해서 <code class=\"language-text\">서버</code>로 전송한다.</p>\n<ol start=\"4\">\n<li><code class=\"language-text\">서버</code>는 자신의 비공개키를 통해 <code class=\"language-text\">pre master secret</code>를 복호화한다.</li>\n</ol>\n<p> 이를 통해, 클라이언트와 서버는 안전하게 같은 <code class=\"language-text\">pre master secret</code>를 가진다.\n서버와 클라이언트는 일련의 과정을 통해 <code class=\"language-text\">pre master secret</code>을 <code class=\"language-text\">master secret</code>라는 <code class=\"language-text\">session key</code>를 생성한다.\n<code class=\"language-text\">master secret</code>은 실제로 클라이언트와 서버가 주고받는 데이터를 <code class=\"language-text\">암호화/복호화</code> 하는데 사용한다.</p>\n<ol start=\"5\">\n<li>클라이언트와 서버는 <code class=\"language-text\">HandShake</code>가 종료됬음을 서로에게 알린다.</li>\n</ol>\n<h3>통신</h3>\n<p>이제 <code class=\"language-text\">master secret</code>을 통해 <code class=\"language-text\">클라이언트</code>와 <code class=\"language-text\">서버</code>는 데이터를 <code class=\"language-text\">암호화/복호화</code>하면서 주고 받는다. </p>\n<h3>통신종료</h3>\n<p>데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다.\n그리고 사용한 대칭키인 <code class=\"language-text\">master secret</code>은 폐기한다.</p>\n<h2>마치면서</h2>\n<p>이상 SSL통신에 대해서 자세하게 살펴보았다.\nSSL 통신은 <code class=\"language-text\">공개키 방식</code>, <code class=\"language-text\">대칭키 방식</code>을 합쳐서 사용하는 만큼 꽤나 복잡하다.\n작성한 글이 많은 크루들에게 HTTPS와 SSL 통신에 대한 이해에 도움이 되었으면 좋겠다.</p>\n<h2>참조</h2>\n<p><a href=\"https://opentutorials.org/course/228/4894\">https://opentutorials.org/course/228/4894</a></p>","frontmatter":{"title":"SSL을 통한 HTTPS통신 과정","date":"July 31, 2022","update":"July 31, 2022","tags":["HTTPS"],"series":null},"fields":{"slug":"/ssl_protocol/","readingTime":{"minutes":14.47}}},"seriesList":{"edges":[{"node":{"id":"a621dc7b-8590-5ec6-9b52-3d9e5182486d","fields":{"slug":"/appearance-background-of-jpa/"},"frontmatter":{"title":"JPA 등장배경"}}},{"node":{"id":"9d2a87b6-2b9c-5b87-b790-3426d17c2d8e","fields":{"slug":"/intellij-final-keyword/"},"frontmatter":{"title":"IntelliJ에서 메소드 추출한 메소드의 파라미터에 final 키워드 자동 추가하기"}}},{"node":{"id":"251e9767-1c92-5cf5-9cef-2c4a42c10df2","fields":{"slug":"/git-branch-strategy/"},"frontmatter":{"title":"달록팀의 git 브랜치 전략을 소개합니다."}}},{"node":{"id":"5090cce3-0c1f-5376-badc-1d25e44c1bd9","fields":{"slug":"/infinite-scroll/"},"frontmatter":{"title":"React에서 무한 스크롤 구현하기"}}},{"node":{"id":"bcb53ba5-0286-5d10-96c2-fdcb88e2cc60","fields":{"slug":"/package-structure/"},"frontmatter":{"title":"달록에 적절한 패키지 구조 고민하기"}}},{"node":{"id":"a7fc89de-f37c-596e-a81d-3d4fe5a795b8","fields":{"slug":"/data-jpa-slice-page/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"e1ba92ee-0cf0-50c8-80bd-5da5075df8d1","fields":{"slug":"/data-jpa-auditing/"},"frontmatter":{"title":"Spring Data JPA의 Auditing"}}},{"node":{"id":"3e036508-c916-504e-9e8d-89f69332471e","fields":{"slug":"/separated-interface/"},"frontmatter":{"title":"외부와 의존성 분리하기"}}},{"node":{"id":"cade544a-16ef-58a3-b97c-824986a8395f","fields":{"slug":"/apply-rest-docs/"},"frontmatter":{"title":"MockMvc를 사용한 Spring RestDocs"}}},{"node":{"id":"87649d54-d59e-58a6-afd5-8491eb4113a8","fields":{"slug":"/properties-to-object/"},"frontmatter":{"title":"properties 객체로 다루기"}}},{"node":{"id":"eb380f6d-5a00-5a9e-a916-003fb292cc8a","fields":{"slug":"/test-fixture-constant/"},"frontmatter":{"title":"테스트에서 Entity 객체를 상수로 두면 안 되는 이유"}}},{"node":{"id":"9734e30a-b430-5922-919d-f53808a56eb9","fields":{"slug":"/what_is_nginx/"},"frontmatter":{"title":"NGINX 란?"}}},{"node":{"id":"9ebc6e21-2a76-5d42-be33-c2dae8c849b2","fields":{"slug":"/ssl_protocol/"},"frontmatter":{"title":"SSL을 통한 HTTPS통신 과정"}}},{"node":{"id":"fa5ad595-1f81-5a20-a884-2da69adee3c5","fields":{"slug":"/integration-test-slice-test/"},"frontmatter":{"title":"통합 테스트와 슬라이스 테스트"}}},{"node":{"id":"d8c66823-bb05-5e83-a6a1-2fd9af450b6f","fields":{"slug":"/query-invalidation/"},"frontmatter":{"title":"React-Query에서의 데이터 최신화 (Query Invalidation)"}}},{"node":{"id":"f5187517-342f-52a1-9092-d12c1a80d132","fields":{"slug":"/seperate-components/"},"frontmatter":{"title":"컴포넌트 분리 기준"}}},{"node":{"id":"d6249c8b-bea6-5c91-8477-d3dd15ad9b39","fields":{"slug":"/test-isolation/"},"frontmatter":{"title":"테스트 격리"}}},{"node":{"id":"98e390ef-fb19-5d01-a3ef-d14bc0e65176","fields":{"slug":"/dallog-jacoco/"},"frontmatter":{"title":"달록의 Jacoco 적용기 (feat. Gradle)"}}}]},"previous":{"fields":{"slug":"/what_is_nginx/"},"frontmatter":{"title":"NGINX 란?"}},"next":{"fields":{"slug":"/integration-test-slice-test/"},"frontmatter":{"title":"통합 테스트와 슬라이스 테스트"}}},"pageContext":{"id":"9ebc6e21-2a76-5d42-be33-c2dae8c849b2","series":null,"previousPostId":"9734e30a-b430-5922-919d-f53808a56eb9","nextPostId":"fa5ad595-1f81-5a20-a884-2da69adee3c5"}},"staticQueryHashes":[]}