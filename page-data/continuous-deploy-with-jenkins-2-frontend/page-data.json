{"componentChunkName":"component---src-templates-post-jsx","path":"/continuous-deploy-with-jenkins-2-frontend/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"f88fe712-01b6-51ca-84a7-2ded8ef8ab98","excerpt":"이 글은 우테코 달록팀 크루 후디가 작성했습니다. 안녕하세요, 우테코 달록팀 후디입니다. 바로 직전 포스팅으로 달록팀 백엔드의 배포 환경과 지속적 배포 환경을 구축한 방법을 소개해드렸었죠. 이번 포스팅에서는 프론트엔드의 배포 환경과 지속적 배포 환경 구성을 소개해드리려고 합니다. 바로 시작할까요? 프론트엔드 CD 다이어그램  프론트엔드의 지속적 배포 과정…","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 <a href=\"https://github.com/devHudi\">후디</a>가 작성했습니다.</p>\n</blockquote>\n<p>안녕하세요, 우테코 달록팀 후디입니다. 바로 <a href=\"https://dallog.github.io/continuous-deploy-with-jenkins-1-backend/\">직전 포스팅</a>으로 달록팀 백엔드의 배포 환경과 지속적 배포 환경을 구축한 방법을 소개해드렸었죠. 이번 포스팅에서는 프론트엔드의 배포 환경과 지속적 배포 환경 구성을 소개해드리려고 합니다. 바로 시작할까요?</p>\n<h2>프론트엔드 CD 다이어그램</h2>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/91e04a38c950370c6add24f7154e184c/42d3e/fe.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 45.294117647058826%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABaklEQVQoz3VSS0vDQBDOX/fuyYuevYmgogdFwYsHqSDSqgRbiq22ia1tmqRJ9r2fs0ti66MfDJnszHzzDKy1cOKwrsvZG6BKrxuj6d3Udnr+HJCzhPO0xnzbHIKGpBGjlTfEZ9t4al2hMEQgJYQQXjQRvB9uIQzbqLQF5xy8trn4ABtQkeNFL0JaMXBWQBIxly6ZxTTLcUm2Bq42TkmN1giUUmCMUVuUeRzj/PoGZVkhjmPvPHx+xOnejtezokRRFhCMqtIc3cUI4XyI9+UMWmloR+jIkmTh2wq7fezuHyCjCkajEaKPCTrtDk6OjhGNx0iXBfkmyNIUkzzFw7SH+8kLBvl0RSjr+TgoKXxgsyBpLPqvA9y27jw5jcx3oihQWfxtmZb3Y4bZklqlQKUk3CiEkJD0lTQ7R8K58ISuCLcI5uXXUlanYhHlFr15nbWuxtbi9bXzav69mH/OxoFRBUle+eo2ofHdZPsC8ji4T1JhqTcAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='프론트엔드 지속적 배포 환경' title='프론트엔드 지속적 배포 환경' src='/static/91e04a38c950370c6add24f7154e184c/ca1dc/fe.png' srcset='/static/91e04a38c950370c6add24f7154e184c/e7570/fe.png 170w,\n/static/91e04a38c950370c6add24f7154e184c/f46e7/fe.png 340w,\n/static/91e04a38c950370c6add24f7154e184c/ca1dc/fe.png 680w,\n/static/91e04a38c950370c6add24f7154e184c/02d09/fe.png 1020w,\n/static/91e04a38c950370c6add24f7154e184c/9d567/fe.png 1360w,\n/static/91e04a38c950370c6add24f7154e184c/42d3e/fe.png 2314w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>프론트엔드 지속적 배포 환경</figcaption>\n  </figure></p>\n<p>프론트엔드의 지속적 배포 과정은 사실 백엔드과 크게 다른점이 없습니다. PR이 생성되고, 병합되고, 이 이벤트가 Webhook을 통해 젠킨스 서버에 전달됩니다.</p>\n<p>젠킨스 서버는 Webpack을 이용하여 리액트 프로젝트를 빌드하고, <code class=\"language-text\">index.html</code>과 <code class=\"language-text\">bundle.js</code>를 생성합니다. 달록의 프론트엔드 EC2 인스턴스에는 <strong>NGINX가 도커 컨테이너</strong>로 띄워져 있는데요, 생성된 정적파일은 이 NGINX 디렉토리로 전송됩니다.</p>\n<h2>파이프라인 셋업</h2>\n<h3>사전 작업</h3>\n<p>달록팀 프론트엔드 팀은 리액트를 사용합니다. 또한 달록팀은 모듈 번들러로 <strong>웹팩(Webpack)</strong>을 채택하여 사용하고 있습니다. 또한 웹팩을 사용하여 프로젝트를 빌드하기 위해서는 빌드 서버에 <strong>node.js</strong>가 설치되어있어야 합니다.</p>\n<p>이를 위해서 달록팀은 젠킨스에 <code class=\"language-text\">NodeJS</code> 플러그인을 설치했습니다. 플러그인을 설치한 이후 사용할 node.js의 버전을 선택해야합니다. <strong>Jenkins 관리 > Global Tool Configuration > NodeJS > NodeJS Installation</strong> 에 들어가 사용할 node.js 버전을 선택하고 이름을 지정해줍니다.</p>\n<p>달록팀은 개발 환경에서 node.js 16.14.0을 사용하므로 16.14.0 버전을 선택하고 이름을 <code class=\"language-text\">NodeJS 16.14.0</code>로 지정하였습니다.</p>\n<h3>파이프라인 스크립트</h3>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">pipeline <span class=\"token punctuation\">{</span>\n   agent any\n   stages <span class=\"token punctuation\">{</span>\n       <span class=\"token function\">stage</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Github'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           steps <span class=\"token punctuation\">{</span>\n               git branch<span class=\"token punctuation\">:</span> <span class=\"token string\">'develop'</span><span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">:</span> <span class=\"token string\">'https://github.com/woowacourse-teams/2022-dallog.git'</span>\n           <span class=\"token punctuation\">}</span>\n       <span class=\"token punctuation\">}</span>\n       <span class=\"token function\">stage</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Build'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           steps <span class=\"token punctuation\">{</span>\n               <span class=\"token function\">dir</span><span class=\"token punctuation\">(</span><span class=\"token string\">'frontend'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                   <span class=\"token function\">nodejs</span><span class=\"token punctuation\">(</span>nodeJSInstallationName<span class=\"token punctuation\">:</span> <span class=\"token string\">'NodeJS 16.14.0'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        sh <span class=\"token string\">'npm install &amp;&amp; npm run build'</span>\n                    <span class=\"token punctuation\">}</span>\n               <span class=\"token punctuation\">}</span>\n           <span class=\"token punctuation\">}</span>\n       <span class=\"token punctuation\">}</span>\n       <span class=\"token function\">stage</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Deploy'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           steps <span class=\"token punctuation\">{</span>\n               <span class=\"token function\">dir</span><span class=\"token punctuation\">(</span><span class=\"token string\">'frontend/dist'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                   <span class=\"token function\">sshagent</span><span class=\"token punctuation\">(</span>credentials<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'key-dallog'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        sh <span class=\"token string\">'ls'</span>\n                        sh <span class=\"token string\">'scp ./index.html ubuntu@192.168.XXX.XXX:/home/ubuntu/'</span>\n                        sh <span class=\"token string\">'scp ./bundle.js ubuntu@192.168.XXX.XXX:/home/ubuntu/'</span>\n                        sh <span class=\"token string\">'ssh ubuntu@192.168.XXX.XXX \"sudo mv ./index.html ./html &amp;&amp; sudo mv ./bundle.js ./html\"'</span>\n                   <span class=\"token punctuation\">}</span>\n               <span class=\"token punctuation\">}</span>\n           <span class=\"token punctuation\">}</span>\n       <span class=\"token punctuation\">}</span>\n   <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>Build stage</h4>\n<p><code class=\"language-text\">nodejs</code> Directive를 사용하여 사용할 NodeJS Installation의 이름을 입력하고, 실행할 명령을 입력합니다. <code class=\"language-text\">npm install</code> 로 필요한 모듈을 설치하고, <code class=\"language-text\">npm run build</code> 명령으로 빌드합니다.</p>\n<h4>Deploy stage</h4>\n<p>백엔드와 마찬가지로 <code class=\"language-text\">sshagent</code> 를 사용하여 프론트엔드 배포 서버에 SSH로 접속합니다. 빌드된 두개의 파일 <code class=\"language-text\">index.html</code>과 <code class=\"language-text\">bundle.js</code> 을 전송합니다.</p>\n<p>이후 전송된 파일을 원격지의 sudo 권한으로 <code class=\"language-text\">html</code> 디렉토리로 이동합니다. 이 <code class=\"language-text\">html</code> 디렉토리는 이후 설명하겠지만, NGINX 컨테이너 내부의 디렉토리와 마운팅된 디렉토리입니다. 배포 서버의 Docker가 sudo 권한으로 실행되고 있으므로, 파일을 해당 디렉토리로 이동시킬 때에도 sudo 권한이 필요합니다.</p>\n<h2>도커 및 NGINX 설정</h2>\n<h3>docker-compose</h3>\n<p>맨 위의 다이어그램과 같이 프론트엔드 배포 서버는 NGINX가 도커로 띄워져있습니다. 이를 위한 <strong>docker-compose.yml</strong> 내용은 아래와 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"3\"</span>\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">dallog-front</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> nginx\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./html<span class=\"token punctuation\">:</span>/usr/share/nginx/html\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token datetime number\">80:80</span></code></pre></div>\n<p><code class=\"language-text\">/usr/share/nginx/html</code> 디렉토리는 NGINX가 서빙할 정적 파일이 위치될 디렉토리입니다. 이를 컨테이너 외부의 <code class=\"language-text\">./html</code> 디렉토리와 볼륨 마운팅 설정을 해두었습니다.</p>\n<h3>클라이언트 사이드 라우팅 대응</h3>\n<p>달록은 리액트 라우터를 사용하여 클라이언트 사이드 라우팅을 구현하였습니다. 따라서 이를 위해서 NGINX에 별도 설정이 필요합니다. <code class=\"language-text\">index.html</code> 로 접속하면 html 파일을 잘 찾을 수 있지만, 그 외의 라우트로 접속한다면 html 파일 자체를 찾지 못해 404 에러를 반환하기 때문입니다.</p>\n<p>도커 내부의 <code class=\"language-text\">/etc/nginx/conf.d/default.conf</code> 파일을 열어 아래와 같이 설정을 수정합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">...\n\nlocation / {\n\t    root   /usr/share/nginx/html;\n\t    index  index.html index.htm;\n\t    try_files $uri $uri/ /index.html;\n}\n\n...</code></pre></div>\n<p>알 수 없는 라우트로 접속했을 때 자동으로 <code class=\"language-text\">index.html</code> 로 Fallback 되도록 <code class=\"language-text\">try_files</code> 설정을 추가하였습니다. 파일을 수정하고 도커 컨테이너를 재시작해주면 설정이 완료됩니다.</p>\n<h2>트러블 슈팅</h2>\n<h3>빌드 시 메모리 부족 문제</h3>\n<p>리액트 프로젝트를 빌드할 때 아래와 같은 메모리 이슈를 마주하게 되었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;--- Last few GCs --->\n\n[21854:0x147b3960]    21931 ms: Scavenge 456.7 (469.5) -> 456.4 (470.7) MB, 3.2 / 0.0 ms  (average mu = 0.381, current mu = 0.228) allocation failure\n[21854:0x147b3960]    21939 ms: Scavenge 457.4 (470.7) -> 457.2 (475.2) MB, 4.5 / 0.0 ms  (average mu = 0.381, current mu = 0.228) allocation failure\n\n\n&lt;--- JS stacktrace --->\n\nFATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory\n 1: 0xaf9c78 node::Abort() [webpack]\n 2: 0xa21a88 node::FatalError(char const*, char const*) [webpack]\n 3: 0xccdec8 v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [webpack]</code></pre></div>\n<p><strong>Jenkins 관리 > 시스템 설정 > Global Properties</strong> 에서 <code class=\"language-text\">NODE_OPTIONS</code> 환경변수를 <code class=\"language-text\">-max-old-space-size=3072</code> 로 설정하여 메모리 이슈를 해결하였습니다.</p>\n<h2>마치며</h2>\n<p>현재 생성된 PR에 대한 코드를 검사하고 정상적으로 빌드되지 않은 PR의 병합을 막기 위해 Github Actions를 사용하고 있습니다. 가능하다면 조금 더 학습하여 이후 이런 작업까지 젠킨스에서 처리하도록 할 계획이 있습니다.</p>\n<p>또한 현재 백엔드와 프론트엔드 모두 <code class=\"language-text\">develop</code> 이라는 하나의 브랜치에서 작업을 하다보니 백엔드, 프론트엔드 어느 한쪽의 코드만 병합되어도 백엔드, 프론트엔드 두개의 빌드 프로세스가 실행되는 이슈가 존재합니다. 이후에는 빌드 트리거를 조금 더 세분화하여 Github의 라벨을 기반으로 트리거 되도록 개선할 계획을 가지고 있습니다.</p>\n<p>여기까지 달록팀의 젠킨스를 사용한 달록팀의 지속적 배포 환경 구축기를 읽어주셔서 감사드립니다 🙂</p>","frontmatter":{"title":"젠킨스를 사용한 달록팀의 지속적 배포 환경 구축기 (2) - 프론트엔드편","date":"July 24, 2022","update":null,"tags":["DevOps"],"series":"달록팀 CI/CD 이야기"},"fields":{"slug":"/continuous-deploy-with-jenkins-2-frontend/","readingTime":{"minutes":8.005}}},"seriesList":{"edges":[{"node":{"id":"258c06fb-1629-5dfc-83b5-95e9d9661aa5","fields":{"slug":"/deploy-automation-with-shell-script/"},"frontmatter":{"title":"쉘 스크립트와 함께하는 달록의 스프링부트 어플리케이션 배포 자동화"}}},{"node":{"id":"d8d96885-2eec-50eb-b4d3-c72d05aca4b6","fields":{"slug":"/install-jenkins-with-docker-on-ec2/"},"frontmatter":{"title":"EC2 환경에서 도커를 활용한 젠킨스 설치하기"}}},{"node":{"id":"0aec665d-0632-510b-8307-fa4158c4c0ac","fields":{"slug":"/continuous-deploy-with-jenkins-1-backend/"},"frontmatter":{"title":"젠킨스를 사용한 달록팀의 지속적 배포 환경 구축기 (1) - 백엔드편"}}},{"node":{"id":"f88fe712-01b6-51ca-84a7-2ded8ef8ab98","fields":{"slug":"/continuous-deploy-with-jenkins-2-frontend/"},"frontmatter":{"title":"젠킨스를 사용한 달록팀의 지속적 배포 환경 구축기 (2) - 프론트엔드편"}}}]},"previous":{"fields":{"slug":"/continuous-deploy-with-jenkins-1-backend/"},"frontmatter":{"title":"젠킨스를 사용한 달록팀의 지속적 배포 환경 구축기 (1) - 백엔드편"}},"next":{"fields":{"slug":"/apply-rest-docs/"},"frontmatter":{"title":"MockMvc를 사용한 Spring RestDocs"}}},"pageContext":{"id":"f88fe712-01b6-51ca-84a7-2ded8ef8ab98","series":"달록팀 CI/CD 이야기","previousPostId":"0aec665d-0632-510b-8307-fa4158c4c0ac","nextPostId":"cade544a-16ef-58a3-b97c-824986a8395f"}},"staticQueryHashes":[]}