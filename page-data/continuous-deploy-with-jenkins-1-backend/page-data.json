{"componentChunkName":"component---src-templates-post-jsx","path":"/continuous-deploy-with-jenkins-1-backend/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"0aec665d-0632-510b-8307-fa4158c4c0ac","excerpt":"이 글은 우테코 달록팀 크루 후디가 작성했습니다. 안녕하세요, 달록팀 후디입니다. 지난번 포스팅에서 달록팀이 도커를 활용하여 EC2 인스턴스에 도커를 설치한 과정을 이야기 드렸었죠. 이번 포스팅에서는 젠킨스를 활용해서 백엔드와 프론트엔드에 지속적 배포 환경을 구성한 과정에 대해 이야기 드리려고 합니다. 달록팀 지속적 배포 환경 일단 현재 구성된 달록팀의 …","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 <a href=\"https://github.com/devHudi\">후디</a>가 작성했습니다.</p>\n</blockquote>\n<p>안녕하세요, 달록팀 후디입니다. 지난번 포스팅에서 달록팀이 도커를 활용하여 EC2 인스턴스에 도커를 설치한 과정을 이야기 드렸었죠. 이번 포스팅에서는 젠킨스를 활용해서 백엔드와 프론트엔드에 지속적 배포 환경을 구성한 과정에 대해 이야기 드리려고 합니다.</p>\n<h2>달록팀 지속적 배포 환경</h2>\n<p>일단 현재 구성된 달록팀의 지속적 배포 환경을 간단한 다이어그램으로 살펴보겠습니다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/362ecaa69f58311f8c89b2bb692cde67/2bae1/be.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 44.705882352941174%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABdElEQVQoz3VSTUvDQBDNr/fk2au99SAooiDeqgc9iYhSDy2VQm2bZNN8NN3uZ54zm0ZaaBeGTHZ23pt5M1HTNGDj0/o++Cr5Acp58J2zaLyH97vYYgRXLMFZ3rtw732LEXWAnXlK5pO/XuHtoYdEU5JzUNpAqS0YUgwuIb8H4JfWGBgyrTURuxbw1HmeppiXNbbVCso6aNdW6aiaLst4Hb58z8ARO1LKwJBmK1zdPUJkOdIkgazXqEWK/vkZ9IaAjUVR5CjLkiqzkKbGy/SeyDYkSdMCKqUghIC1BnEqcNHrYxGnSOIYs/kCo9EYN9e3GA6HkEqjqiqs12tK1phkX3j/fcJYfIQKrbWIuG92wlDosshXrfgkhaO+RFFgPJlgtlhSez7o2b03VlM3Alstg/6hwn3NNsoiy6swOSZiGSwDkDkC64T/j1HbDMIEB0PpBrOSDT6XVMXu3+9WpbNmtzbHYt1KHQAyW1Fvic2cnPz++2OxP3yMuVsRjMY3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='백엔드 지속적 배포 환경' title='백엔드 지속적 배포 환경' src='/static/362ecaa69f58311f8c89b2bb692cde67/ca1dc/be.png' srcset='/static/362ecaa69f58311f8c89b2bb692cde67/e7570/be.png 170w,\n/static/362ecaa69f58311f8c89b2bb692cde67/f46e7/be.png 340w,\n/static/362ecaa69f58311f8c89b2bb692cde67/ca1dc/be.png 680w,\n/static/362ecaa69f58311f8c89b2bb692cde67/02d09/be.png 1020w,\n/static/362ecaa69f58311f8c89b2bb692cde67/9d567/be.png 1360w,\n/static/362ecaa69f58311f8c89b2bb692cde67/2bae1/be.png 2308w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>백엔드 지속적 배포 환경</figcaption>\n  </figure></p>\n<p>우선, 달록의 백엔드 개발자가 열심히 기능을 개발하여 Github에 PR을 생성합니다. 이때 PR 코드가 정상적으로 빌드되고, 모든 테스트를 통과하는지 <strong>Github Actions</strong>를 사용하여 우선적으로 검사합니다. 이때, PR 브랜치의 코드가 문제가 있다면 develop 브랜치로 병합이 불가능합니다.</p>\n<blockquote>\n<p>달록팀의 브랜치 전략에 대해서는 달록팀 매트가 작성한 '<a href=\"https://dallog.github.io/git-branch-strategy/\">달록팀의 git 브랜치 전략을 소개합니다.</a>' 포스팅을 참고해주세요!</p>\n</blockquote>\n<p>정상적으로 빌드가 되는 코드는 이후 달록 개발자들끼리 코드리뷰가 진행되고, develop 브랜치에 병합이 됩니다. 이때, Github는 달록팀이 구축한 젠킨스 서버에 <strong>Webhook</strong>을 통해 병합 사실을 알립니다.</p>\n<p>Webhook이란, 특정한 애플리케이션이 다른 애플리케이션으로 <strong>이벤트 발생 정보를 실시간으로 제공하기 위한 방법</strong>입니다. 젠킨스는 외부에 Webhook URL을 열어두고, Github으로부터 이 Webhook URL로 요청을 받아 이벤트가 발생한 즉시 그 사실을 알 수 있습니다.</p>\n<p>Webhook을 통해 신호를 받은 젠킨스는 미리 지정된 젠킨스 파이프라인 스크립트를 실행하여 스프링부트 어플리케이션을 빌드하여 <code class=\"language-text\">jar</code> 파일을 생성합니다.</p>\n<p>생성한 <code class=\"language-text\">jar</code> 파일은 스프링부트 어플리케이션이 실행되고 있는 EC2 인스턴스로 전송됩니다. 그리고 스프링부트 인스턴스에서 <code class=\"language-text\">jar</code> 파일이 실행되어 배포가 완료됩니다.</p>\n<h2>프리스타일과 파이프라인</h2>\n<p>젠킨스에서 잡(Job)을 생성하는 방식은 크게 <strong>프리스타일과 파이프라인</strong> 두가지로 나뉩니다.</p>\n<h3>프리스타일</h3>\n<p>프리스타일은 <strong>GUI기반</strong>으로 젠킨스 잡을 구성할 수 있습니다. 따라서 간단한 작업에 적합하고, <strong>복잡한 작업에는 다소 적절치 않습니다.</strong> 또한 GUI 기반이므로 설정 과정이 다소 난잡하게 느껴질 수 있습니다.</p>\n<h3>파이프라인</h3>\n<p>반면 젠킨스 파이프라인은 일련의 배포 과정을 <strong>코드로 작성</strong>할 수 있습니다. 이 코드는 <strong>Jenkinsfile</strong> 라고 불리는 파일로 관리할 수 있어, Git 등을 통한 <strong>버전관리</strong>도 가능합니다. 또한 파이프라인을 사용하면 스테이지(Stage)라는 단위로 각 작업에 소요되는 시간, 실패여부를 <strong>시각화</strong>하여 확인할 수 있습니다.</p>\n<p>달록은 프리스타일 대신 젠킨스 파이프라인을 이용하여 잡(Job)을 생성했습니다. 개발자 입장에서는 아무래도 GUI보다는 코드 기반으로 작업 과정을 작성하는 것이 편하게 느껴집니다. 또한 추후 배포 프로세스 자체를 Github 저장소에서 관리할 수 있다는 것이 큰 장점으로 다가왔습니다.</p>\n<h4>Scripted vs Declarative</h4>\n<p>파이프라인도 문법에 따라 크게 <strong>Scripted Pipeline</strong>과 <strong>Declarative Pipeline</strong> 두가지로 나뉩니다.</p>\n<p>Scripted는 Groovy라는 언어로 작성되며, 변수 선언등이 지원되어 프로그래밍을 할 수 있다는 특징이 있다. 반면, Declarative는 Scripted에 비해 간단하며, Groovy를 알지 않아도 사용할 수 있다는 장점이 존재합니다. <strong>Scripted 문법은 Declarative에 비해 유연성이나 확장성이 높지만, 복잡도와 유지보수 난이도가 더 높습니다</strong>.</p>\n<p>최근 CI/CD 기조는 Declarative 스타일로 많이 이동되고 있다고 합니다 (<a href=\"https://www.theserverside.com/answer/Declarative-vs-scripted-pipelines-Whats-the-difference\">참고</a>). 당장 비교적 최근에 출시된 Github Actions 도 YAML 기반의 Declarative 스타일만 사용할 수 있습니다. 따라서 달록팀은 Declarative 문법을 사용하기로 결정했습니다.</p>\n<h2>잡(Job) 생성 및 세팅</h2>\n<h3>파이프라인으로 생성</h3>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/bb5fc7fc2233f7523c1e8c017a45a138/973af/pipeline.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABFklEQVQoz5WSyXbDIAxF/f9/120zeIZ4AINtbOMsXiUdJ216mkUX90gC8XgMSQgBzjl474WZ6nVdsSzLvwhEjBGJMQZpmiLNMpwvFzRtCz+Osolz/uB7w3dwD5tLVGdxKjQy3SO/kTjFq+qQEhKpPpUN2t5ioo3+EhuPcXaajHOAbg2MoQXTTO4mcfg7jtNE8+9hURF0zuL6+YG6rpHnObquE+vzPP/gdTGPsYDk1PsYkztcwoi2PiMvChGsqkrE+76XYwzDIPBdM8Pg5L44t9ZKD0fuEUEfVpSthdbq+VL8ytu2Ie671JLHI3/W8YWdevf7HQk3sO2iLFESSimJ7FRpLW45Z5qmkaPKD3g8CB2XfwKbYcEvY5hhgTOF7S0AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='pipeline' title='pipeline' src='/static/bb5fc7fc2233f7523c1e8c017a45a138/ca1dc/pipeline.png' srcset='/static/bb5fc7fc2233f7523c1e8c017a45a138/e7570/pipeline.png 170w,\n/static/bb5fc7fc2233f7523c1e8c017a45a138/f46e7/pipeline.png 340w,\n/static/bb5fc7fc2233f7523c1e8c017a45a138/ca1dc/pipeline.png 680w,\n/static/bb5fc7fc2233f7523c1e8c017a45a138/02d09/pipeline.png 1020w,\n/static/bb5fc7fc2233f7523c1e8c017a45a138/9d567/pipeline.png 1360w,\n/static/bb5fc7fc2233f7523c1e8c017a45a138/973af/pipeline.png 1956w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>젠킨스 메뉴에서 '새로운 Item'을 클릭하고, 'Pipeline'을 선택하여 새로운 잡을 생성합니다.</p>\n<h3>Github URL 설정</h3>\n<p><strong>General > GitHub project > Project url</strong> 에 저희 깃허브 저장소 주소인 <strong><a href=\"https://github.com/woowacourse-teams/2022-dallog\">https://github.com/woowacourse-teams/2022-dallog</a></strong> 를 입력합니다.</p>\n<h3>오래된 빌드 삭제</h3>\n<p>빌드 이력을 오래 가지고 있어봤자 큰 의미가 없을 것 같기도 하고, 아무래도 <strong>t4g.micro</strong> 에서 돌리다보니 용량이 넉넉치 않기도 합니다. 따라서 <strong>General > 오래된 빌드 삭제</strong> 옵션을 클릭하여 활성화하고, 보관할 최대 갯수를 3으로 지정했습니다.</p>\n<blockquote>\n<p>나중에 빌드 이력 보관 개수가 너무 적다고 판단되면 조금 더 늘릴 생각입니다 🙂</p>\n</blockquote>\n<h3>빌드 트리거 설정</h3>\n<p><strong>Build Triggers > GitHub hook trigger for GITScm polling</strong> 을 체크해줍니다. Github의 Webhook을 통해 빌드가 트리거되는 옵션입니다.</p>\n<blockquote>\n<p>이 기능은 <strong>GitHub plugin</strong>에서 제공하는 기능입니다. 최초 젠킨스를 설치했을 때 Install suggested plugins 를 선택하지 않으면 이 플러그인이 설치되어있지 않을수도 있습니다.</p>\n</blockquote>\n<h4>Github 저장소에 Webhook 등록하기</h4>\n<p>Webhook을 사용하려면 Github 저장소의 Settings > Webhooks 에서 Webhook URL을 등록해주어야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">http://{서비스 IP 혹은 도메인 주소}/github-webhook/</code></pre></div>\n<p>위와 같이 URL을 등록해줍니다. 이때 URL의 마지막에 <code class=\"language-text\">/</code>가 들어가지 않으면 오류가 발생하니 꼭 추가합니다.</p>\n<h2>파이프라인 작성</h2>\n<p>이제 빌드가 트리거 되었을 때 실행될 파이프라인 스크립트를 작성할 차례입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">pipeline <span class=\"token punctuation\">{</span>\n   agent any\n   stages <span class=\"token punctuation\">{</span>\n       <span class=\"token function\">stage</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Github'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           steps <span class=\"token punctuation\">{</span>\n               git branch<span class=\"token punctuation\">:</span> <span class=\"token string\">'develop'</span><span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">:</span> <span class=\"token string\">'https://github.com/woowacourse-teams/2022-dallog.git'</span>\n           <span class=\"token punctuation\">}</span>\n       <span class=\"token punctuation\">}</span>\n       <span class=\"token function\">stage</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Build'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           steps <span class=\"token punctuation\">{</span>\n               <span class=\"token function\">dir</span><span class=\"token punctuation\">(</span><span class=\"token string\">'backend'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                   sh <span class=\"token interpolation-string\"><span class=\"token string\">\"./gradlew bootJar\"</span></span>\n               <span class=\"token punctuation\">}</span>\n           <span class=\"token punctuation\">}</span>\n       <span class=\"token punctuation\">}</span>\n       <span class=\"token function\">stage</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Deploy'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           steps <span class=\"token punctuation\">{</span>\n               <span class=\"token function\">dir</span><span class=\"token punctuation\">(</span><span class=\"token string\">'backend/build/libs'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                   <span class=\"token function\">sshagent</span><span class=\"token punctuation\">(</span>credentials<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'key-dallog'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        sh <span class=\"token string\">'scp backend-0.0.1-SNAPSHOT.jar ubuntu@192.168.XXX.XXX:/home/ubuntu'</span>\n                        sh <span class=\"token string\">'ssh ubuntu@192.168.XXX.XXX \"sh run.sh\" &amp;'</span>\n                   <span class=\"token punctuation\">}</span>\n               <span class=\"token punctuation\">}</span>\n           <span class=\"token punctuation\">}</span>\n       <span class=\"token punctuation\">}</span>\n   <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Github stage</h3>\n<p>Github stage에서는 사용할 깃허브의 저장소 주소와 브랜치를 설정합니다. 젠킨스는 이 스테이지에 명시된 저장소와 브랜치를 기준으로 코드를 가져옵니다.</p>\n<h3>Build stage</h3>\n<p><code class=\"language-text\">gradlew</code> 파일을 사용하여 빌드합니다. 이때, <code class=\"language-text\">dir</code> 지시어(Directive)를 사용하여 명령을 수행할 디렉토리를 지정할 수 있습니다.</p>\n<h3>Deploy stage</h3>\n<blockquote>\n<p>이 작업을 위해서 사전에 Jenkins 관리 > Manage Credentials 에서 'SSH Username with private key' 로 AWS에서 발급 받은 PEM 키를 먼저 등록해야합니다.</p>\n</blockquote>\n<p>달록팀은 SSH Agent 플러그인을 사용하여 배포 서버에 원격으로 접속합니다. SSH Agent 플러그인을 사용하여 파이프라인에서 젠킨스에 등록해둔 SSH 자격증명을 쉽게 사용할 수 있습니다. 플러그인을 설치하면 <code class=\"language-text\">sshagent</code> 라는 Directive를 사용할 수 있는데, 인자로 사전에 젠킨스 Credential로 등록한 PEM키의 이름을 넣어줍니다. 이렇게 만들어진 <code class=\"language-text\">sshagent</code> Directive Block 내부에서 <code class=\"language-text\">sh</code> 를 통해 <code class=\"language-text\">ssh</code> 관련 명령을 수행할 수 있습니다.</p>\n<h4>jar 파일 전송</h4>\n<p>SCP(Secure Copy)는 SSH 통신 기반으로 원격지에 파일이나 디렉토리를 전송할 수 있는 프로토콜입니다. 리눅스에서는 <code class=\"language-text\">scp</code> 명령을 통해 SCP 프로토콜을 사용할 수 있습니다. 달록팀은 이 <code class=\"language-text\">scp</code> 명령을 통해 스프링부트 애플리케이션이 실행되고 있는 EC2 인스턴스로 빌드된 <code class=\"language-text\">jar</code> 파일을 전송합니다.</p>\n<blockquote>\n<p>여기서 IP주소가 프라이빗 IP로 적혀있습니다. 우테코에서 제공되는 EC2 인스턴스의 보안그룹 설정상 잠실 및 선릉 캠퍼스의 IP로만 SSH(22번 포트) 인바운드가 허용되어 있습니다. 따라서 퍼블릭 IP 대신 프라이빗 IP로 지정해주었습니다. 프라이빗 IP를 사용해도 두 EC2 인스턴스가 같은 VPC에 존재하므로 정상적으로 접근이 가능합니다.</p>\n</blockquote>\n<h4>원격지의 쉘 스크립트 실행</h4>\n<p>스프링부트 인스턴스에는 사전에 <code class=\"language-text\">run.sh</code> 라는 이름의 쉘 스크립트가 작성되어 있습니다. 이 쉘 스크립트는 현재 실행중인 스프링부트 애플리케이션의 프로세스를 제거하고, 환경변수를 설정하고, 같은 디렉토리에 있는 <code class=\"language-text\">jar</code> 파일을 실행합니다. 스크립트는 아래와 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token shebang important\">#! /bin/bash</span>\n\n<span class=\"token assign-left variable\">PROJECT_NAME</span><span class=\"token operator\">=</span>backend\n<span class=\"token assign-left variable\">CURRENT_PID</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>pgrep <span class=\"token parameter variable\">-f</span> $<span class=\"token punctuation\">{</span>PROJECT_NAME<span class=\"token punctuation\">}</span>-.*.jar <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-n</span> <span class=\"token number\">1</span><span class=\"token variable\">)</span></span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-z</span> <span class=\"token string\">\"<span class=\"token variable\">$CURRENT_PID</span>\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"🌈 구동중인 애플리케이션이 없으므로 종료하지 않습니다.\"</span>\n<span class=\"token keyword\">else</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"🌈 구동중인 애플리케이션을 종료했습니다. (pid : <span class=\"token variable\">$CURRENT_PID</span>)\"</span>\n    <span class=\"token function\">kill</span> <span class=\"token parameter variable\">-15</span> <span class=\"token variable\">$CURRENT_PID</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\n\">\\n</span>🌈 SpringBoot 환경변수 설정\"</span>\n\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">GOOGLE_CLIENT_ID</span><span class=\"token operator\">=</span><span class=\"token string\">\"XXXXXXXXXXXXXX\"</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">GOOGLE_CLIENT_SECRET</span><span class=\"token operator\">=</span><span class=\"token string\">\"XXXXXXXXXXXXXX\"</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">GOOGLE_REDIRECT_URI</span><span class=\"token operator\">=</span><span class=\"token string\">\"XXXXXXXXXXXXXX\"</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">GOOGLE_TOKEN_URI</span><span class=\"token operator\">=</span><span class=\"token string\">\"XXXXXXXXXXXXXX\"</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">JWT_EXPIRE_LENGTH</span><span class=\"token operator\">=</span><span class=\"token number\">86400000</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">JWT_SECRET_KEY</span><span class=\"token operator\">=</span><span class=\"token string\">\"XXXXXXXXXXXXXX\"</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\n\">\\n</span>🌈 SpringBoot 애플리케이션을 실행합니다.<span class=\"token entity\" title=\"\\n\">\\n</span>\"</span>\n\n<span class=\"token assign-left variable\">JAR_NAME</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">ls</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> .jar <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-n</span> <span class=\"token number\">1</span><span class=\"token variable\">)</span></span>\n<span class=\"token function\">sudo</span> <span class=\"token parameter variable\">-E</span> <span class=\"token function\">nohup</span> <span class=\"token function\">java</span> <span class=\"token parameter variable\">-jar</span> /home/ubuntu/<span class=\"token variable\">$JAR_NAME</span> <span class=\"token operator\">&amp;</span></code></pre></div>\n<p>지난 포스팅인 <strong><a href=\"/deploy-automation-with-shell-script\">쉘 스크립트와 함께하는 달록의 스프링부트 어플리케이션 배포 자동화</a></strong> 에서 소개드린 쉘 스크립트에서 소스코드를 Pull 해오고 빌드하는 과정만 사라진 스크립트입니다.</p>\n<p>이 원격지에 있는 스크립트를 <code class=\"language-text\">ssh</code> 명령을 통해 실행하게되면 배포과정이 완료됩니다.</p>\n<h2>트러블슈팅</h2>\n<h3>Webhook 트리거 이슈</h3>\n<p>처음 젠킨스를 설정할 때 아무리 Webhook 설정을 건드려봐도 빌드가 트리거되지 않는 이슈가 발생했었습니다.</p>\n<p>먼저 위 파이프라인 스크립트의 Github 스테이지에서 사용된 <code class=\"language-text\">git</code> Directive를 명시적으로 사용해줘야합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git branch: 'develop', url: 'https://github.com/woowacourse-teams/2022-dallog.git'</code></pre></div>\n<p>또한 최초로 '지금 빌드' 버튼을 클릭해야지 그 이후 Webhook 요청을 수신할 수 있게됩니다.</p>\n<h3>SSH 자격 증명 이슈</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Host key verification failed.\nlost connection</code></pre></div>\n<p>젠킨스 서버에서 다른 인스턴스에 최초로 SSH 연결을 시도할 경우 젠킨스에서 위와 같은 에러가 발생할 수 있습니다. 다들 SSH로 최초 원격접속 시 아래와 같은 메시지를 본 적이 있을 것 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">root@XXXXXXXX:/home# ssh -i key.pem ubuntu@192.168.XXX.XXX\nThe authenticity of host '192.168.XXX.XXX (192.168.XXX.XXX)' can't be established.\nECDSA key fingerprint is SHA256:XXXXXXXXXXXXXXXX\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes</code></pre></div>\n<p>터미널에서 직접 접속할 때에는 yes 를 입력하면, 곧바로 접속될텐데요. 젠킨스 파이프라인에서는 불가능합니다. 따라서 미리 젠킨스 측의 <code class=\"language-text\">known_hosts</code> 에 원격지의 공개키를 등록해야합니다.</p>\n<p><code class=\"language-text\">keyscan</code> 명령을 통해서 호스트의 공개키를 수집할 수 있습니다. 이 명령을 통해서 <code class=\"language-text\">~/.ssh/known_hosts</code> 에 접속할 호스트의 공개키를 추가해야합니다.</p>\n<h2>마치며</h2>\n<p>이번 포스팅으로 달록팀이 젠킨스를 활용하여 스프링부트 애플리케이션의 지속적 배포 환경을 구축한 방법을 소개드렸습니다. 이어지는 다음 포스팅에서는 달록팀의 프론트엔드 배포 환경과 지속적 배포 환경 구축 방법을 소개드리려고 합니다. 읽어주셔서 감사드립니다 😄</p>","frontmatter":{"title":"젠킨스를 사용한 달록팀의 지속적 배포 환경 구축기 (1) - 백엔드편","date":"July 24, 2022","update":null,"tags":["DevOps"],"series":"달록팀 CI/CD 이야기"},"fields":{"slug":"/continuous-deploy-with-jenkins-1-backend/","readingTime":{"minutes":15.485}}},"seriesList":{"edges":[{"node":{"id":"258c06fb-1629-5dfc-83b5-95e9d9661aa5","fields":{"slug":"/deploy-automation-with-shell-script/"},"frontmatter":{"title":"쉘 스크립트와 함께하는 달록의 스프링부트 어플리케이션 배포 자동화"}}},{"node":{"id":"d8d96885-2eec-50eb-b4d3-c72d05aca4b6","fields":{"slug":"/install-jenkins-with-docker-on-ec2/"},"frontmatter":{"title":"EC2 환경에서 도커를 활용한 젠킨스 설치하기"}}},{"node":{"id":"0aec665d-0632-510b-8307-fa4158c4c0ac","fields":{"slug":"/continuous-deploy-with-jenkins-1-backend/"},"frontmatter":{"title":"젠킨스를 사용한 달록팀의 지속적 배포 환경 구축기 (1) - 백엔드편"}}},{"node":{"id":"f88fe712-01b6-51ca-84a7-2ded8ef8ab98","fields":{"slug":"/continuous-deploy-with-jenkins-2-frontend/"},"frontmatter":{"title":"젠킨스를 사용한 달록팀의 지속적 배포 환경 구축기 (2) - 프론트엔드편"}}},{"node":{"id":"63ed4d50-249e-5bcb-8140-5bd443937c9f","fields":{"slug":"/jenkins-pipeline-from-scm/"},"frontmatter":{"title":"젠킨스 파이프라인 스크립트 형상 관리"}}},{"node":{"id":"a3c7cbae-6f4f-54c3-84e1-8e63102179c1","fields":{"slug":"/jenkins-build-optimization/"},"frontmatter":{"title":"젠킨스 빌드 최적화를 향한 여정"}}}]},"previous":{"fields":{"slug":"/separated-interface/"},"frontmatter":{"title":"외부와 의존성 분리하기"}},"next":{"fields":{"slug":"/continuous-deploy-with-jenkins-2-frontend/"},"frontmatter":{"title":"젠킨스를 사용한 달록팀의 지속적 배포 환경 구축기 (2) - 프론트엔드편"}}},"pageContext":{"id":"0aec665d-0632-510b-8307-fa4158c4c0ac","series":"달록팀 CI/CD 이야기","previousPostId":"3e036508-c916-504e-9e8d-89f69332471e","nextPostId":"f88fe712-01b6-51ca-84a7-2ded8ef8ab98"}},"staticQueryHashes":[]}