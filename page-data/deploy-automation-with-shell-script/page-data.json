{"componentChunkName":"component---src-templates-post-jsx","path":"/deploy-automation-with-shell-script/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"258c06fb-1629-5dfc-83b5-95e9d9661aa5","excerpt":"이 글은 우테코 달록팀 크루 후디가 작성했습니다. 웹서비스 개발팀은 새롭게 개발한 서비스의 기능을 어떻게 사용자에게 전달할까요? 새로운 기능이 메인 브랜치에 병합될 때 마다 EC2 인스턴스에 접속하여 브랜치를 Pull 하고, 프로젝트를 빌드하고, 현재 동작중인 어플리케이션의 프로세스를 종료하고, 새롭게 빌드된 어플리케이션의 프로세스를 띄우는 과정... 배…","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 <a href=\"https://github.com/devHudi\">후디</a>가 작성했습니다.</p>\n</blockquote>\n<p>웹서비스 개발팀은 새롭게 개발한 서비스의 기능을 어떻게 사용자에게 전달할까요? 새로운 기능이 메인 브랜치에 병합될 때 마다 EC2 인스턴스에 접속하여 브랜치를 Pull 하고, 프로젝트를 빌드하고, 현재 동작중인 어플리케이션의 프로세스를 종료하고, 새롭게 빌드된 어플리케이션의 프로세스를 띄우는 과정...</p>\n<p>배포가 필요할때마다 이런 명령을 수동으로 일일히 입력한다면, 그건 너무 지루한 작업아닐까요? 😫 실수라도 하면 어쩌죠? 😰</p>\n<p>우테코 달록팀 백엔드는 이런 한계점을 극복하고자 쉘 스크립트를 활용하여 배포 프로세스를 자동화하였습니다. 달록팀은 어떻게 스프링부트 어플리케이션의 배포를 자동화했을까요?</p>\n<h2>쉘 스크립트</h2>\n<p>쉘 스크립트는 유닉스/리눅스 기반 운영체제에서의 일련의 명령으로 구성된 실행가능한 텍스트 파일입니다. 원래라면 일일히 키보드로 입력해야하는 리눅스 명령을 하나의 파일에 모아두고, 한번에 실행할 수 있죠. 작성된 명령은 셸이라고 불리는 명령줄 인터프리터에서 실행되며, 위에서부터 아래로 차례로 실행됩니다. 이 쉘 스크립트를 이용해 리눅스 환경에서 여러 프로세스를 자동화할 수 있습니다.</p>\n<p>달록이 스프링부트 어플리케이션을 배포하는 환경은 Ubuntu 22 버전이므로 쉘 스크립트를 활용할 수 있습니다.</p>\n<h2>수동으로 배포하기</h2>\n<p>배포 프로세스를 자동화하려면 우선 수동으로 어떤 명령을 사용해서 배포를 하는지 알아야합니다. 어떤과정을 거쳐 배포되는지부터 알아볼까요?</p>\n<blockquote>\n<p>레포지토리는 이미 Clone 되어있다고 가정합니다.</p>\n</blockquote>\n<h3>1. Git Pull</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token builtin class-name\">cd</span> <span class=\"token number\">2022</span>-dallog/backend\n$ <span class=\"token function\">git</span> pull</code></pre></div>\n<p>우선 Github에서 가장 최신 버전을 pull 해와야겠죠?</p>\n<h3>2. 빌드</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">./gradlew bootJar</code></pre></div>\n<p><code class=\"language-text\">gradlew</code> 를 사용하여 자바 프로젝트를 빌드해서 <code class=\"language-text\">.jar</code> 파일을 생성합니다.</p>\n<h3>3. 프로세스 종료</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token function\">ps</span> -ef <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> jar\n$ <span class=\"token function\">kill</span> -15 XXXXX</code></pre></div>\n<p><code class=\"language-text\">ps</code> 명령을 사용해서 실행중인 스프링부트 어플리케이션의 PID를 알아내고, <code class=\"language-text\">kill</code> 명령을 통해 프로세스를 종료합니다.</p>\n<h3>4. 환경변수 설정</h3>\n<p>달록의 스프링부트 어플리케이션은 여러 민감한 정보를 환경변수를 사용하여 외부에 노출되지 않도록 하였습니다. 따라서 어플리케이션이 실행될 때 환경변수도 함께 설정을 해주어야합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">GOOGLE_CLIENT_ID</span><span class=\"token operator\">=</span><span class=\"token string\">\"XXXXX\"</span>\n$ <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">GOOGLE_CLIENT_SECRET</span><span class=\"token operator\">=</span><span class=\"token string\">\"XXXXX\"</span>\n$ <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">GOOGLE_REDIRECT_URI</span><span class=\"token operator\">=</span><span class=\"token string\">\"XXXXX\"</span>\n$ <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">GOOGLE_TOKEN_URI</span><span class=\"token operator\">=</span><span class=\"token string\">\"XXXXX\"</span>\n$ <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">JWT_SECRET_KEY</span><span class=\"token operator\">=</span><span class=\"token string\">\"XXXXX\"</span>\n$ <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">JWT_EXPIRE_LENGTH</span><span class=\"token operator\">=</span><span class=\"token number\">3600</span>\n\n<span class=\"token punctuation\">..</span>.</code></pre></div>\n<h3>5. 드디어 실행</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token function\">sudo</span> -E <span class=\"token function\">nohup</span> java -jar ./build/libs/backend-0.0.1-SNAPSHOT.jar</code></pre></div>\n<p>드디어 스프링부트 어플리케이션을 실행합니다.</p>\n<p>이 귀찮은 과정을 배포 할때마다 해야한다니 벌써 머리가 어질어질 하네요. 😵‍💫 그렇다면 앞서 소개드린 쉘 스크립트를 통해서 이 과정을 자동화해볼까요?</p>\n<h2>달록의 배포 쉘 스크립트</h2>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token shebang important\">#! /bin/bash</span>\n\n<span class=\"token assign-left variable\">PROJECT_PATH</span><span class=\"token operator\">=</span>/home/ubuntu/2022-dallog\n<span class=\"token assign-left variable\">PROJECT_NAME</span><span class=\"token operator\">=</span>backend\n<span class=\"token assign-left variable\">PROJECT_BUILD_PATH</span><span class=\"token operator\">=</span>backend/build/libs\n\n<span class=\"token builtin class-name\">cd</span> <span class=\"token variable\">$PROJECT_PATH</span>/<span class=\"token variable\">$PROJECT_NAME</span>\n\n<span class=\"token function\">clear</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"🌈 Github에서 프로젝트를 Pull 합니다.<span class=\"token entity\" title=\"\\n\">\\n</span>\"</span>\n\n<span class=\"token function\">git</span> pull\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\n\">\\n</span>🌈 SpringBoot 프로젝트 빌드를 시작합니다.<span class=\"token entity\" title=\"\\n\">\\n</span>\"</span>\n\n./gradlew bootJar\n\n<span class=\"token assign-left variable\">CURRENT_PID</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>pgrep -f $<span class=\"token punctuation\">{</span>PROJECT_NAME<span class=\"token punctuation\">}</span>-.*.jar <span class=\"token operator\">|</span> <span class=\"token function\">head</span> -n <span class=\"token number\">1</span><span class=\"token variable\">)</span></span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> -z <span class=\"token string\">\"<span class=\"token variable\">$CURRENT_PID</span>\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n\t<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"🌈 구동중인 애플리케이션이 없으므로 종료하지 않습니다.\"</span>\n<span class=\"token keyword\">else</span>\n\t<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"🌈 구동중인 애플리케이션을 종료했습니다. (pid : <span class=\"token variable\">$CURRENT_PID</span>)\"</span>\n\t<span class=\"token function\">kill</span> -15 <span class=\"token variable\">$CURRENT_PID</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\n\">\\n</span>🌈 SpringBoot 환경변수 설정\"</span>\n\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">GOOGLE_CLIENT_ID</span><span class=\"token operator\">=</span><span class=\"token string\">\"XXXXX\"</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">GOOGLE_CLIENT_SECRET</span><span class=\"token operator\">=</span><span class=\"token string\">\"XXXXX\"</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">GOOGLE_REDIRECT_URI</span><span class=\"token operator\">=</span><span class=\"token string\">\"XXXXX\"</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">GOOGLE_TOKEN_URI</span><span class=\"token operator\">=</span><span class=\"token string\">\"XXXXX\"</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">JWT_SECRET_KEY</span><span class=\"token operator\">=</span><span class=\"token string\">\"XXXXX\"</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">JWT_EXPIRE_LENGTH</span><span class=\"token operator\">=</span><span class=\"token number\">3600</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\n\">\\n</span>🌈 SpringBoot 애플리케이션을 실행합니다.<span class=\"token entity\" title=\"\\n\">\\n</span>\"</span>\n\n<span class=\"token assign-left variable\">JAR_PATH</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">ls</span> $PROJECT_PATH/$PROJECT_BUILD_PATH/ <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> .jar <span class=\"token operator\">|</span> <span class=\"token function\">head</span> -n <span class=\"token number\">1</span><span class=\"token variable\">)</span></span>\n<span class=\"token function\">sudo</span> -E <span class=\"token function\">nohup</span> java -jar <span class=\"token variable\">$PROJECT_PATH</span>/<span class=\"token variable\">$PROJECT_BUILD_PATH</span>/<span class=\"token variable\">$JAR_PATH</span> <span class=\"token operator\">&amp;</span></code></pre></div>\n<p>달록이 작성한 배포 자동화 쉘 스크립트는 아래와 같습니다. 차근차근 알아볼까요?</p>\n<h3>#! /bin/bash</h3>\n<p><code class=\"language-text\">#! /bin/bash</code> 은 해당 쉘 스크립트가 많은 쉘 중 <strong>Bash Shell 로 실행됨</strong>을 알립니다.</p>\n<h3>변수 사용</h3>\n<p><code class=\"language-text\">PROJECT_PATH</code>, <code class=\"language-text\">PROJECT_NAME</code> 과 같이 자주 사용되는 데이터는 쉘 스크립트에서 제공하는 변수 기능으로 분리하였습니다. 이때 주의할 점은 쉘 스크립트에서 변수를 선언할 때 <code class=\"language-text\">=</code> <strong>앞뒤에 공백이 와서는 안된다는 점</strong> 입니다.</p>\n<h3>echo</h3>\n<p><code class=\"language-text\">echo</code> 명령을 통해 배포 프로세스가 어디까지 진행됐는지 사용자에게 알려줍니다.</p>\n<h3>실행중인 어플리케이션의 PID 가져오기</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token assign-left variable\">CURRENT_PID</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>pgrep -f $<span class=\"token punctuation\">{</span>PROJECT_NAME<span class=\"token punctuation\">}</span>-.*.jar <span class=\"token operator\">|</span> <span class=\"token function\">head</span> -n <span class=\"token number\">1</span><span class=\"token variable\">)</span></span></code></pre></div>\n<h4>pgrep</h4>\n<p>쉘 스크립트 중 위와 같은 코드가 있었습니다. 위 코드는 우선 <code class=\"language-text\">pgrep</code> 이라는 명령을 통해서 실행중인 프로세스의 이름으로 PID 목록을 가져옵니다.</p>\n<h4>pipe와 head</h4>\n<p>그리고 파이프(<code class=\"language-text\">|</code>)명령으로 다른 프로세스로 PID 목록을 보냅니다. PID 목록은 <code class=\"language-text\">head</code> 명령으로 전달되며, <code class=\"language-text\">head</code> 명령은 PID 목록의 첫번째만을 가져옵니다.</p>\n<h4>명령의 실행결과를 변수에 담기</h4>\n<p>이렇게 가져온 PID는 <code class=\"language-text\">$()</code> 문법을 통해 <code class=\"language-text\">CURRENT_PID</code> 변수에 저장됩니다. <code class=\"language-text\">$()</code> 는 <code class=\"language-text\">$(command)</code> 형태로 사용되며, 괄호 내부의 실행 결과를 변수로 저장하기 위해 사용됩니다.</p>\n<h3>조건문</h3>\n<p>쉘 스크립트에도 <code class=\"language-text\">if</code> 문을 사용하여 조건문을 작성할 수 있습니다. 다만, 우리에게 익숙한 프로그래밍 언어에서의 if문과는 조금 괴리가 존재해서 별도로 학습이 필요할수도 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> -z <span class=\"token string\">\"<span class=\"token variable\">$CURRENT_PID</span>\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n\t<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"🌈 구동중인 애플리케이션이 없으므로 종료하지 않습니다.\"</span>\n<span class=\"token keyword\">else</span>\n\t<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"🌈 구동중인 애플리케이션을 종료했습니다. (pid : <span class=\"token variable\">$CURRENT_PID</span>)\"</span>\n\t<span class=\"token function\">kill</span> -15 <span class=\"token variable\">$CURRENT_PID</span>\n<span class=\"token keyword\">fi</span></code></pre></div>\n<p>위 코드는 아까 PID를 담은 <code class=\"language-text\">CURRENT_PID</code> 가 비어있는지 확인한 후 존재하지 않다면 메시지만 출력하고, 존재한다면 해당 PID를 <code class=\"language-text\">kill</code> 명령으로 종료합니다.</p>\n<p>쉘 스크립트의 <code class=\"language-text\">if</code> 문에서 <code class=\"language-text\">-z</code> 는 조건식의 종류 중 하나이며, 주어진 문자열의 길이가 0이라면 True를 나타냅니다. 확실히 조금 낯설죠? 😅</p>\n<h3>JAR파일 경로 가져오기</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token assign-left variable\">JAR_PATH</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">ls</span> $PROJECT_PATH/$PROJECT_BUILD_PATH/ <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> .jar <span class=\"token operator\">|</span> <span class=\"token function\">head</span> -n <span class=\"token number\">1</span><span class=\"token variable\">)</span></span></code></pre></div>\n<p><code class=\"language-text\">ls</code> 명령을 통해 빌드 디렉토리의 파일 목록을 가져오고, <code class=\"language-text\">grep</code> 명령을 통해 <code class=\"language-text\">.jar</code> 파일만을 가져옵니다. 그다음 <code class=\"language-text\">head</code> 명령을 통해 단 하나의 파일만을 가져온 다음, <code class=\"language-text\">JAR_PATH</code> 변수에 저장합니다.</p>\n<h3>어플리케이션 실행하기</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">sudo</span> -E <span class=\"token function\">nohup</span> java -jar <span class=\"token variable\">$PROJECT_PATH</span>/<span class=\"token variable\">$PROJECT_BUILD_PATH</span>/<span class=\"token variable\">$JAR_PATH</span> <span class=\"token operator\">&amp;</span></code></pre></div>\n<p>어플리케이션을 실행합니다.</p>\n<h4>sudo -E</h4>\n<p><code class=\"language-text\">sudo</code> 명령 뒤에 붙은 <code class=\"language-text\">-E</code> 옵션은 유저가 설정한 환경변수를 <code class=\"language-text\">sudo</code> 명령에서도 공유하여 사용할 수 있도록 만드는 옵션입니다.</p>\n<h4>nohup</h4>\n<p><code class=\"language-text\">nohup</code> 명령은 현재 <strong>터미널 세션이 끊어져도 프로세스가 계속 살아있도록</strong> 만들기 위해 사용되는 명령입니다.</p>\n<h4>Background 프로세스</h4>\n<p>그리고 명령 맨 뒤에 <code class=\"language-text\">&amp;</code> 가 붙어있는데, 프로세스를 Foreground가 아닌 <strong>Background에서 실행</strong>하기 위해 붙여줍니다.</p>\n<h2>한계점</h2>\n<p>하지만, 이런 방식도 결국 한계점이 존재합니다. 특히나 달록과 같이 애자일한 조직에서는 최대한 작은 기능단위로 개발이 병렬적으로 진행되어, 메인 브랜치에 머지됩니다. 하루에 몇번이고 배포를 해야하는 상황이 발생할수도 있죠.\n그렇지 않아도 모든 개발자가 바쁘게 새로운 기능을 개발하기 바쁜데, 메인 브랜치에 병합된 시점마다 EC2 인스턴스에 접속해서 쉘 스크립트를 실행해야할까요?</p>\n<p>이런 한계점을 극복하고자, 달록팀은 앞으로 CI/CD 도구를 도입할 예정입니다. 세상에는 참 다양한 CI/CD 도구가 존재합니다. Jenkins, Github Actions, Travis CI, Circle CI, Gitlab CI/CD 등등...</p>\n<p>달록의 이번 스프린트의 배포 태스크에서는 이런 다양한 CI/CD 도구들의 장단을 분석하고 도입할 예정입니다. 많은 기대 부탁드립니다. 👏👏</p>","frontmatter":{"title":"쉘 스크립트와 함께하는 달록의 스프링부트 어플리케이션 배포 자동화","date":"July 19, 2022","update":null,"tags":["DevOps"],"series":"달록팀 CI/CD 이야기"},"fields":{"slug":"/deploy-automation-with-shell-script/","readingTime":{"minutes":11.12}}},"seriesList":{"edges":[{"node":{"id":"258c06fb-1629-5dfc-83b5-95e9d9661aa5","fields":{"slug":"/deploy-automation-with-shell-script/"},"frontmatter":{"title":"쉘 스크립트와 함께하는 달록의 스프링부트 어플리케이션 배포 자동화"}}},{"node":{"id":"d8d96885-2eec-50eb-b4d3-c72d05aca4b6","fields":{"slug":"/install-jenkins-with-docker-on-ec2/"},"frontmatter":{"title":"EC2 환경에서 도커를 활용한 젠킨스 설치하기"}}},{"node":{"id":"0aec665d-0632-510b-8307-fa4158c4c0ac","fields":{"slug":"/continuous-deploy-with-jenkins-1-backend/"},"frontmatter":{"title":"젠킨스를 사용한 달록팀의 지속적 배포 환경 구축기 (1) - 백엔드편"}}},{"node":{"id":"f88fe712-01b6-51ca-84a7-2ded8ef8ab98","fields":{"slug":"/continuous-deploy-with-jenkins-2-frontend/"},"frontmatter":{"title":"젠킨스를 사용한 달록팀의 지속적 배포 환경 구축기 (2) - 프론트엔드편"}}}]},"previous":{"fields":{"slug":"/data-jpa-auditing/"},"frontmatter":{"title":"Spring Data JPA의 Auditing"}},"next":{"fields":{"slug":"/mechanism-of-jpa/"},"frontmatter":{"title":"JPA 작동 메커니즘"}}},"pageContext":{"id":"258c06fb-1629-5dfc-83b5-95e9d9661aa5","series":"달록팀 CI/CD 이야기","previousPostId":"e1ba92ee-0cf0-50c8-80bd-5da5075df8d1","nextPostId":"27e0338e-3bf4-50e6-9280-70f1ee8da256"}},"staticQueryHashes":[]}