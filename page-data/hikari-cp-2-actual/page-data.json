{"componentChunkName":"component---src-templates-post-jsx","path":"/hikari-cp-2-actual/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"2ab919f2-9c8e-543b-b370-8f7e77ae67ad","excerpt":"이 글은 우테코 달록팀 크루 매트가 작성했습니다. HikariCP와 적절한 풀 사이즈 고민하기 (2) - 삽질편 About Pool Sizing HikariCP 공식 문서에 따르면 디스크 및 네트워크의  시간을 고려하면 아래와 같은 공식을 제안했다. 또한 여러 데이터베이스에도 적용할 수 있다고 언급되어 있다.  connections = (corecount…","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 <a href=\"https://github.com/hyeonic\">매트</a>가 작성했습니다.</p>\n</blockquote>\n<h2>HikariCP와 적절한 풀 사이즈 고민하기 (2) - 삽질편</h2>\n<p><a href=\"https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing\">About Pool Sizing</a></p>\n<p>HikariCP 공식 문서에 따르면 디스크 및 네트워크의 <code class=\"language-text\">block</code> 시간을 고려하면 아래와 같은 공식을 제안했다. 또한 여러 데이터베이스에도 적용할 수 있다고 언급되어 있다. </p>\n<blockquote>\n<p><em>connections = (core<em>count * 2) + effective</em>spindle_count</em></p>\n</blockquote>\n<h2>서버 사양 살펴보기</h2>\n<p>우선 현재 우리가 사용하고 있는 데이터베이스 서버의 사양을 살펴보자.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/0353a9d59b18d3cb3324b50081234538/9a8ca/t4gmicro.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 45.88235294117647%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAABeUlEQVQoz01Qy27bMBD0//9Ce8mpPTkPpGnQr2iDPODYkmxLskSKXJG7S0pOWqCj5lJguJiZnSEBrqq6fdzsnjbFw8s2SIqaOU0AiOT5fwKAfAQ+yAoFQ+RCHEUxgyZMSyNk05vWWDiQMD2L8UQsPjKcpRwl+4EjpSm9B0pZl+lMUD53zdC3Lsn5uD85G01HxfZge2prWxUNrlmNKT6559ewrfKhkLJM+zJV27jb58NOyh0X8EutgEKrZ/eC7YZef/UPvQyrgzYX+4t1f3mvP27o9o7vv8Xvt+EO8tJer+0VyLW/gQN8OX5FYN1ffSo//4yPK0nZdi54Pk+/k8xzfp/SW9YzJIfEo77Nf5QnOPC9HREIJKZzotNSrtuTdS7Nc2CWnKMqCKQjGohAKASYwKnvEbDe120bRVGejnVjrMvTHCJryiw6hgjp8cmeFgLNwqrtqUPADq5u/pVZc2cMHkl5QgI7HGQhxxjRWsjSVfiD8wjQGIwdWNJfWx7uW/O7DjcAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='t4gmicro' title='t4gmicro' src='/static/0353a9d59b18d3cb3324b50081234538/ca1dc/t4gmicro.png' srcset='/static/0353a9d59b18d3cb3324b50081234538/e7570/t4gmicro.png 170w,\n/static/0353a9d59b18d3cb3324b50081234538/f46e7/t4gmicro.png 340w,\n/static/0353a9d59b18d3cb3324b50081234538/ca1dc/t4gmicro.png 680w,\n/static/0353a9d59b18d3cb3324b50081234538/9a8ca/t4gmicro.png 868w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>EC2 T4g 인스턴스는 <code class=\"language-text\">Arm</code> 기반 AWS Gravition2 프로세서로 구동되며 T3 인스턴스에 비해 최대 40% 더 나은 가격 성능을 제공한다. 다양한 상품이 존재하지만 우리에게 허락된 사양은 <code class=\"language-text\">2개의 vCPU</code>와 <code class=\"language-text\">1GB</code> 메모리를 가진 <code class=\"language-text\">t4g.micro</code> 뿐이었다.</p>\n<h2>Tomcat 스레드 풀 세팅</h2>\n<p><a href=\"https://dallog.github.io/preparing-for-performance-test/\">톰캣 튜닝을 위한 달록의 서버 성능 테스트 준비 과정</a></p>\n<p>이전 성능 테스트를 진행할 때 사용한 세팅을 그대로 활용한다. </p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">tomcat</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">accept-count</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>\n    <span class=\"token key atrule\">max-connections</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8192</span>\n    <span class=\"token key atrule\">threads</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">max</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>\n\n<span class=\"token punctuation\">...</span></code></pre></div>\n<h2>공식에 대입하기</h2>\n<blockquote>\n<p>5 = (2 * 2) + 1</p>\n</blockquote>\n<p>CPU 코어의 개수는 <code class=\"language-text\">2개(core_count)</code>이며 <code class=\"language-text\">1개(effective_spindle_count)</code>의 디스크를 활용하고 있다. 위 공식은 절대적인 것은 아니지만 기준으로 잡고 테스트를 진행해보았다.</p>\n<p>먼저 성능 테스트는 <code class=\"language-text\">JMeter</code>를 활용하여 진행하였다.</p>\n<p><code class=\"language-text\">JMeter</code> 는 아파치 재단에서 개발한 성능 테스트를 위한 도구이다. 순수 Java로 개발된 애플리케이션이다. 웹 애플리케이션 서버 성능 테스트를 위해 개발되었지만, 현재는 FTP, 데이터베이스, TCP 등 여러 프로토콜의 성능을 테스트할 수 있도록 발전하였다.</p>\n<p>먼저 우리 서비스에서 <code class=\"language-text\">주로 조회되는 API</code>를 기준으로 성능 테스트를 진행하였다. 달록에서 가장 많은 요청은 <code class=\"language-text\">한달 단위로 자신이 체크한 일정 정보를 조회하는 API</code>이다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/aa4ac7fe948910e24f620cb76d1fbc88/e1b3e/dallog-main-api.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 58.235294117647065%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAC40lEQVQoz12T3U8TWRiHZ73TGIkRxf+Ju+2/oIlS9mrXC0280YW2UxMjZm1BLLpugLi7VGRaKqBVo8bsKibCFrUWaOnH1HZm+jnf5/3tmeIX/pInc+adkydzznuOMDg4eMDn8707cfIk/H6/xXGGh4e/4Pd7/OQMDfk5wz38Q7t1XjNPnTqNH32+5wAED+HgoYPHY7GpJnZDuq6DuS6IMe/1G76PV3O8SYjFJvOCIPwgeDncf/TYeDSi2LYFy7JYqVylQqFMO8WPtFPIUj2foGouThv/TNL7Vzdp498btLX2O6k78x7MUlcwce1CTvic/iPHBqLjEdUwDTDmMteswjXKcC0ZVicPXdno0ZDX0axmOOvoyjk4chmWXGJoaYhFI5tf/vBQf//A9fGoapsWHMdknfpTNMoStPwCGpt3oLwW0fpwCy05Da2YQo3XLfkdnM0qzM0iQ1lB7LfoVyHPwO3bf6jeXji2zaz327C3K71d0k0Hue23qMtZcDtcNQumfICh/get9hjax0fMNV7iejS4Vzg7O7srdBzmtFtwu+2e0LINbNVqUNoamN2Aa7dAZKPbKqFWXEW7lmFwSrgxMbZXODMz0xPatsG69WdQ+NJeZiSsbcyjWZDQqSyhVXmA5vZfaLy5BDU7jXb1CZqlFeZqz3hTRvcKp6ene0LLNJihZdGt8wbUM1Aqq6jmX6BTW4POl6nX+bO2ypvEx2oGHWWdwd3B5MSVPcLj8Xhc/XS4GPTXZGlPKFt8TFuFZdLlJaLWU0L7OdlViZytcbIqCTKbL8h8e4fh1RSmLp/3hPs+C/vOnjurrKwsY0GS2GLqARKpNOaSafw5n8Lc3SQW76d7JJNLSEoSEtIin/MQiXsptryQwpmff8l5t2R/X58gpNOPEmNXx8xQKIRwOMxEMUSiGKRL4RAFA6M0MvIrjQZG6OLFCxQIBkgMh/l3kUKhIB+LLCCGcC0SaaZSy/G/5+5e+R8UzMBU1uGOFAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='dallog main api' title='dallog main api' src='/static/aa4ac7fe948910e24f620cb76d1fbc88/ca1dc/dallog-main-api.png' srcset='/static/aa4ac7fe948910e24f620cb76d1fbc88/e7570/dallog-main-api.png 170w,\n/static/aa4ac7fe948910e24f620cb76d1fbc88/f46e7/dallog-main-api.png 340w,\n/static/aa4ac7fe948910e24f620cb76d1fbc88/ca1dc/dallog-main-api.png 680w,\n/static/aa4ac7fe948910e24f620cb76d1fbc88/02d09/dallog-main-api.png 1020w,\n/static/aa4ac7fe948910e24f620cb76d1fbc88/9d567/dallog-main-api.png 1360w,\n/static/aa4ac7fe948910e24f620cb76d1fbc88/e1b3e/dallog-main-api.png 2463w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>실제 API는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET /api/members/me/schedules?startDateTime=2022-09-15T00:00&amp;endDateTime=2022-11-15T00:00    </code></pre></div>\n<p><code class=\"language-text\">startDateTime</code>와 <code class=\"language-text\">endDateTime</code>을 활용하여 특정 날짜 사이에 존재하는 일정 정보를 조회하는 로직이다. </p>\n<blockquote>\n<p>간단한 확인을 위해 외부 요청 로직은 배제하고 진행한다.</p>\n</blockquote>\n<p>유의미한 결과를 획득하기 위해 미리 데이터베이스에 <code class=\"language-text\">100만건</code>의 일정 정보를 세팅해두었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">mysql> SELECT COUNT(*) FROM schedules;\n+----------+\n| COUNT(*) |\n+----------+\n|  1000000 |\n+----------+</code></pre></div>\n<p>해당 로직에서는 아래와 같은 형식의 쿼리가 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> \n<span class=\"token keyword\">FROM</span> schedules s\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> categories c <span class=\"token keyword\">ON</span> s<span class=\"token punctuation\">.</span>categories_id <span class=\"token operator\">=</span> c<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">WHERE</span> c<span class=\"token punctuation\">.</span>id <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'check한 카테고리 id 목록'</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">AND</span> s<span class=\"token punctuation\">.</span>start_date_time <span class=\"token operator\">&lt;=</span> <span class=\"token string\">'2022-11-15 00:00'</span>\n<span class=\"token operator\">AND</span> s<span class=\"token punctuation\">.</span>end_date_time <span class=\"token operator\">>=</span> <span class=\"token string\">'2022-09-15 00:00'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>원할한 조회를 위해서 인덱스 까지 미리 세팅해두었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> schedules <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">INDEX</span> idx_categories_id_start_date_time_end_date_time <span class=\"token punctuation\">(</span>categories_id<span class=\"token punctuation\">,</span> start_date_time<span class=\"token punctuation\">,</span> end_date_time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    </code></pre></div>\n<h2>JMeter 세팅</h2>\n<p>먼저 가상의 사용자 <code class=\"language-text\">100명</code>이 위 API를 요청하는 상황을 가정한다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 492px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/0d786a8ec2c999d9aa04d51f1d6891ed/f5a47/jmeter-setting.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 55.294117647058826%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABkUlEQVQoz21S2XKDMAzkq9IkJBDAYO7LXDn62Jn2/z9A1Yo6JTN5WKwD5F0tThAqMsNEPcOMM/VmXDGMNHCe5iWd/YD8ICTv8gr/DRy8rLOCmranqmkp0RmfHVV1K7nOcjp5Fxm6ha3h3MLB43jyaLc/Mlz6OKzYH0/P+OCe5R0AsXv2X4b6QfTPEMULy67bjvKyFnaQibhm1kXVSA+1rKioZOYq1pQWJS33B1XcU2lGCSsBZCBu6HhvnRlonBaRn/Ia8PHA+XK9U9sZ2TVyDMbH8+1OJa8l0qkMBRxLXSSzvN0byeht44PrsapIiARRTGGcUKhWONgHirfHp9wOyWAKTMuV2n49x3kR98EW8lvuN8ZQzEw1y9dFIRDJ+AUgI2fAcewPuUhL87XHNfQQR7xDnReyR8VyY5Zq8ZQM96ybW1etoza3NRgpMjdyRbI1BZIgzYyTxDAn5n8S7NNydXdhE67sLGJI/vr+YdkDqYxdZsaAY/8le0MQqb8zlmHoeXwhYrBCHQRUomWXuDTi2OIX6o6Q6xKrfswAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='jmeter setting' title='jmeter setting' src='/static/0d786a8ec2c999d9aa04d51f1d6891ed/f5a47/jmeter-setting.png' srcset='/static/0d786a8ec2c999d9aa04d51f1d6891ed/e7570/jmeter-setting.png 170w,\n/static/0d786a8ec2c999d9aa04d51f1d6891ed/f46e7/jmeter-setting.png 340w,\n/static/0d786a8ec2c999d9aa04d51f1d6891ed/f5a47/jmeter-setting.png 492w' sizes='(max-width: 492px) 100vw, 492px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>보다 더 유의미한 처리량을 확인하기 위해 <code class=\"language-text\">반복 횟수(loop count)</code>도 적절히 설정한다. </p>\n<blockquote>\n<p>각 설정은 테스트 하고자 하는 상황에 맞게 적절히 설정한다.</p>\n</blockquote>\n<h2>성능 측정하기</h2>\n<p>먼저 처리량에 가장 큰 영향을 주는 커넥션 풀의 개수부터 조정하며 테스트를 진행했다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/37949e49e8e2969dcd5a7f68157acce6/683d4/test.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 89.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAADMklEQVQ4y2VU2XIbRRTVH0MVxRO88AAUCQ/5mFQKsB0qqbiixYtkxYqxZWv3aLSPpNH0dM/ocE5LQxHoqitd3eX0uUurFJkcb/oOJ8MMp6OD/EH9ddfidc/h90Hm5Yz2M9lpe9OzOKV+Msq9vA8YQ4wwzlDqRxbfVQ1e3jj8eLnDi+sEv1L/+nyHbz4a6hYvGyle1A1eNS2+LRt89WGHX+oWP9ci/FBe46crg+9rBrczi5JzFtYY7Pd7jEYjPAeB102yg0sNnHPY7XZYLJdwWQZLmySm7cP5OS4uLrBaRXCWODYVoPM/dBaLOVZM1EnNAYzo1BNsNxta9/AEGG+SBK3bT+h2OgRcYZ/n3l7SR8LknOEjsgvC0OsxEwx9joGbeIfZYomM4EmaepG/XKmiXK1iHE58XJqKIZPSOAbrwHjQx2Q4xJ6MEt6abtbIWdpmNsNqEno9Xa9h1hGSaIVGtYLbqytEEwJut4QQID/MbIp8GiJsfcL08y3y8TN23SeYQRfueYDtUxur+ztkz0NvM/0u/Y9onPyG1ru3mN+1YIc9GNpKGkjC/uRkNXp6RPDYRk5mMS8xywUcmazHAeb9HtxqiWQ6QUK2W9oqZ6eo/fkWIfOs7K3moYeGdAUYdLsIu50DIAPMfApH0E3wjAVZSRdYEgaIaau/f4fPlY+Yd56Q0p5G0WHKVtPkmc7nmBdTts43ei/dZX4I0mWzmSRD6+4v3D08YMW+yifbYcoKZqD2MOCkc+oxB2WOqxNxQDMOJqOuWEnMqqqccE1THo/96h2mzCApnuF0ijlZ6gjMHvdT+sbvIXysRKA3Nze4v79HxFIzLb21XwJOOH4x0VGCfFsyCbmbYi9Q2XSBpNFooNlseiL5F4utkrm0g8HAJ0pXyUpWCy4vL/0T6/f7nomeonIqlQrq9bp/KfbfJRelKUGg/y1ZCUUrrD0+PfpVcrvd9lX8j6FOh+9SolMMRWx7vR4eOM2iFbILpFareVC1qWhdqbhNidfX1z6gACwuarVavmT/L3Tsn/pZLpdxxacn9v+ULKpC1/eSO6jyCvqFfc09WywWvn/+3+nYJgEpRxfLJ/kb0DBOJHdsryEAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='test' title='test' src='/static/37949e49e8e2969dcd5a7f68157acce6/ca1dc/test.png' srcset='/static/37949e49e8e2969dcd5a7f68157acce6/e7570/test.png 170w,\n/static/37949e49e8e2969dcd5a7f68157acce6/f46e7/test.png 340w,\n/static/37949e49e8e2969dcd5a7f68157acce6/ca1dc/test.png 680w,\n/static/37949e49e8e2969dcd5a7f68157acce6/02d09/test.png 1020w,\n/static/37949e49e8e2969dcd5a7f68157acce6/683d4/test.png 1174w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<blockquote>\n<p>커넥션 풀의 개수가 스레드 풀의 개수보다 적으면 무의미하기 때문에 적절히 증가시켜 비교해보았다.</p>\n</blockquote>\n<p>가장 높은 처리량은 공식으로 부터 도출된 <code class=\"language-text\">5개</code>이다. 또한 커넥션 풀의 개수를 과하게 설정할 경우 재밌는 결과를 확인할 수 있었다. 오히려 <code class=\"language-text\">처리량이 줄어드는 것</code>을 볼 수 있다. 서버가 가진 <code class=\"language-text\">한정된 자원</code>인 CPU 코어가 과도한 <code class=\"language-text\">컨텍스트 스위칭</code>으로 인해 처리 시간이 늘어난 것에 대한 결과로 추측된다.</p>\n<p>다음으로 고려해볼만한 값은 <code class=\"language-text\">connectionTimeout</code>이다. <code class=\"language-text\">connectionTimeout</code>은 커넥션을 구하기 위해 대기하는 시간이다. 만약 풀에서 모든 커넥션을 사용중인 경우 대기가 발생하게 된다. 기본값은 <code class=\"language-text\">30초</code>이다. </p>\n<p><code class=\"language-text\">이론편</code>에서 언급한 것 처럼 풀에서 모든 커넥션이 사용중인 경우 최악의 경우 사용자는 <code class=\"language-text\">30초 이후</code> 에러 페이지를 마주할 수 있다. 내가 사용자라면 절대 가만히 30초를 기다리지 않을 것이다.</p>\n<p>사용자에게 에러 페이지는 지양해야 하지만 적어도 빠른 시간안에 피드백을 주는 것이 바람직하다. 보통은 서버 상황에 따라 <code class=\"language-text\">0.5 ~ 3</code>초 사이를 설정한다.</p>\n<p>자 이제 커넥션의 최적의 개수는 찾았으니, 타임 아웃 시간을 지정해보자.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/d4f39381d4ddf2586eb82a32a6611729/02a0d/connectionTimeout.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 42.35294117647059%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABk0lEQVQoz2WPSW/TUBSF86/Lkk2RWJRNB4klGzaVKrGpxL5SldjBsR078ZQBHESh1EMc/Aa7p/c+lFTQxZHfOz73e+cOPkQSJ57GeajxfqbxxpF4bUuchZ3RxazDMXmvRhJvXY1T8o4nGkdDuk+k+X9O3jtf42MsMUh+C/gPPYZfS3i/JElh8lPg2lng6jakb4YvP1p49xqjvMbljYfJnaAMZe8VPrtLfBrOYG0aLEqFwaMSAHq0dQF0ko6kR418kSAOPGxW2V+fPNVUmDoWoNqDt04jzDwHvWjII2ArBHTX46Eo0QoJISWU1viW5xhZNvLNd0iljcqqhj0e40/bmpyQCmm2QBCGqOqaMgQUBOz7HkVRQFKI1XUdVqsVLMvCer2GoqCmR6qqgm3baAnIOfazLEMQBNhut+Z+AJZleQjx8Hw+N8A4jo3PXk0txtRwD2QvSRJMp9OXwH1DNnmAQzwc0jq73c60/r8hA9M0he/7aJrmGchhbshnDjHEdV2zShRFRgzgho7j/LPycrk02+wbPgH5DlBrFB7XRwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='connectionTimeout' title='connectionTimeout' src='/static/d4f39381d4ddf2586eb82a32a6611729/ca1dc/connectionTimeout.png' srcset='/static/d4f39381d4ddf2586eb82a32a6611729/e7570/connectionTimeout.png 170w,\n/static/d4f39381d4ddf2586eb82a32a6611729/f46e7/connectionTimeout.png 340w,\n/static/d4f39381d4ddf2586eb82a32a6611729/ca1dc/connectionTimeout.png 680w,\n/static/d4f39381d4ddf2586eb82a32a6611729/02d09/connectionTimeout.png 1020w,\n/static/d4f39381d4ddf2586eb82a32a6611729/9d567/connectionTimeout.png 1360w,\n/static/d4f39381d4ddf2586eb82a32a6611729/02a0d/connectionTimeout.png 1478w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>큰 차이가 없는 것을 확인할 수 있다. 애초에 오랜시간 커넥션을 잡을 만한 로직이 아니기 때문에 이같은 결과가 나온 것으로 추측한다. 그럼에도 만일에 일을 대비하여 대략 3초로 설정해두었다.</p>\n<h2>정리</h2>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">tomcat</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">accept-count</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>\n    <span class=\"token key atrule\">max-connections</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8192</span>\n    <span class=\"token key atrule\">threads</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">max</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">...</span>\n<span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">...</span>\n  <span class=\"token key atrule\">datasource</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">...</span>\n    <span class=\"token key atrule\">hikari</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">maximumPoolSize</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5</span>\n      <span class=\"token key atrule\">connectionTimeout</span><span class=\"token punctuation\">:</span> <span class=\"token number\">3000</span></code></pre></div>\n<p>최종적으로 달록에서 적용하게 된 설정은 위와 같다. 비교적 적은 사양을 가진 서버이기 때문에 수치가 전반적으로 낮은 것을 확인할 수 있다. 이 밖에도 다양한 설정 정보가 있지만 현재 구조에서는 크게 연관된 부분이 없다고 판단하여 기본값으로 설정하였다. </p>\n<p>스레드 풀의 개수보다 커넥션 풀의 개수는 낮게 설정하는 것이 좋다. 애플리케이션에서 커넥션을 사용하는 주체는 스레드이기 때문에 스레드의 개수보다 커넥션의 개수를 많이 설정해봐야 무의미하게 생성될 것이다. 또한 아무리 공식이 존재하여도 실제 테스트를 통해 각 애플리케이션 상황에 최적화된 값을 찾는 것이 중요하다 생각한다.</p>\n<p>항상 이론적으로만 접했던 개념(e.g. 디스크 I/O, 컨텍스트 스위칭 등)들을 실습을 통해 체감하게 되어 온전한 기억으로 남길 수 있게 되었다. 다음 시간에는 커넥션 풀을 설정하며 마주한 문제에 대해 작성해보려 한다.</p>\n<h2>References.</h2>\n<p><a href=\"https://github.com/brettwooldridge/HikariCP\">HikariCP</a><br>\n<a href=\"https://techblog.woowahan.com/2663/\">HikariCP Dead lock에서 벗어나기 (이론편)</a><br>\n<a href=\"https://techblog.woowahan.com/2664/\">HikariCP Dead lock에서 벗어나기 (실전편)</a><br>\n<a href=\"https://www.youtube.com/watch?v=6Q7iRTb4tQE\">프로그래밍 초식: 커넥션풀 설정</a><br>\n<a href=\"https://hyuntaeknote.tistory.com/m/12\">내가 만든 서비스는 얼마나 많은 사용자가 이용할 수 있을까? - 3편(DB Connection Pool)</a></p>","frontmatter":{"title":"HikariCP와 적절한 풀 사이즈 고민하기 (2) - 실전편","date":"October 18, 2022","update":"October 18, 2022","tags":["매트","BE","HikariCP","데이터베이스 커넥션"],"series":"HikariCP와 적절한 풀 사이즈 고민하기"},"fields":{"slug":"/hikari-cp-2-actual/","readingTime":{"minutes":8.905}}},"seriesList":{"edges":[{"node":{"id":"ce40a615-2dcf-54cc-a699-da29ba8fb999","fields":{"slug":"/hikari-cp-1-theory/"},"frontmatter":{"title":"HikariCP와 적절한 풀 사이즈 고민하기 (1) - 이론편"}}},{"node":{"id":"2ab919f2-9c8e-543b-b370-8f7e77ae67ad","fields":{"slug":"/hikari-cp-2-actual/"},"frontmatter":{"title":"HikariCP와 적절한 풀 사이즈 고민하기 (2) - 실전편"}}},{"node":{"id":"9452f85a-2e76-5b0e-85b2-22277976f133","fields":{"slug":"/hikari-cp-3-spadework/"},"frontmatter":{"title":"HikariCP와 적절한 풀 사이즈 고민하기 (3) - 삽질편"}}}]},"previous":{"fields":{"slug":"/db-time-3-time-zone/"},"frontmatter":{"title":"달력 서비스의 DB 시간 다루기 3 - Time Zone, 어디서 어떻게 설정해야 할까?"}},"next":{"fields":{"slug":"/jenkins-distributed-build-architecture/"},"frontmatter":{"title":"젠킨스 분산 빌드 아키텍처 구축"}}},"pageContext":{"id":"2ab919f2-9c8e-543b-b370-8f7e77ae67ad","series":"HikariCP와 적절한 풀 사이즈 고민하기","previousPostId":"baa7d054-550b-572e-a8c8-337f87b42bf6","nextPostId":"cf403487-1c48-5ca7-b5c2-ef0d8fefe3c4"}},"staticQueryHashes":[]}