{"componentChunkName":"component---src-templates-post-jsx","path":"/json-property-json-naming/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"7a3bde6d-746b-56fd-8d91-0d8059ebf1f8","excerpt":"이 글은 우테코 달록팀 크루 '매트'가 작성했습니다. @JsonProperty, @JsonNaming 구글 측에서 OpenID connect Sever flow를 살펴보면 사용자 인증을 진행할 경우 아래와 같은 흐름으로 진행되는 것을 확인할 수 있다. Create an anti-forgery state token: 위조 방지 상태 토큰 만들기 Send a…","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 '<a href=\"https://github.com/hyeonic\">매트</a>'가 작성했습니다.</p>\n</blockquote>\n<h2>@JsonProperty, @JsonNaming</h2>\n<p>구글 측에서 <a href=\"https://developers.google.com/identity/protocols/oauth2/openid-connect#server-flow\">OpenID connect Sever flow</a>를 살펴보면 사용자 인증을 진행할 경우 아래와 같은 흐름으로 진행되는 것을 확인할 수 있다.</p>\n<ol>\n<li>Create an anti-forgery state token: 위조 방지 상태 토큰 만들기</li>\n<li>Send an authentication request to Google: Google에서 인증 요청 보내기</li>\n<li>Confirm anti-forgery state token: 위조 방지 상태 토큰 확인</li>\n<li><code class=\"language-text\">Exchange code for access token and ID token: code를 액세스 토큰 및 ID 토큰으로 교환</code></li>\n<li>Obtain user information from the ID token: ID 토큰에서 사용자 정보 가져오기</li>\n<li>Authenticate the user: 사용자 인증</li>\n</ol>\n<p><code class=\"language-text\">4</code>를 살펴보면 서버가 액세스 토큰 및 ID 토큰을 교환받기 위해 일회성 승인 코드인 <code class=\"language-text\">code</code>를 활용하여 아래와 같이 요청을 보내야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">POST /token HTTP/1.1\nHost: oauth2.googleapis.com\nContent-Type: application/x-www-form-urlencoded\n\ncode=4/P7q7W91a-oMsCeLvIaQm6bTrgtp7&amp;\nclient_id=your-client-id&amp;\nclient_secret=your-client-secret&amp;\nredirect_uri=https%3A//oauth2.example.com/code&amp;\ngrant_type=authorization_code</code></pre></div>\n<p>위 요청을 보낸 뒤 성공적으로 처리되면 아래와 같은 응답을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"access_token\"</span><span class=\"token operator\">:</span> ...<span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"expires_in\"</span><span class=\"token operator\">:</span> ...<span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"id_token\"</span><span class=\"token operator\">:</span> ...<span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"token_type\"</span><span class=\"token operator\">:</span> ...<span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"refresh_token\"</span><span class=\"token operator\">:</span> ...\n<span class=\"token punctuation\">}</span> </code></pre></div>\n<p>주목해야 할 것은 google 측에서 token 정보를 <code class=\"language-text\">snake_case</code> 형식으로 제공하고 있다는 것을 기억하자.</p>\n<h2>snake_case to CamelCase</h2>\n<p>google 측에서 제공된 token 정보의 경우 <code class=\"language-text\">snake_case</code>로 되어 있기 때문에 해당 데이터를 Java 객체로 변환하기 위해서는 아래와 같이 필드명을 작성해야 정상적으로 변환이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GoogleTokenResponse</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> access_token<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> refresh_token<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id_token<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> expires_in<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> token_type<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> scope<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">GoogleTokenResponse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getAccess_token</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> access_token<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그러나 Java에서는 기본적으로 <code class=\"language-text\">CamelCase</code>를 사용하고 있다. 코드 내부에 <code class=\"language-text\">CamelCase</code>와 <code class=\"language-text\">snake_case</code>가 함께 뒹굴고 있으면 일관성이 떨어진 코드를 마주하게 될 것이다. 우리는 <code class=\"language-text\">snake_case</code>로 제공 받은 데이터를 <code class=\"language-text\">역직렬화</code>할 때 <code class=\"language-text\">CamelCase</code>로 변환하는 방법에 대해 고민하게 되었다.</p>\n<blockquote>\n<p>직렬화: Java 객체 → 전송 가능한 데이터 <br>\n역직렬화: 전송 가능한 데이터 → Java 객체</p>\n</blockquote>\n<h3>@JsonProperty</h3>\n<p><code class=\"language-text\">@JsonProperty</code>는 필드나 메서드 위에 선언되어 <code class=\"language-text\">직렬화/역직렬화</code>될 때 매핑 하기 위한 <code class=\"language-text\">property 명을 지정</code>한다. 아래와 같이 적용이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GoogleTokenResponse</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@JsonProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"access_token\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> accessToken<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@JsonProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"refresh_token\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> refreshToken<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@JsonProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"id_token\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> idToken<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@JsonProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"expires_in\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> expiresIn<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@JsonProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"token_type\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> tokenType<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> scope<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">GoogleTokenResponse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>다만 변환해야 하는 필드 값이 늘어날 경우 필드마다 해당 애노테이션을 명시해야 한다. 또한 문자열로 작성하기 때문에 오타로 인해 정상적으로 변환하지 못할 가능성 또한 존재한다.</p>\n<h3>@JsonNaming</h3>\n<p>google 측에서 제공되는 token 정보의 경우 <code class=\"language-text\">snake_case</code>의 일정한 전략을 활용하여 응답하고 있다. 이때 변환하고자 하는 클래스 위에 <code class=\"language-text\">@JsonNaming</code>을 통해 일괄적으로 적용이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@JsonNaming</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PropertyNamingStrategies<span class=\"token punctuation\">.</span>SnakeCaseStrategy</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GoogleTokenResponse</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> accessToken<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> refreshToken<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> idToken<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> expiresIn<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> tokenType<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> scope<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">GoogleTokenResponse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>TODO</h2>\n<p>간단히 역직렬화 시점에 <code class=\"language-text\">snake_case</code>로 명시된 JSON 데이터를 <code class=\"language-text\">CamelCase</code> 필드로 변환하는 방식에 대해 알 수 있었다. 하지만 이 밖에도 직렬화/역직렬화를 진행할 때 Jackson에서 제공되는 애노테이션의 종류는 다양하다. 추후 어떠한 시점에 해당 애노테이션이 작용되며 직렬화와 역직렬화 시점에 필수적으로 필요한 것들에 대해 알아보려 한다. </p>\n<h2>References.</h2>\n<p><a href=\"https://developers.google.com/identity/protocols/oauth2/openid-connect\">OpenID Connect</a><br>\n<a href=\"https://www.baeldung.com/jackson-annotations\">Jackson Annotation Examples</a></p>","frontmatter":{"title":"@JsonProperty, @JsonNaming","date":"September 10, 2022","update":"September 10, 2022","tags":["매트","역직렬화","BE","JsonProperty","JsonNaming"],"series":null},"fields":{"slug":"/json-property-json-naming/","readingTime":{"minutes":4.665}}},"seriesList":{"edges":[{"node":{"id":"a621dc7b-8590-5ec6-9b52-3d9e5182486d","fields":{"slug":"/appearance-background-of-jpa/"},"frontmatter":{"title":"JPA 등장배경"}}},{"node":{"id":"9d2a87b6-2b9c-5b87-b790-3426d17c2d8e","fields":{"slug":"/intellij-final-keyword/"},"frontmatter":{"title":"IntelliJ에서 메소드 추출한 메소드의 파라미터에 final 키워드 자동 추가하기"}}},{"node":{"id":"251e9767-1c92-5cf5-9cef-2c4a42c10df2","fields":{"slug":"/git-branch-strategy/"},"frontmatter":{"title":"달록팀의 git 브랜치 전략을 소개합니다."}}},{"node":{"id":"5090cce3-0c1f-5376-badc-1d25e44c1bd9","fields":{"slug":"/infinite-scroll/"},"frontmatter":{"title":"React에서 무한 스크롤 구현하기"}}},{"node":{"id":"bcb53ba5-0286-5d10-96c2-fdcb88e2cc60","fields":{"slug":"/package-structure/"},"frontmatter":{"title":"달록에 적절한 패키지 구조 고민하기"}}},{"node":{"id":"a7fc89de-f37c-596e-a81d-3d4fe5a795b8","fields":{"slug":"/data-jpa-slice-page/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"e1ba92ee-0cf0-50c8-80bd-5da5075df8d1","fields":{"slug":"/data-jpa-auditing/"},"frontmatter":{"title":"Spring Data JPA의 Auditing"}}},{"node":{"id":"3e036508-c916-504e-9e8d-89f69332471e","fields":{"slug":"/separated-interface/"},"frontmatter":{"title":"외부와 의존성 분리하기"}}},{"node":{"id":"cade544a-16ef-58a3-b97c-824986a8395f","fields":{"slug":"/apply-rest-docs/"},"frontmatter":{"title":"MockMvc를 사용한 Spring RestDocs"}}},{"node":{"id":"87649d54-d59e-58a6-afd5-8491eb4113a8","fields":{"slug":"/properties-to-object/"},"frontmatter":{"title":"properties 객체로 다루기"}}},{"node":{"id":"eb380f6d-5a00-5a9e-a916-003fb292cc8a","fields":{"slug":"/test-fixture-constant/"},"frontmatter":{"title":"테스트에서 Entity 객체를 상수로 두면 안 되는 이유"}}},{"node":{"id":"9734e30a-b430-5922-919d-f53808a56eb9","fields":{"slug":"/what_is_nginx/"},"frontmatter":{"title":"NGINX 란?"}}},{"node":{"id":"9ebc6e21-2a76-5d42-be33-c2dae8c849b2","fields":{"slug":"/ssl_protocol/"},"frontmatter":{"title":"SSL을 통한 HTTPS통신 과정"}}},{"node":{"id":"fa5ad595-1f81-5a20-a884-2da69adee3c5","fields":{"slug":"/integration-test-slice-test/"},"frontmatter":{"title":"통합 테스트와 슬라이스 테스트"}}},{"node":{"id":"d8c66823-bb05-5e83-a6a1-2fd9af450b6f","fields":{"slug":"/query-invalidation/"},"frontmatter":{"title":"React-Query에서의 데이터 최신화 (Query Invalidation)"}}},{"node":{"id":"f5187517-342f-52a1-9092-d12c1a80d132","fields":{"slug":"/seperate-components/"},"frontmatter":{"title":"컴포넌트 분리 기준"}}},{"node":{"id":"d6249c8b-bea6-5c91-8477-d3dd15ad9b39","fields":{"slug":"/test-isolation/"},"frontmatter":{"title":"테스트 격리"}}},{"node":{"id":"98e390ef-fb19-5d01-a3ef-d14bc0e65176","fields":{"slug":"/dallog-jacoco/"},"frontmatter":{"title":"달록의 Jacoco 적용기 (feat. Gradle)"}}},{"node":{"id":"33d19946-de0c-5b41-bfa0-d7c3fd80f10b","fields":{"slug":"/google-refresh-token/"},"frontmatter":{"title":"Google은 Refresh Token을 쉽게 내주지 않는다."}}},{"node":{"id":"8168857d-a82c-5608-bd40-cea4b917d17d","fields":{"slug":"/submodule/"},"frontmatter":{"title":"달록 서브모듈 도입기"}}},{"node":{"id":"836fc724-7e2f-5c7a-a42b-c0cc9163167a","fields":{"slug":"/dallog-flyway/"},"frontmatter":{"title":"달록의 데이터베이스 마이그레이션을 위한 Flyway 적용기"}}},{"node":{"id":"7a3bde6d-746b-56fd-8d91-0d8059ebf1f8","fields":{"slug":"/json-property-json-naming/"},"frontmatter":{"title":"@JsonProperty, @JsonNaming"}}},{"node":{"id":"50673f5c-f835-5982-b70c-b77e5a352a2c","fields":{"slug":"/servlet-life-cycle/"},"frontmatter":{"title":"서블릿 생명주기와 직접만든 톰캣을 통한 의문점"}}},{"node":{"id":"61e7f4d1-7b3a-5968-bfe8-c3f6efb88748","fields":{"slug":"/preparing-for-performance-test/"},"frontmatter":{"title":"톰캣 튜닝을 위한 달록의 서버 성능 테스트 준비 과정"}}},{"node":{"id":"9272061d-68c6-5f82-a961-0e2efe0fd6be","fields":{"slug":"/cyclic-dependency/"},"frontmatter":{"title":"cyclic dependency"}}},{"node":{"id":"6e779308-f266-58af-bfcc-e9fee6d39a98","fields":{"slug":"/multi-datasource-issue-with-osiv/"},"frontmatter":{"title":"대체 왜 DataSource 라우팅이 안되는거야!? (feat. OSIV)"}}},{"node":{"id":"0e63245e-c52c-5977-9f60-f94ee0fd00fc","fields":{"slug":"/hikari-cp-theory/"},"frontmatter":{"title":"HikariCP와 적절한 풀 사이즈 고민하기 (이론편)"}}},{"node":{"id":"c7bea043-345c-5f78-ae53-796a83812961","fields":{"slug":"/react-query-useMutation-trouble-shooting/"},"frontmatter":{"title":"react-query useMutation onSuccess 안 되는줄 알았던 트러블 슈팅"}}},{"node":{"id":"cf403487-1c48-5ca7-b5c2-ef0d8fefe3c4","fields":{"slug":"/jenkins-distributed-build-architecture/"},"frontmatter":{"title":"젠킨스 분산 빌드 아키텍처 구축"}}}]},"previous":{"fields":{"slug":"/dallog-flyway/"},"frontmatter":{"title":"달록의 데이터베이스 마이그레이션을 위한 Flyway 적용기"}},"next":{"fields":{"slug":"/servlet-life-cycle/"},"frontmatter":{"title":"서블릿 생명주기와 직접만든 톰캣을 통한 의문점"}}},"pageContext":{"id":"7a3bde6d-746b-56fd-8d91-0d8059ebf1f8","series":null,"previousPostId":"836fc724-7e2f-5c7a-a42b-c0cc9163167a","nextPostId":"50673f5c-f835-5982-b70c-b77e5a352a2c"}},"staticQueryHashes":[]}