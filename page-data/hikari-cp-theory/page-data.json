{"componentChunkName":"component---src-templates-post-jsx","path":"/hikari-cp-theory/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"0e63245e-c52c-5977-9f60-f94ee0fd00fc","excerpt":"이 글은 우테코 달록팀 크루 매트가 작성했습니다. HikariCP와 적절한 풀 사이즈 고민하기 (이론편) 는 을 제공하는 이다.  데이터베이스 커넥션 풀 데이터베이스 커넥션이 필요할 때마다 매번 생성해서 연결하는 것은 매우 비효율적이다. 데이터베이스 커넥션을 생성해둔 뒤 사용하는 방식을 데이터베이스 커넥션 풀이라 한다. 요청 마다 커넥션 객체를 생성하여 …","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 <a href=\"https://github.com/hyeonic\">매트</a>가 작성했습니다.</p>\n</blockquote>\n<h2>HikariCP와 적절한 풀 사이즈 고민하기 (이론편)</h2>\n<p><code class=\"language-text\">HikariCP</code>는 <code class=\"language-text\">connection pooling</code>을 제공하는 <code class=\"language-text\">JDBC DataSource 구현체</code>이다. </p>\n<h2>데이터베이스 커넥션 풀</h2>\n<p>데이터베이스 커넥션이 필요할 때마다 매번 생성해서 연결하는 것은 매우 비효율적이다. 데이터베이스 커넥션을 생성해둔 뒤 사용하는 방식을 데이터베이스 커넥션 풀이라 한다.</p>\n<p>요청 마다 커넥션 객체를 생성하여 쿼리를 전달하기 위해서는 항상 아래와 같은 과정을 겪어야 한다.</p>\n<ul>\n<li>JDBC 드라이버를 로드한다.</li>\n<li>연결 정보를 기반으로 데이터베이스에 연결해야 한다.</li>\n<li>Statement를 생성한다.</li>\n<li>SQL문을 전송한다.</li>\n<li>ResultSet을 통해 결과를 확인한다.</li>\n<li>연결을 해제한다.</li>\n</ul>\n<p>커넥션 객체를 생성하는 비용 자체도 문제가 되지만 매번 SQL 쿼리 자체를 전송하기 위해 <code class=\"language-text\">객체를 생성하고 해제하는 과정</code>이 매우 비효율적으로 느껴진다.</p>\n<p>또한 커넥션 연결도 <code class=\"language-text\">TCP/IP</code>를 통해 이루어진다. 즉 <code class=\"language-text\">3-way-handshaking</code> 과정을 통해 통신을 준비하는데, 이 과정이 쿼리를 요청할 때 마다 반복되면 네트워크 구간에서 병목의 원인이 될 수 있다.</p>\n<blockquote>\n<p>커넥션을 생성하는 과정은 전체 과정 중 대략 50%를 차지한다고 한다.</p>\n</blockquote>\n<p>정리하면 데이터베이스 커넥션 풀은 아래와 같은 이점을 가지고 있다.</p>\n<ul>\n<li>이미 커넥션을 맺은 상태로 커넥션 풀에서 관리되기 때문에 데이터베이스와 <code class=\"language-text\">네트워크 연결 시간을 단축</code> 시켜 준다. 이러한 응답 시간 단축은 처리량 증가로 이어질 수 있다.</li>\n<li>데이터베이스에 대한 커넥션 개수를 일정 수준으로 제한하여 불필요한 리소스를 줄일 수 있다. 또한 과한 커넥션을 맺지 않도록 방지하여 일관된 데이터베이스 성능을 유지할 수 있다.</li>\n</ul>\n<p>데이터베이스 커넥션 풀은 대표적으로 <code class=\"language-text\">commons-dbcp</code>, <code class=\"language-text\">tomcat-jdbc-pool</code>, <code class=\"language-text\">HikariCP</code> 등이 존재한다.</p>\n<h2>HikariCP</h2>\n<p><code class=\"language-text\">HikariCP</code>는 <code class=\"language-text\">connection pooling</code>을 제공하는 <code class=\"language-text\">JDBC DataSource 구현체</code>이다. </p>\n<p>공식 문서에 따르면 몇몇 바이트코드 레벨의 구현이 있으며, 마이크로 최적화, <code class=\"language-text\">ArrayList&lt;Statement></code> 사용 대신 FastList 직접 구현으로 처음부터 끝까지 모든 것을 스캔하는 과정을 생략하는 등 다른 프레임워크보다 빠른 속도를 가지고 있다고 소개하고 있다.</p>\n<p>Spring Boot 2.0 이후 <code class=\"language-text\">HikariCP</code>를 default 커넥션 풀로 활용하고 있다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/a78576c71a0e8ea1ac66b35ee9c96d48/d8a90/hikari-dependency.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 57.64705882352942%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB7klEQVQoz4VTy27VMBTMFyGx6yXv3Lxu4ryc1y2sKj6gLaxAiLZ8BRIfO8w5SYq6YjE6x048nhnbTjMvGKYF/TBisBOabkAQJfDDGF4QvYHM/Q9OkuXorrfoSToSlpjmFU3bIyRxGJ93JErq+qHiXx+99lId1wsQZQXMuqKlumGcMZJQqijud7S9RZLmiJIU8TnTTaTK+IA4czzukBQlmisJqaqjdQUJmq4n2aiEdpq1H8a95z8j45JvUqfliqy4wBHfMW1fRqu2LZUpuEgWizIZK/Gec9sP2kuVf0zTKZmoVkLXDRCXkuUn5reowoP0yFTn9oyl39TOuNTmNT/NUE+HTWoqdJQ9iSWqmEgmsFw4yS2gGruTiE1RdWT5gedw3ALHC9kEMbKmxmX9CDOtMPNV1dasNceCalzQyPywWRfCsjKKmn2al28J08bgc2fwmAa4zyN8vZy13mcRHvIYj+wfTIFRch3slq3mvMVSm3Y7ZZ+EpzBBE4X4k7zH9yLE09nFc+4rfpUhXooA3zIfv713uPNPOCU5Ylo9rtBxfVShEHpsQgb7Jb7BU+bhWbATCn6mLn4kJ7wQt12LmurEsoJXTWwXZaXEzvFkAqkMPrM8ObugZGbVdEUxzCg5llpwrtdTtvoIznwQYvN4qoK/2PnCstInMBUAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='hikari dependency' title='hikari dependency' src='/static/a78576c71a0e8ea1ac66b35ee9c96d48/ca1dc/hikari-dependency.png' srcset='/static/a78576c71a0e8ea1ac66b35ee9c96d48/e7570/hikari-dependency.png 170w,\n/static/a78576c71a0e8ea1ac66b35ee9c96d48/f46e7/hikari-dependency.png 340w,\n/static/a78576c71a0e8ea1ac66b35ee9c96d48/ca1dc/hikari-dependency.png 680w,\n/static/a78576c71a0e8ea1ac66b35ee9c96d48/d8a90/hikari-dependency.png 920w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<h2>HikariCP 설정</h2>\n<h3>maximumPoolSize</h3>\n<p>풀이 제공할 수 있는 최대 커넥션 개수를 의미한다. 최대 커넥션 개수는 <code class=\"language-text\">사용 중인 커넥션 수 + 유후 커넥션 수</code>와 같다. 기본값은 <code class=\"language-text\">10개</code>이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HikariConfig</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">HikariConfigMXBean</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">DEFAULT_POOL_SIZE</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>최대 커넥션 개수는 <code class=\"language-text\">TPS</code>에 가장 많은 영향을 주는 옵션이다. 아래 공식 문서에 소개된 공식과 서버 상황에 따라 적절한 값을 설정해야 한다.</p>\n<h3>connectionTimeout</h3>\n<p>커넥션 풀에서 커넥션을 구하기 위해 <code class=\"language-text\">대기</code>하는 시간이다. 만약 풀에서 모든 커넥션을 사용중인 경우 대기가 발생하게 된다. 기본값은 <code class=\"language-text\">30초</code>이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HikariConfig</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">HikariConfigMXBean</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> longCONNECTION_TIMEOUT <span class=\"token operator\">=</span> <span class=\"token constant\">SECONDS</span><span class=\"token punctuation\">.</span><span class=\"token function\">toMillis</span><span class=\"token punctuation\">(</span><span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>사용자가 응답을 받기 까지 기본값 <code class=\"language-text\">30초</code>를 대기하는 것은 너무 길다. 스레드 풀 기반의 WAS는 순간적으로 트래픽이 증가하게 되면 스레드가 대기할 수 있다. 사용자는 응답 없이 기다리는 것 보다 빠르게 에러 화면 이라도 마주하는 것이 더 낫다. </p>\n<p>보통의 웹 서비스는 <code class=\"language-text\">0.5 ~ 3초</code> 이내로 설정하여 응답 시간을 최소화 한다.</p>\n<h3>maxLifeTime</h3>\n<p>커넥션을 생성한 뒤 설정된 시간이 지나면 커넥션을 닫고 풀에서 제거한다. 제거한 뒤 커넥션을 새롭게 생성한다. 기본값은 <code class=\"language-text\">30초</code>이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HikariConfig</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">HikariConfigMXBean</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> <span class=\"token constant\">MAX_LIFETIME</span> <span class=\"token operator\">=</span> <span class=\"token constant\">MINUTES</span><span class=\"token punctuation\">.</span><span class=\"token function\">toMillis</span><span class=\"token punctuation\">(</span><span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>기본적인 규칙은 네트워크나 데이터베이스의 관련 설정 값보다 작은 값을 사용한다. 관련 설정의 예시로는 네트워크 장비의 최대 TCP 커넥션 유지 시간이 될 수 있다. 최대 TCP 유지 시간이 10분이라고 가정한다. 이 값이 관련 설정보다 크게되면 <code class=\"language-text\">이미 유효하지 않은 커넥션</code>이 풀에 남게 된다. </p>\n<p>풀에서 유효하지 않은 커넥션을 검증하는 과정에서 추가적인 커넥션이 새로 생성된다. 즉 트래픽이 몰리는 시점에 성능 저하를 유발할 수 있다.</p>\n<h3>keepaliveTime</h3>\n<p>커넥션이 살아 있는지 확인하는 주기이다. 유휴 커넥션에 대해 커넥션을 검증하고 유효하지 않은 경우 풀에서 제거한다. 제거 후 커넥션을 새로 생성한다.</p>\n<p>이 또한 네트워크나 데이터베이스의 관련 설정 값보다 작은 값을 사용한다. 관련 설정 예시로는 데이터베이스의 미활동 대기 시간이 될 수 있다. 데이터베이스의 미활동 시간보다 설정 시간이 긴 경우 이미 데이터베이스에서 커넥션을 제거했기 때문에 <code class=\"language-text\">무의미한 검증 시간</code>이 될 수 있다.</p>\n<h3>minimumIdle</h3>\n<p>풀에서 유지할 최소 유휴 커넥션 개수를 지정한다. 기본 값은 <code class=\"language-text\">maximumPoolSize</code>와 동일하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HikariConfig</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">HikariConfigMXBean</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> maxPoolSize<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> minIdle<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">HikariConfig</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        minIdle <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        maxPoolSize <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">validate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        <span class=\"token function\">validateNumerics</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">validateNumerics</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>minIdle <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> minIdle <span class=\"token operator\">></span> maxPoolSize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            minIdle <span class=\"token operator\">=</span> maxPoolSize<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>HikariCP 문서에 따르면 설정하지 않는 것을 추천한다. 즉 maximumPoolSize와 동일 크기를 추천한다. 이 값을 작게 설정할 경우 급격한 트래픽 증가 시 성능 저하를 일으킬 수 있다.</p>\n<p>해당 설정은 트래픽이 적은 시간대에 데이터베이스 자원 사용을 줄이기 위함이다.</p>\n<h3>idleTimeout</h3>\n<p>사용하지 않고 풀에 머물 수 있는 시간인 최대 유휴 시간을 설정한다. 풀에서 설정한 시간동안 머무른 커넥션은 종료하고 풀에서 제거한다. 해당 설정은 <code class=\"language-text\">minimumIdle &lt; maximumPoolSize</code>인 경우 적용된다. </p>\n<h2>적절한 커넥션 풀 사이즈 고민하기</h2>\n<p><a href=\"https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing\">About Pool Sizing</a></p>\n<p>커넥션 풀을 구성하는 것은 개발자가 자주 실수하는 것이다. 풀을 구성할 때 이해 해야하는 몇 가지 원칙이 있을 수 있다.</p>\n<p>하나의 CPU 코어가 있는 컴퓨터도 수십 혹은 수백 개의 스레드를 <code class=\"language-text\">동시에</code> 지원할 수 있다. 하지만 이것은 운영체제의 속임수일 뿐이다. 실제로 단일 코어는 <code class=\"language-text\">한 번에 하나의 스레드</code>만 실행할 수 있다. 운영체제는 <code class=\"language-text\">컨텍스트 스위칭</code>을 한 뒤 다른 스레드의 코드를 실행할 뿐이다. 즉 빠른 시간의 <code class=\"language-text\">컨텍스트 스위칭</code>으로 동시에 진행하는 것 처럼 보일 뿐이다.</p>\n<p>단일 CPU가 주어지면 <code class=\"language-text\">A와 B를 순차적으로 실행하는 것</code>이 <code class=\"language-text\">시분할을 통해 A와 B를 동시에 실행하는 것</code> 보다 항상 빠를 것이라는 것은 컴퓨팅의 기본 법칙이다. 스레드 수가 CPU 코어 수를 초과하면 단순히 스레드 수가 더 많아질 뿐이지 더 빠른 속도를 보장하는 것은 아니다. 즉 단순히 풀의 크기를 늘린다고 더 빠른 속도로 처리되는 것은 아니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/0c90554deca414c631e0ec7b0c97a21f/2d788/thread-compare.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 25.882352941176467%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABW0lEQVQY0z2QSy9DcRDF+xUtERsL7xJFU+JVjyI0FkoiUiSIlCghoh6VSjyKsqmQPm/VVdVyqxu9Lfrzv4RJzkzOSebMyejS68soVjOZyREexweQrH0oE0MotmEy42Ycez4s1+9YfVlGzlIMuqOMXr4xJrjFm8GfyKLVV7H4M3XxuSkejDXIPQZC7fX422qROxt56G5Gbq/F5jikyfOC8SCBYUeiYc1Pi/uJ1sMkTbsyx4FH+Czw+VWkKEx1KfsE4bpyEp16uvZjlB1k0R8p3PV3cK+vQO41YHJFqNyWGXQFeTFV8VpdQmiom0ZhXOqUsF0pIpsw1BImPPuE5qeRVhfYOL1l/izKynmYoHMFaWHmZzouIsx6Yzi9AcKrS0SW7NxsbbLoizN7EsETeOLtNY2q5tHdJ5PEnlOo2o2C6IV3gRw5wf+g8V9d/ddU7Wea9pETezkURSGfz/MNe59M7VoFzsQAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='thread compare' title='thread compare' src='/static/0c90554deca414c631e0ec7b0c97a21f/ca1dc/thread-compare.png' srcset='/static/0c90554deca414c631e0ec7b0c97a21f/e7570/thread-compare.png 170w,\n/static/0c90554deca414c631e0ec7b0c97a21f/f46e7/thread-compare.png 340w,\n/static/0c90554deca414c631e0ec7b0c97a21f/ca1dc/thread-compare.png 680w,\n/static/0c90554deca414c631e0ec7b0c97a21f/02d09/thread-compare.png 1020w,\n/static/0c90554deca414c631e0ec7b0c97a21f/9d567/thread-compare.png 1360w,\n/static/0c90554deca414c631e0ec7b0c97a21f/2d788/thread-compare.png 1382w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>데이터베이스의 주요 병목 현상에 대해 살펴보면 CPU, 디스크, 네트워크 세 가지 관점으로 요약할 수 있다. 디스크와 네트워크를 무시하면 간단히 계산할 수 있다. 예시로 8개의 CPU 코어가 있는 서버가 있다고 가정하자. 서버는 커넥션 풀안에 커넥션 수를 8로 설정하면 최적의 성능을 제공할 수 있으며 이 이상의 커넥션을 생성할 경우 컨텍스트 스위칭의 오버헤드로 인해 속도는 느려질 것이다.</p>\n<p>그러나 <code class=\"language-text\">디스크</code>와 <code class=\"language-text\">네트워크</code>가 변수로 작용하게 된다. 데이터베이스는 일반적으로 디스크에 저장하는데, 전통적인 모터 구동 암에 읽기/쓰기 헤드가 장착된 회전 금속 플레이트로 구성된다. 읽기/쓰기 헤드는 한 번에 한 곳에만 읽을 수 있으며 다른 쿼리에 대한 데이터를 읽기 위해서는 새 위치를 <code class=\"language-text\">검색</code> 해야 한다. 따라서 탐색 시간 비용과 플래터의 데이터가 다시 돌아오기 까지 디스크를 기다려야 하는 <code class=\"language-text\">회전 비용</code>이 추가적으로 발생한다.</p>\n<p>디스크에서 위 과정이 일어나는 동안 스레드는 <code class=\"language-text\">block</code> 된다. 이 시간 동안 다른 스레드의 작업을 처리할 수 있는 여유가 생기게 된다. 이러한 여유 덕분에 실제로 더 많은 작업을 수행할 수 있게 된다.</p>\n<p>네트워크도 디스크와 유사하다. 이더넷 인터페이스를 통해  유선으로 데이터를 작성하면 송/수신 버퍼가 가득차거나 멈출 때 <code class=\"language-text\">block</code>이 발생할 수 있다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/702312033deaeb6e2764c87a46db46ed/9cafe/disk-io.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 38.82352941176471%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA+klEQVQoz41S2YqEQAzs//8UH/0OHxURERR1xvvE+6ihAj0Ps7PsFoQ0IalUdbe67xufQfR9j6qq0DQNlmXBtm0oigJZlkmwL0kSeJ6HcRzfswpfkOe5NPq+L0PP51PCdV04jiM5CAKYpgnDMGBZlggg1HVdOI5DghumaRJFXdehrmuUZYl1Xb/tRRiGQs4ZDdW2LR6Ph9ihClpkjSrTNJVMctaGYZDMYB+tzvMsZwb7FFXEcSykvBsSR1EkNVpm5l1ymb5DvVzP8axFqfM835ZpX4M2uJ0q9n3Hf/HjUTQpH8O2bVFLi8S3H/EZ6rdvQxLao10q1YR/4QXYrGXMhvZ95wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='disk io' title='disk io' src='/static/702312033deaeb6e2764c87a46db46ed/ca1dc/disk-io.png' srcset='/static/702312033deaeb6e2764c87a46db46ed/e7570/disk-io.png 170w,\n/static/702312033deaeb6e2764c87a46db46ed/f46e7/disk-io.png 340w,\n/static/702312033deaeb6e2764c87a46db46ed/ca1dc/disk-io.png 680w,\n/static/702312033deaeb6e2764c87a46db46ed/02d09/disk-io.png 1020w,\n/static/702312033deaeb6e2764c87a46db46ed/9cafe/disk-io.png 1317w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>다양한 상황을 고려 했을 때 PostgreSQL에서는 아래와 같은 공식을 제안했다. 또한 여러 데이터베이스에도 적용할 수 있다고 언급되어 있다. </p>\n<blockquote>\n<p><em>connections = (core<em>count * 2) + effective</em>spindle_count</em></p>\n</blockquote>\n<ul>\n<li><code class=\"language-text\">core_count * 2</code>: 코어 수에 근접할 수록 좋지만, 위에서 언급한 디스크 및 네트워크와 CPU의 속도차이로 인한 여유 시간을 활용하기 위해 계수 2를 곱해준다.</li>\n<li><code class=\"language-text\">effective_spindle_count</code>: 하드 디스크는 하나의 spindle을 가진다. spindle은 데이터베이스 서버가 관리할 수 있는 동시 I/O 요청 수를 말한다. 디스크가 <code class=\"language-text\">n개</code> 존재하면 <code class=\"language-text\">spindle_count</code>는 <code class=\"language-text\">n</code>이 될 수 있다.</li>\n</ul>\n<p>하나의 하드 디스크가 있는 4-core i7 CPU를 가진 서버에서 <code class=\"language-text\">9 = (4 * 2) + 1</code>의 커넥션 풀을 설정해야 한다. 대략 10을 설정할 수 있다. 위 공식은 절대적인 것이 아니기 때문에 풀 크기를 선정할 때 기준으로 활용할 수 있다. </p>\n<p>사용자가 10,000명이라고 커넥션 풀이 10,000개를 설정한 것은 굉장한 낭비에 가깝다. 1,000개도 많다. 심지어 100개의 커넥션도 과하다. 위에 언급한 바와 같이 <code class=\"language-text\">CPU core * 2</code> 보다 훨씬 많은 경우는 거의 없다. 데이터베이스를 과도하게 낭비하지 말자.</p>\n<p>다음 시간에는 이러한 내용을 기반으로 달록에 직접 적용해보려 한다.</p>\n<h2>References.</h2>\n<p><a href=\"https://github.com/brettwooldridge/HikariCP\">HikariCP</a><br>\n<a href=\"https://techblog.woowahan.com/2663/\">HikariCP Dead lock에서 벗어나기 (이론편)</a><br>\n<a href=\"https://techblog.woowahan.com/2664/\">HikariCP Dead lock에서 벗어나기 (실전편)</a><br>\n<a href=\"https://www.youtube.com/watch?v=6Q7iRTb4tQE\">프로그래밍 초식: 커넥션풀 설정</a><br>\n<a href=\"https://hyuntaeknote.tistory.com/m/12\">내가 만든 서비스는 얼마나 많은 사용자가 이용할 수 있을까? - 3편(DB Connection Pool)</a></p>","frontmatter":{"title":"HikariCP와 적절한 풀 사이즈 고민하기 (이론편)","date":"October 17, 2022","update":"October 17, 2022","tags":["매트","BE","HikariCP","데이터베이스 커넥션"],"series":null},"fields":{"slug":"/hikari-cp-theory/","readingTime":{"minutes":14.865}}},"seriesList":{"edges":[{"node":{"id":"a621dc7b-8590-5ec6-9b52-3d9e5182486d","fields":{"slug":"/appearance-background-of-jpa/"},"frontmatter":{"title":"JPA 등장배경"}}},{"node":{"id":"9d2a87b6-2b9c-5b87-b790-3426d17c2d8e","fields":{"slug":"/intellij-final-keyword/"},"frontmatter":{"title":"IntelliJ에서 메소드 추출한 메소드의 파라미터에 final 키워드 자동 추가하기"}}},{"node":{"id":"251e9767-1c92-5cf5-9cef-2c4a42c10df2","fields":{"slug":"/git-branch-strategy/"},"frontmatter":{"title":"달록팀의 git 브랜치 전략을 소개합니다."}}},{"node":{"id":"5090cce3-0c1f-5376-badc-1d25e44c1bd9","fields":{"slug":"/infinite-scroll/"},"frontmatter":{"title":"React에서 무한 스크롤 구현하기"}}},{"node":{"id":"bcb53ba5-0286-5d10-96c2-fdcb88e2cc60","fields":{"slug":"/package-structure/"},"frontmatter":{"title":"달록에 적절한 패키지 구조 고민하기"}}},{"node":{"id":"a7fc89de-f37c-596e-a81d-3d4fe5a795b8","fields":{"slug":"/data-jpa-slice-page/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"e1ba92ee-0cf0-50c8-80bd-5da5075df8d1","fields":{"slug":"/data-jpa-auditing/"},"frontmatter":{"title":"Spring Data JPA의 Auditing"}}},{"node":{"id":"3e036508-c916-504e-9e8d-89f69332471e","fields":{"slug":"/separated-interface/"},"frontmatter":{"title":"외부와 의존성 분리하기"}}},{"node":{"id":"cade544a-16ef-58a3-b97c-824986a8395f","fields":{"slug":"/apply-rest-docs/"},"frontmatter":{"title":"MockMvc를 사용한 Spring RestDocs"}}},{"node":{"id":"87649d54-d59e-58a6-afd5-8491eb4113a8","fields":{"slug":"/properties-to-object/"},"frontmatter":{"title":"properties 객체로 다루기"}}},{"node":{"id":"eb380f6d-5a00-5a9e-a916-003fb292cc8a","fields":{"slug":"/test-fixture-constant/"},"frontmatter":{"title":"테스트에서 Entity 객체를 상수로 두면 안 되는 이유"}}},{"node":{"id":"9734e30a-b430-5922-919d-f53808a56eb9","fields":{"slug":"/what_is_nginx/"},"frontmatter":{"title":"NGINX 란?"}}},{"node":{"id":"9ebc6e21-2a76-5d42-be33-c2dae8c849b2","fields":{"slug":"/ssl_protocol/"},"frontmatter":{"title":"SSL을 통한 HTTPS통신 과정"}}},{"node":{"id":"fa5ad595-1f81-5a20-a884-2da69adee3c5","fields":{"slug":"/integration-test-slice-test/"},"frontmatter":{"title":"통합 테스트와 슬라이스 테스트"}}},{"node":{"id":"d8c66823-bb05-5e83-a6a1-2fd9af450b6f","fields":{"slug":"/query-invalidation/"},"frontmatter":{"title":"React-Query에서의 데이터 최신화 (Query Invalidation)"}}},{"node":{"id":"f5187517-342f-52a1-9092-d12c1a80d132","fields":{"slug":"/seperate-components/"},"frontmatter":{"title":"컴포넌트 분리 기준"}}},{"node":{"id":"d6249c8b-bea6-5c91-8477-d3dd15ad9b39","fields":{"slug":"/test-isolation/"},"frontmatter":{"title":"테스트 격리"}}},{"node":{"id":"98e390ef-fb19-5d01-a3ef-d14bc0e65176","fields":{"slug":"/dallog-jacoco/"},"frontmatter":{"title":"달록의 Jacoco 적용기 (feat. Gradle)"}}},{"node":{"id":"33d19946-de0c-5b41-bfa0-d7c3fd80f10b","fields":{"slug":"/google-refresh-token/"},"frontmatter":{"title":"Google은 Refresh Token을 쉽게 내주지 않는다."}}},{"node":{"id":"8168857d-a82c-5608-bd40-cea4b917d17d","fields":{"slug":"/submodule/"},"frontmatter":{"title":"달록 서브모듈 도입기"}}},{"node":{"id":"836fc724-7e2f-5c7a-a42b-c0cc9163167a","fields":{"slug":"/dallog-flyway/"},"frontmatter":{"title":"달록의 데이터베이스 마이그레이션을 위한 Flyway 적용기"}}},{"node":{"id":"7a3bde6d-746b-56fd-8d91-0d8059ebf1f8","fields":{"slug":"/json-property-json-naming/"},"frontmatter":{"title":"@JsonProperty, @JsonNaming"}}},{"node":{"id":"50673f5c-f835-5982-b70c-b77e5a352a2c","fields":{"slug":"/servlet-life-cycle/"},"frontmatter":{"title":"서블릿 생명주기와 직접만든 톰캣을 통한 의문점"}}},{"node":{"id":"61e7f4d1-7b3a-5968-bfe8-c3f6efb88748","fields":{"slug":"/preparing-for-performance-test/"},"frontmatter":{"title":"톰캣 튜닝을 위한 달록의 서버 성능 테스트 준비 과정"}}},{"node":{"id":"9272061d-68c6-5f82-a961-0e2efe0fd6be","fields":{"slug":"/cyclic-dependency/"},"frontmatter":{"title":"cyclic dependency"}}},{"node":{"id":"6e779308-f266-58af-bfcc-e9fee6d39a98","fields":{"slug":"/multi-datasource-issue-with-osiv/"},"frontmatter":{"title":"대체 왜 DataSource 라우팅이 안되는거야!? (feat. OSIV)"}}},{"node":{"id":"0e63245e-c52c-5977-9f60-f94ee0fd00fc","fields":{"slug":"/hikari-cp-theory/"},"frontmatter":{"title":"HikariCP와 적절한 풀 사이즈 고민하기 (이론편)"}}},{"node":{"id":"c7bea043-345c-5f78-ae53-796a83812961","fields":{"slug":"/react-query-useMutation-trouble-shooting/"},"frontmatter":{"title":"react-query useMutation onSuccess 안 되는줄 알았던 트러블 슈팅"}}},{"node":{"id":"cf403487-1c48-5ca7-b5c2-ef0d8fefe3c4","fields":{"slug":"/jenkins-distributed-build-architecture/"},"frontmatter":{"title":"젠킨스 분산 빌드 아키텍처 구축"}}},{"node":{"id":"24c152c7-4e94-5b84-aaea-a5a9a8357693","fields":{"slug":"/zero-downtime-deployment/"},"frontmatter":{"title":"달록 무중단 배포 도입기"}}}]},"previous":{"fields":{"slug":"/multi-datasource-issue-with-osiv/"},"frontmatter":{"title":"대체 왜 DataSource 라우팅이 안되는거야!? (feat. OSIV)"}},"next":{"fields":{"slug":"/react-query-useMutation-trouble-shooting/"},"frontmatter":{"title":"react-query useMutation onSuccess 안 되는줄 알았던 트러블 슈팅"}}},"pageContext":{"id":"0e63245e-c52c-5977-9f60-f94ee0fd00fc","series":null,"previousPostId":"6e779308-f266-58af-bfcc-e9fee6d39a98","nextPostId":"c7bea043-345c-5f78-ae53-796a83812961"}},"staticQueryHashes":[]}