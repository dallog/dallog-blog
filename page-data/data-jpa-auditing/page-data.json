{"componentChunkName":"component---src-templates-post-jsx","path":"/data-jpa-auditing/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"e1ba92ee-0cf0-50c8-80bd-5da5075df8d1","excerpt":"이 글은 우테코 달록팀 크루 파랑이 작성했습니다. auditing이란 엔티티와 관련된 이벤트(insert, update, delete)를 추적하고 기록하는 것을 의미한다. 모든 엔티티에 생성일시, 수정일시, 생성한 사람을 추가하고 싶은 경우를 생각해보자. 모든 엔티티에 생성일시, 수정일시, 생성한 사람에 대한 필드를 일일이 구현해주어야 한다. 이렇게 되면…","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 <a href=\"https://github.com/summerlunaa\">파랑</a>이 작성했습니다.</p>\n</blockquote>\n<blockquote>\n<p>auditing이란 엔티티와 관련된 이벤트(insert, update, delete)를 추적하고 기록하는 것을 의미한다.</p>\n</blockquote>\n<p>모든 엔티티에 생성일시, 수정일시, 생성한 사람을 추가하고 싶은 경우를 생각해보자. 모든 엔티티에 생성일시, 수정일시, 생성한 사람에 대한 필드를 일일이 구현해주어야 한다. 이렇게 되면 모든 엔티티에 중복이 생기고 유지보수가 어려워진다. Spring Data JPA가 제공하는 <code class=\"language-text\">Auditing</code> 기능을 사용하면 이런 기능을 쉽고 빠르게 구현할 수 있다.</p>\n<h2>Spring Data JPA Auditing 적용하기</h2>\n<p><code class=\"language-text\">Auditing</code>을 적용하기 위해서는 우선 어노테이션을 적용해야 한다. <code class=\"language-text\">@Configuration</code> 어노테이션이 적용된 Config 클래스에 아래와 같이 <code class=\"language-text\">@EnableJpaAuditing</code>을 추가한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Configuration</span>\n<span class=\"token annotation punctuation\">@EnableJpaAuditing</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">JpaConfig</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>⚠️ 주의 : 원활한 Slice 테스트를 위해 @SpringBootApplication 과 @EnableJpaAuditing 어노테이션 분리하기</p>\n<p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.user-configuration-and-slicing\">https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.user-configuration-and-slicing</a></p>\n<h3>Spring Entity Callback Listener 적용하기</h3>\n<p>Auditing entity listener class로 지정하기 위해 <code class=\"language-text\">@EntityListeners</code> 어노테이션을 Entity 클래스에 추가한다. 인자로는 <code class=\"language-text\">AuditingEntityListener.class</code>를 넘긴다. 이 설정을 통해 엔티티에 이벤트가 발생했을 때 정보를 캡처할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@EntityListeners</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">AuditingEntityListener</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BaseEntity</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>생성일시, 수정일시 추적하기</h3>\n<p>생성일시는 <code class=\"language-text\">@CreatedDate</code>, 수정일시는 <code class=\"language-text\">@LastModifiedDate</code> 어노테이션을 통해 추적할 수 있다. 생성일시의 경우 한 번 생성되면 변경되어선 안 되며, 항상 존재해야 하므로 <code class=\"language-text\">nullable = false</code>, <code class=\"language-text\">updatable = false</code>로 지정한다.</p>\n<p>추가적으로 BaseEntity를 다른 Entity들이 상속받아 사용할 수 있도록 <code class=\"language-text\">@MappedSuperclass</code> 어노테이션을 통해 해당 클래스를 Entity가 아닌 SuperClass로 지정했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@MappedSuperclass</span>\n<span class=\"token annotation punctuation\">@EntityListeners</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">AuditingEntityListener</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BaseEntity</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@CreatedDate</span>\n    <span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"created_at\"</span><span class=\"token punctuation\">,</span> nullable <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> updatable <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">LocalDateTime</span> createdAt<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@LastModifiedDate</span>\n    <span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"updated_at\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">LocalDateTime</span> updatedAt<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>생성한 사람, 수정한 사람 추적하기</h3>\n<p>생성한 사람은 <code class=\"language-text\">@CreatedBy</code>, 수정한 사람은 <code class=\"language-text\">@LastModifiedBy</code> 어노테이션을 통해 추적할 수 있다. 해당 필드는 생성자, 수정자의 이름으로 채워진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@MappedSuperclass</span>\n<span class=\"token annotation punctuation\">@EntityListeners</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">AuditingEntityListener</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BaseEntity</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@CreatedBy</span>\n    <span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"created_by\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> createdBy<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@LastModifiedBy</span>\n    <span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"modified_by\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> modifiedBy<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>유저에 대한 정보는 SecurityContext's Authentication 인스턴스로부터 가져온다. 이 값을 커스텀하고 싶다면 <code class=\"language-text\">AuditorAware&lt;T></code> 인터페이스를 구현해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AuditorAwareImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">AuditorAware</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getCurrentAuditor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// your custom logic</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 만든 <code class=\"language-text\">AuditorAwareImpl</code>를 사용하려면 Config 클래스에 <code class=\"language-text\">AuditorAwareImpl</code> 인스턴스로 초기화되는 <code class=\"language-text\">AuditorAware</code> 타입의 빈을 설정해주어야 한다. 그리고 <code class=\"language-text\">@EnableJpaAuditing</code> 어노테이션에 <code class=\"language-text\">auditorAwareRef=\"auditorProvider\"</code> 설정을 추가한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Configuration</span>\n<span class=\"token annotation punctuation\">@EnableJpaAuditing</span><span class=\"token punctuation\">(</span>auditorAwareRef<span class=\"token operator\">=</span><span class=\"token string\">\"auditorProvider\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">JpaConfig</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//...</span>\n\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token class-name\">AuditorAware</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">auditorProvider</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AuditorAwareImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h3>References</h3>\n<p><a href=\"https://www.baeldung.com/database-auditing-jpa\">https://www.baeldung.com/database-auditing-jpa</a></p>","frontmatter":{"title":"Spring Data JPA의 Auditing","date":"July 18, 2022","update":"July 18, 2022","tags":["Spring","Data JPA","Auditing"],"series":null},"fields":{"slug":"/data-jpa-auditing/","readingTime":{"minutes":3.775}}},"seriesList":{"edges":[{"node":{"id":"a621dc7b-8590-5ec6-9b52-3d9e5182486d","fields":{"slug":"/appearance-background-of-jpa/"},"frontmatter":{"title":"JPA 등장배경"}}},{"node":{"id":"9d2a87b6-2b9c-5b87-b790-3426d17c2d8e","fields":{"slug":"/intellij-final-keyword/"},"frontmatter":{"title":"IntelliJ에서 메소드 추출한 메소드의 파라미터에 final 키워드 자동 추가하기"}}},{"node":{"id":"251e9767-1c92-5cf5-9cef-2c4a42c10df2","fields":{"slug":"/git-branch-strategy/"},"frontmatter":{"title":"달록팀의 git 브랜치 전략을 소개합니다."}}},{"node":{"id":"5090cce3-0c1f-5376-badc-1d25e44c1bd9","fields":{"slug":"/infinite-scroll/"},"frontmatter":{"title":"React에서 무한 스크롤 구현하기"}}},{"node":{"id":"bcb53ba5-0286-5d10-96c2-fdcb88e2cc60","fields":{"slug":"/package-structure/"},"frontmatter":{"title":"달록에 적절한 패키지 구조 고민하기"}}},{"node":{"id":"a7fc89de-f37c-596e-a81d-3d4fe5a795b8","fields":{"slug":"/data-jpa-slice-page/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"e1ba92ee-0cf0-50c8-80bd-5da5075df8d1","fields":{"slug":"/data-jpa-auditing/"},"frontmatter":{"title":"Spring Data JPA의 Auditing"}}},{"node":{"id":"3e036508-c916-504e-9e8d-89f69332471e","fields":{"slug":"/separated-interface/"},"frontmatter":{"title":"외부와 의존성 분리하기"}}},{"node":{"id":"cade544a-16ef-58a3-b97c-824986a8395f","fields":{"slug":"/apply-rest-docs/"},"frontmatter":{"title":"MockMvc를 사용한 Spring RestDocs"}}},{"node":{"id":"87649d54-d59e-58a6-afd5-8491eb4113a8","fields":{"slug":"/properties-to-object/"},"frontmatter":{"title":"properties 객체로 다루기"}}},{"node":{"id":"eb380f6d-5a00-5a9e-a916-003fb292cc8a","fields":{"slug":"/test-fixture-constant/"},"frontmatter":{"title":"테스트에서 Entity 객체를 상수로 두면 안 되는 이유"}}},{"node":{"id":"9734e30a-b430-5922-919d-f53808a56eb9","fields":{"slug":"/what_is_nginx/"},"frontmatter":{"title":"NGINX 란?"}}},{"node":{"id":"9ebc6e21-2a76-5d42-be33-c2dae8c849b2","fields":{"slug":"/ssl_protocol/"},"frontmatter":{"title":"SSL을 통한 HTTPS통신 과정"}}},{"node":{"id":"fa5ad595-1f81-5a20-a884-2da69adee3c5","fields":{"slug":"/integration-test-slice-test/"},"frontmatter":{"title":"통합 테스트와 슬라이스 테스트"}}},{"node":{"id":"d8c66823-bb05-5e83-a6a1-2fd9af450b6f","fields":{"slug":"/query-invalidation/"},"frontmatter":{"title":"React-Query에서의 데이터 최신화 (Query Invalidation)"}}},{"node":{"id":"f5187517-342f-52a1-9092-d12c1a80d132","fields":{"slug":"/seperate-components/"},"frontmatter":{"title":"컴포넌트 분리 기준"}}},{"node":{"id":"d6249c8b-bea6-5c91-8477-d3dd15ad9b39","fields":{"slug":"/test-isolation/"},"frontmatter":{"title":"테스트 격리"}}},{"node":{"id":"98e390ef-fb19-5d01-a3ef-d14bc0e65176","fields":{"slug":"/dallog-jacoco/"},"frontmatter":{"title":"달록의 Jacoco 적용기 (feat. Gradle)"}}},{"node":{"id":"33d19946-de0c-5b41-bfa0-d7c3fd80f10b","fields":{"slug":"/google-refresh-token/"},"frontmatter":{"title":"Google은 Refresh Token을 쉽게 내주지 않는다."}}},{"node":{"id":"8168857d-a82c-5608-bd40-cea4b917d17d","fields":{"slug":"/submodule/"},"frontmatter":{"title":"달록 서브모듈 도입기"}}},{"node":{"id":"836fc724-7e2f-5c7a-a42b-c0cc9163167a","fields":{"slug":"/dallog-flyway/"},"frontmatter":{"title":"달록의 데이터베이스 마이그레이션을 위한 Flyway 적용기"}}},{"node":{"id":"7a3bde6d-746b-56fd-8d91-0d8059ebf1f8","fields":{"slug":"/json-property-json-naming/"},"frontmatter":{"title":"@JsonProperty, @JsonNaming"}}},{"node":{"id":"50673f5c-f835-5982-b70c-b77e5a352a2c","fields":{"slug":"/servlet-life-cycle/"},"frontmatter":{"title":"서블릿 생명주기와 직접만든 톰캣을 통한 의문점"}}},{"node":{"id":"61e7f4d1-7b3a-5968-bfe8-c3f6efb88748","fields":{"slug":"/preparing-for-performance-test/"},"frontmatter":{"title":"톰캣 튜닝을 위한 달록의 서버 성능 테스트 준비 과정"}}},{"node":{"id":"9272061d-68c6-5f82-a961-0e2efe0fd6be","fields":{"slug":"/cyclic-dependency/"},"frontmatter":{"title":"cyclic dependency"}}},{"node":{"id":"6e779308-f266-58af-bfcc-e9fee6d39a98","fields":{"slug":"/multi-datasource-issue-with-osiv/"},"frontmatter":{"title":"대체 왜 DataSource 라우팅이 안되는거야!? (feat. OSIV)"}}},{"node":{"id":"0e63245e-c52c-5977-9f60-f94ee0fd00fc","fields":{"slug":"/hikari-cp-theory/"},"frontmatter":{"title":"HikariCP와 적절한 풀 사이즈 고민하기 (이론편)"}}}]},"previous":{"fields":{"slug":"/data-jpa-slice-page/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}},"next":{"fields":{"slug":"/deploy-automation-with-shell-script/"},"frontmatter":{"title":"쉘 스크립트와 함께하는 달록의 스프링부트 어플리케이션 배포 자동화"}}},"pageContext":{"id":"e1ba92ee-0cf0-50c8-80bd-5da5075df8d1","series":null,"previousPostId":"a7fc89de-f37c-596e-a81d-3d4fe5a795b8","nextPostId":"258c06fb-1629-5dfc-83b5-95e9d9661aa5"}},"staticQueryHashes":[]}