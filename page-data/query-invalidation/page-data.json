{"componentChunkName":"component---src-templates-post-jsx","path":"/query-invalidation/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"d8c66823-bb05-5e83-a6a1-2fd9af450b6f","excerpt":"이 글은 우테코 달록팀 크루 나인이 작성했습니다. React-Query의 캐싱개념은 stale과 cacheTime을 통해 이루어집니다. Stale 사전적 의미로 '신선하지 않은' 입니다. react query는 기본적으로 캐싱된 데이터를 stale하다고 생각합니다. react query에서는 stale time의 default이 0입니다. (즉, 캐싱이 …","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 <a href=\"https://github.com/jhy979\">나인</a>이 작성했습니다.</p>\n</blockquote>\n<p>React-Query의 캐싱개념은 stale과 cacheTime을 통해 이루어집니다.</p>\n<h2>Stale</h2>\n<blockquote>\n<p>사전적 의미로 '신선하지 않은' 입니다. react query는 기본적으로 캐싱된 데이터를 stale하다고 생각합니다.</p>\n</blockquote>\n<p>react query에서는 stale time의 default이 0입니다. (즉, 캐싱이 되지 않는다고 볼 수 있겠죠?)</p>\n<h3>staleTime</h3>\n<blockquote>\n<p>데이터가 fresh한 상태에서 stale한 상태로 변하는 시간입니다.</p>\n</blockquote>\n<ul>\n<li>fresh 상태일때는 쿼리 인스턴스가 새롭게 mount 되어도 fetch가 일어나지 않습니다. </li>\n<li>데이터가 fetch 되고 나서 staleTime이 지나지 않았다면 unmount 후 mount 되어도 fetch가 일어나지 않습니다.</li>\n</ul>\n<h3>cacheTime</h3>\n<blockquote>\n<p>데이터가 inactive 상태일 때 캐싱된 상태로 남아있는 시간입니다.</p>\n</blockquote>\n<ul>\n<li>쿼리 인스턴스가 unmount 되면 데이터는 inactive 상태로 변경되며, 캐시는 cacheTime만큼 유지됩니다.</li>\n<li>cacheTime은 staleTime과 관계없이, 무조건 <code class=\"language-text\">inactive된 시점</code>을 기준으로 캐싱을 결정합니다.</li>\n</ul>\n<hr>\n<h2>달록에서의 데이터 최신화</h2>\n<blockquote>\n<p>달록은 일정, 카테고리, 구독 등의 작업으로 인해 데이터의 변화가 잦은 어플리케이션입니다. 따라서 저희 팀은 staleTime을 지정해주지 않았습니다.</p>\n</blockquote>\n<p>그렇다면 stale한 데이터는 늘 최신화가 필요할 것입니다.</p>\n<p>그래서 저는 매번 새로운 데이터가 필요할 때마다 <code class=\"language-text\">useQuery의 refetch</code>를 강제적으로 실행시켜주는 방식을 생각했었습니다.</p>\n<p>예를 들면 일정을 추가(post)한 후에 일정을 다시 조회(get)하는 경우가 있을겁니다.</p>\n<p><img src=\"https://velog.velcdn.com/images/jhy979/post/287f66a2-8b7e-49c8-b623-c05a491db600/image.png\"></p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// refetch 함수를 부모로 부터 주입 받아야 합니다.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">ScheduleAddModal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> closeModal<span class=\"token punctuation\">,</span> refetch <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> ScheduleAddModalProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">onSuccessPostSchedule</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">refetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>😢 하지만 이 방식이 우아하지는 않더라구요. </p>\n<p>만약 부모와 자식 간의 props전달이 아니라 조부모와 자식 간의 props 전달이라면 어떨까요? 벌써 머리가 아파옵니다. (props hell)</p>\n<h2>Query Invalidation 도입</h2>\n<p>🤔 다른 방법이 있을텐데.. 어떤 방법이 있을까? 고민하며 공식문서를 읽던 도중 <code class=\"language-text\">Query Invalidation</code>을 발견하게 되었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// Invalidate every query in the cache</span>\nqueryClient<span class=\"token punctuation\">.</span><span class=\"token function\">invalidateQueries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// Invalidate every query with a key that starts with `todos`</span>\nqueryClient<span class=\"token punctuation\">.</span><span class=\"token function\">invalidateQueries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'todos'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<blockquote>\n<p>The QueryClient has an invalidateQueries method that lets you intelligently mark queries as stale and potentially refetch them too!</p>\n</blockquote>\n<p>❗ 캐싱키로 관련된 stale 쿼리들을 체크하고 refetch할 수 있는 메서드가 존재했습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">ScheduleAddModal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> closeModal <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> ScheduleAddModalProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> queryClient <span class=\"token operator\">=</span> <span class=\"token function\">useQueryClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">onSuccessPostSchedule</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 일정 post 성공 시 데이터 최신화를 invalidateQueries메서드를 통해 수행합니다.</span>\n    queryClient<span class=\"token punctuation\">.</span><span class=\"token function\">invalidateQueries</span><span class=\"token punctuation\">(</span><span class=\"token constant\">CACHE_KEY</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SCHEDULES</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>💪 이로써 useQuery의 refetch함수를 넘겨줄 필요없이 어디서든 캐싱키로 fresh한 데이터를 보장할 수 있게 되었습니다.</p>\n<h4>참고자료</h4>\n<p><a href=\"https://tanstack.com/query/v4/docs/guides/query-invalidation\">https://tanstack.com/query/v4/docs/guides/query-invalidation</a></p>","frontmatter":{"title":"React-Query에서의 데이터 최신화 (Query Invalidation)","date":"August 01, 2022","update":null,"tags":["react","react-query"],"series":null},"fields":{"slug":"/query-invalidation/","readingTime":{"minutes":3.835}}},"seriesList":{"edges":[{"node":{"id":"a621dc7b-8590-5ec6-9b52-3d9e5182486d","fields":{"slug":"/appearance-background-of-jpa/"},"frontmatter":{"title":"JPA 등장배경"}}},{"node":{"id":"9d2a87b6-2b9c-5b87-b790-3426d17c2d8e","fields":{"slug":"/intellij-final-keyword/"},"frontmatter":{"title":"IntelliJ에서 메소드 추출한 메소드의 파라미터에 final 키워드 자동 추가하기"}}},{"node":{"id":"251e9767-1c92-5cf5-9cef-2c4a42c10df2","fields":{"slug":"/git-branch-strategy/"},"frontmatter":{"title":"달록팀의 git 브랜치 전략을 소개합니다."}}},{"node":{"id":"5090cce3-0c1f-5376-badc-1d25e44c1bd9","fields":{"slug":"/infinite-scroll/"},"frontmatter":{"title":"React에서 무한 스크롤 구현하기"}}},{"node":{"id":"bcb53ba5-0286-5d10-96c2-fdcb88e2cc60","fields":{"slug":"/package-structure/"},"frontmatter":{"title":"달록에 적절한 패키지 구조 고민하기"}}},{"node":{"id":"a7fc89de-f37c-596e-a81d-3d4fe5a795b8","fields":{"slug":"/data-jpa-slice-page/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"e1ba92ee-0cf0-50c8-80bd-5da5075df8d1","fields":{"slug":"/data-jpa-auditing/"},"frontmatter":{"title":"Spring Data JPA의 Auditing"}}},{"node":{"id":"3e036508-c916-504e-9e8d-89f69332471e","fields":{"slug":"/separated-interface/"},"frontmatter":{"title":"외부와 의존성 분리하기"}}},{"node":{"id":"cade544a-16ef-58a3-b97c-824986a8395f","fields":{"slug":"/apply-rest-docs/"},"frontmatter":{"title":"MockMvc를 사용한 Spring RestDocs"}}},{"node":{"id":"87649d54-d59e-58a6-afd5-8491eb4113a8","fields":{"slug":"/properties-to-object/"},"frontmatter":{"title":"properties 객체로 다루기"}}},{"node":{"id":"eb380f6d-5a00-5a9e-a916-003fb292cc8a","fields":{"slug":"/test-fixture-constant/"},"frontmatter":{"title":"테스트에서 Entity 객체를 상수로 두면 안 되는 이유"}}},{"node":{"id":"9734e30a-b430-5922-919d-f53808a56eb9","fields":{"slug":"/what_is_nginx/"},"frontmatter":{"title":"NGINX 란?"}}},{"node":{"id":"9ebc6e21-2a76-5d42-be33-c2dae8c849b2","fields":{"slug":"/ssl_protocol/"},"frontmatter":{"title":"SSL을 통한 HTTPS통신 과정"}}},{"node":{"id":"fa5ad595-1f81-5a20-a884-2da69adee3c5","fields":{"slug":"/integration-test-slice-test/"},"frontmatter":{"title":"통합 테스트와 슬라이스 테스트"}}},{"node":{"id":"d8c66823-bb05-5e83-a6a1-2fd9af450b6f","fields":{"slug":"/query-invalidation/"},"frontmatter":{"title":"React-Query에서의 데이터 최신화 (Query Invalidation)"}}},{"node":{"id":"f5187517-342f-52a1-9092-d12c1a80d132","fields":{"slug":"/seperate-components/"},"frontmatter":{"title":"컴포넌트 분리 기준"}}},{"node":{"id":"d6249c8b-bea6-5c91-8477-d3dd15ad9b39","fields":{"slug":"/test-isolation/"},"frontmatter":{"title":"테스트 격리"}}},{"node":{"id":"98e390ef-fb19-5d01-a3ef-d14bc0e65176","fields":{"slug":"/dallog-jacoco/"},"frontmatter":{"title":"달록의 Jacoco 적용기 (feat. Gradle)"}}},{"node":{"id":"33d19946-de0c-5b41-bfa0-d7c3fd80f10b","fields":{"slug":"/google-refresh-token/"},"frontmatter":{"title":"Google은 Refresh Token을 쉽게 내주지 않는다."}}},{"node":{"id":"8168857d-a82c-5608-bd40-cea4b917d17d","fields":{"slug":"/submodule/"},"frontmatter":{"title":"달록 서브모듈 도입기"}}},{"node":{"id":"836fc724-7e2f-5c7a-a42b-c0cc9163167a","fields":{"slug":"/dallog-flyway/"},"frontmatter":{"title":"달록의 데이터베이스 마이그레이션을 위한 Flyway 적용기"}}},{"node":{"id":"7a3bde6d-746b-56fd-8d91-0d8059ebf1f8","fields":{"slug":"/json-property-json-naming/"},"frontmatter":{"title":"@JsonProperty, @JsonNaming"}}},{"node":{"id":"50673f5c-f835-5982-b70c-b77e5a352a2c","fields":{"slug":"/servlet-life-cycle/"},"frontmatter":{"title":"서블릿 생명주기와 직접만든 톰캣을 통한 의문점"}}},{"node":{"id":"61e7f4d1-7b3a-5968-bfe8-c3f6efb88748","fields":{"slug":"/preparing-for-performance-test/"},"frontmatter":{"title":"톰캣 튜닝을 위한 달록의 서버 성능 테스트 준비 과정"}}},{"node":{"id":"9272061d-68c6-5f82-a961-0e2efe0fd6be","fields":{"slug":"/cyclic-dependency/"},"frontmatter":{"title":"cyclic dependency"}}},{"node":{"id":"6e779308-f266-58af-bfcc-e9fee6d39a98","fields":{"slug":"/multi-datasource-issue-with-osiv/"},"frontmatter":{"title":"대체 왜 DataSource 라우팅이 안되는거야!? (feat. OSIV)"}}},{"node":{"id":"c7bea043-345c-5f78-ae53-796a83812961","fields":{"slug":"/react-query-useMutation-trouble-shooting/"},"frontmatter":{"title":"react-query useMutation onSuccess 안 되는줄 알았던 트러블 슈팅"}}},{"node":{"id":"cf403487-1c48-5ca7-b5c2-ef0d8fefe3c4","fields":{"slug":"/jenkins-distributed-build-architecture/"},"frontmatter":{"title":"젠킨스 분산 빌드 아키텍처 구축"}}},{"node":{"id":"24c152c7-4e94-5b84-aaea-a5a9a8357693","fields":{"slug":"/zero-downtime-deployment/"},"frontmatter":{"title":"달록 무중단 배포 도입기"}}},{"node":{"id":"623f9105-974d-51b9-84c7-f6298a8d1c19","fields":{"slug":"/get-valid-accessToken/"},"frontmatter":{"title":"refreshToken으로 accessToken 재발급하기"}}},{"node":{"id":"d34299f0-eb49-5aef-a38f-963200d5fd6d","fields":{"slug":"/test-readability/"},"frontmatter":{"title":"어떻게 테스트 코드 가독성을 개선할 수 있을까??"}}}]},"previous":{"fields":{"slug":"/integration-test-slice-test/"},"frontmatter":{"title":"통합 테스트와 슬라이스 테스트"}},"next":{"fields":{"slug":"/seperate-components/"},"frontmatter":{"title":"컴포넌트 분리 기준"}}},"pageContext":{"id":"d8c66823-bb05-5e83-a6a1-2fd9af450b6f","series":null,"previousPostId":"fa5ad595-1f81-5a20-a884-2da69adee3c5","nextPostId":"f5187517-342f-52a1-9092-d12c1a80d132"}},"staticQueryHashes":[]}