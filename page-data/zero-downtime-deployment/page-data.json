{"componentChunkName":"component---src-templates-post-jsx","path":"/zero-downtime-deployment/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"24c152c7-4e94-5b84-aaea-a5a9a8357693","excerpt":"이 글은 우테코 달록팀 크루 파랑이 작성했습니다. 무중단 배포 도입 이유 달록의 기존 배포 스크립트는 이렇습니다. 여기서 2 → 3의 과정, 구동중인 애플리케이션을 종료하고 새로 실행하는 과정에서 서비스가 중단됩니다. 저희 서비스의 중단 시간을 측정해보니 약  정도 중단되는 것을 확인할 수 있었습니다. 물론 지금이야 달록의 사용자가 많지 않아 그 동안 큰…","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 <a href=\"https://github.com/summerlunaa\">파랑</a>이 작성했습니다.</p>\n</blockquote>\n<h1>무중단 배포 도입 이유</h1>\n<p>달록의 기존 배포 스크립트는 이렇습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-z</span> <span class=\"token string\">\"<span class=\"token variable\">$CURRENT_PID</span>\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"🌈 구동중인 애플리케이션이 없으므로 종료하지 않습니다.\"</span>\n<span class=\"token keyword\">else</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"🌈 구동중인 애플리케이션을 종료했습니다. (pid : <span class=\"token variable\">$CURRENT_PID</span>)\"</span>\n    <span class=\"token function\">kill</span> <span class=\"token parameter variable\">-9</span> <span class=\"token variable\">$CURRENT_PID</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\n\">\\n</span>🌈 SpringBoot 애플리케이션을 실행합니다.<span class=\"token entity\" title=\"\\n\">\\n</span>\"</span>\n\n<span class=\"token assign-left variable\">JAR_NAME</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">ls</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> .jar <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-n</span> <span class=\"token number\">1</span><span class=\"token variable\">)</span></span>\n\n<span class=\"token function\">nohup</span> <span class=\"token function\">java</span> <span class=\"token parameter variable\">-jar</span> <span class=\"token parameter variable\">-Dserver.port</span><span class=\"token operator\">=</span><span class=\"token variable\">$1</span> <span class=\"token parameter variable\">-Dspring.profiles.active</span><span class=\"token operator\">=</span><span class=\"token variable\">${SPRING_PROFILE}</span> <span class=\"token parameter variable\">-Duser.timezone</span><span class=\"token operator\">=</span>Asia/Seoul /home/ubuntu/<span class=\"token variable\">$JAR_NAME</span> <span class=\"token operator\">></span> /dev/null <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span> <span class=\"token operator\">&amp;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. 구동중인 애플리케이션을 확인하고\n2. 구동중인 애플리케이션이 있다면 종료한다.\n3. 이후 jar 파일을 실행한다.</code></pre></div>\n<p>여기서 2 → 3의 과정, 구동중인 애플리케이션을 종료하고 새로 실행하는 과정에서 서비스가 중단됩니다. 저희 서비스의 중단 시간을 측정해보니 약 <code class=\"language-text\">8초</code> 정도 중단되는 것을 확인할 수 있었습니다.</p>\n<p>물론 지금이야 달록의 사용자가 많지 않아 그 동안 큰 문제는 없었습니다. 하지만 사용자가 많은 실제 서비스에서 매 배포때마다 8초씩 서비스가 멈춘다면 사용자들의 신뢰가 떨어지고 매출에도 영향을 미치겠조랭이떡? 🤔  저희 달록도 사용자의 편의성과 서비스의 안정성을 보장하기 위해 무중단 배포를 도입하기로 했습니다.</p>\n<h1>달록의 배포 전략 선택</h1>\n<p>이번 글은 실제 무중단 배포 도입기이기 때문에 이론적인 내용은 자세히 다루지 않겠습니다.</p>\n<blockquote>\n<p>무중단 배포 전략의 자세한 내용이 궁금하다면? <a href=\"https://hudi.blog/zero-downtime-deployment/\">후디의 무중단 배포 아키텍처와 배포 전략</a>을 참고해주세요.</p>\n</blockquote>\n<h2>1. 롤링(Rolling) 배포</h2>\n<blockquote>\n<p>트래픽을 점진적으로 구버전에서 새로운 버전으로 옮기는 방식.\n정</p>\n</blockquote>\n<p>애초에 달록은 EC2 한 대만 사용하고 있으며 호환성 문제가 발생할 가능성이 있어 제외했습니다.</p>\n<h2>2. 카나리(Canary) 배포</h2>\n<blockquote>\n<p>소수 인원에 대해서만 트래픽을 새로운 버전에 옮겨둔 상태에서 서비스를 운영한다. 새로운 버전에 이상이 없다고 판단하였을 경우에 모든 트래픽을 신규 버전으로 옮기는 방식. A/B 테스트를 하기에 적합하다.</p>\n</blockquote>\n<p>롤링 배포와 마찬가지로 호환성 문제가 발생합니다. 또한 달록에서는 트래픽까지 점진적으로 옮겨가며 배포할 정도로 오류 감지에 대한 필요성을 느끼지 못해 제외했습니다.</p>\n<h2>3. 블루그린(Blue/Green) 배포</h2>\n<blockquote>\n<p>현재 운영 중인 서비스를 종료하지 않고 새로운 운영 환경을 만든 뒤 트래픽을 한 번에 신버전으로 옮기는 방식.</p>\n</blockquote>\n<h3>3-1. N개의 서버를 이용하는 방식</h3>\n<p>기존에 N개의 서버를 사용하고 있었다면 새롭게 N개의 서버를 구성하여 신버전을 배포하고 트래픽을 옮기는 방식입니다. 이 방식을 사용하면 배포 시 서버 자원이 두 배로 필요하며 서버를 제거하지 않는다면 불필요하게 서버를 방치하게 됩니다.</p>\n<h3>3-2. <code class=\"language-text\">포트를 변경하는 방식</code></h3>\n<p>포트를 변경하는 방식의 장점은 서버 자원을 늘리지 않아도 무중단 배포가 가능하다는 것입니다. EC2 하나만 사용하는 달록에서는 이 방식이 자원을 늘리지 않으며 간단하게 무중단 배포를 적용할 수 있는 적절한 방법이라고 생각했습니다.</p>\n<p>이제 포트 변경 방식의 블루그린 배포 전략을 어떻게 적용했는지 알아보겠습니다.</p>\n<h1>포트 변경 방식의 블루그린 배포 전략 적용</h1>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/9344b830da3c9e25cda5144b40d78910/ac7a9/dallog_infra_before.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 56.470588235294116%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACXElEQVQoz12S227TQBCGewlSyTmxnfiw3vV6fYibNMHpIW2cpCoFmpQWCbiIKoQEEkKCCyTukOAReAJe9WfW4VBxMdrZteff79+Zna+fN/j54wsOpueYLS6xP1mCMYnnRYrQZTBbHtwkwew0guj6YFxhXwUwTA+hDDFKQnh05ooMDSPAjt7wIMKDBqPw0DQDVDohTFrPpzn49AqW5aHYYxhvDhFIjutFgJv3KxxJHwPaOzYHEzHqhsROpcVxr+KgPzzBbLlGteWjaSnYlg+xeIH0zTd4lg3TCXHw6TFELHE8H+Pj93dQroAIMwyTiChjIiRBjblbdzGaLLB8dF1SVumSnhvhMBIYhgqGE+F4L8aRSKC8GIpFCG2fbHNIkYL7EXp+jKYWrHdEKcLVGP39k5JQpoeQQYrrsUKRH5V2ZpGP0csJutMMT28LXL66gFG3sdsSqFCNzZN/hPerNo6LJ1jfbNCyQshkApv18TDOsCqWCAOiNCXUaoLwLMfqdo2LZyTYtFGj+nqHHJHgX8JKk8H2s5JSX6DD6EWwugKOI2G6MU4HETLDxTgaYB4HcBsWDEug2hao/RZs/G9Zxjl1WaLTU9SEpHzLGhU0SXy2x5F/KBAoH4sixPDtHG6XlYKa0L5LuFv3kI1OUZxdlZZ1mE6MKpHrN23b29HKX5N9JSGHCfLNHI5Fo9bkJMqoKXcEa22OrpvScA7KXFvueX20u4poo5LYpcakMqUGJeCUJ5T3qLsW06HgiP52sLXA9h19uo2Vgjo05R8xvWrxBp3ptVXmCu3y2/a7/l/X/QJiaj1obv5G1wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='기존 달록의 인프라 구조' title='기존 달록의 인프라 구조' src='/static/9344b830da3c9e25cda5144b40d78910/ca1dc/dallog_infra_before.png' srcset='/static/9344b830da3c9e25cda5144b40d78910/e7570/dallog_infra_before.png 170w,\n/static/9344b830da3c9e25cda5144b40d78910/f46e7/dallog_infra_before.png 340w,\n/static/9344b830da3c9e25cda5144b40d78910/ca1dc/dallog_infra_before.png 680w,\n/static/9344b830da3c9e25cda5144b40d78910/02d09/dallog_infra_before.png 1020w,\n/static/9344b830da3c9e25cda5144b40d78910/9d567/dallog_infra_before.png 1360w,\n/static/9344b830da3c9e25cda5144b40d78910/ac7a9/dallog_infra_before.png 1920w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>기존 달록의 인프라 구조</figcaption>\n  </figure></p>\n<p>위는 기존 달록의 인프라 구조입니다. 실제 prod 백엔드 서버를 기준으로 간단히 설명하겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. 젠킨스에서 github actions를 통해 merge를 감지\n2. 코드를 빌드한 뒤 jar 파일을 prod 서버로 전송\n3. 젠킨스가 prod 서버의 jar 파일 실행 스크립트를 실행\n4. 배포 완료</code></pre></div>\n<p>블루그린 전략을 적용하기 위해서는 3에서 jar 파일을 실행하기 전 배포할 포트 번호를 설정해 주어야 합니다. 따라서 위의 3번이 아래의 과정으로 대체됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. 현재 실행 중인 포트 번호 확인\n2. 새롭게 배포할 포트 번호로 애플리케이션 실행\n3. 새로운 포트에 애플리케이션이 잘 떴는지 확인(health check)\n4. nginx 설정에서 포트 번호 수정 후 reload\n5. 기존 포트 종료</code></pre></div>\n<p>달록은 이 과정을 젠킨스 파이프라인 스크립트에 추가했습니다. 코드를 보겠습니다.</p>\n<ul>\n<li>파이프라인 스크립트는 선언형(Declarative)으로 작성했습니다.</li>\n<li>SSH Agent 플러그인을 사용했습니다.</li>\n<li>전체 코드가 궁금하다면? <a href=\"https://www.notion.so/9435a94ef13244d2bb31e4adfb339b38\">달록의 backend-prod 젠킨스 파일 전체 보기</a></li>\n</ul>\n<h3>1. 현재 실행 중인 포트 번호 확인</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token function\">curl</span> <span class=\"token parameter variable\">-s</span> <span class=\"token string\">\"http://<span class=\"token variable\">${BACKEND_PROD_PUBLIC_IP}</span>:<span class=\"token variable\">${BLUE_PORT}</span>\"</span> <span class=\"token operator\">></span> /dev/null\n<span class=\"token keyword\">then</span>\n    <span class=\"token assign-left variable\">target_port</span><span class=\"token operator\">=</span><span class=\"token variable\">${GREEN_PORT}</span>\n<span class=\"token keyword\">else</span>\n    <span class=\"token assign-left variable\">target_port</span><span class=\"token operator\">=</span><span class=\"token variable\">${BLUE_PORT}</span>\n<span class=\"token keyword\">fi</span></code></pre></div>\n<p>BLUE<em>PORT(8080)에 health check를 합니다. BLUE</em>PORT가 살아 있다면 <code class=\"language-text\">target_port</code>를 GREEN<em>PORT(8081)로, 죽어 있다면 BLUE</em>PORT로 설정합니다.</p>\n<h3>2. 새롭게 배포할 포트 번호로 애플리케이션 실행</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">scp</span> <span class=\"token parameter variable\">-o</span> <span class=\"token assign-left variable\">StrictHostKeyChecking</span><span class=\"token operator\">=</span>no backend-0.0.1-SNAPSHOT.jar ubuntu@<span class=\"token variable\">${BACKEND_PROD_IP}</span>:/home/ubuntu\n<span class=\"token function\">ssh</span> ubuntu@<span class=\"token variable\">${BACKEND_PROD_IP}</span> <span class=\"token string\">'sh run.sh ${target_port}'</span> <span class=\"token operator\">&amp;</span></code></pre></div>\n<p><code class=\"language-text\">scp</code> 명령어를 통해 jar 파일을 백엔드 서버로 전송합니다. 이후 <code class=\"language-text\">run.sh</code> 스크립트를 실행합니다. 이 때 인자로 <code class=\"language-text\">target_port</code> 를 넘깁니다. 실행 스크립트는 아래와 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#! /bin/bash</span>\n\n<span class=\"token assign-left variable\">PROJECT_NAME</span><span class=\"token operator\">=</span>backend\n<span class=\"token assign-left variable\">SPRING_PROFILE</span><span class=\"token operator\">=</span>prod\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\n\">\\n</span>🌈 SpringBoot 애플리케이션을 실행합니다.<span class=\"token entity\" title=\"\\n\">\\n</span>\"</span>\n\n<span class=\"token assign-left variable\">JAR_NAME</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">ls</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> .jar <span class=\"token operator\">|</span> <span class=\"token function\">head</span> <span class=\"token parameter variable\">-n</span> <span class=\"token number\">1</span><span class=\"token variable\">)</span></span>\n\n<span class=\"token function\">nohup</span> <span class=\"token function\">java</span> <span class=\"token parameter variable\">-jar</span> <span class=\"token parameter variable\">-Dserver.port</span><span class=\"token operator\">=</span><span class=\"token variable\">$1</span> <span class=\"token parameter variable\">-Dspring.profiles.active</span><span class=\"token operator\">=</span><span class=\"token variable\">${SPRING_PROFILE}</span> <span class=\"token parameter variable\">-Duser.timezone</span><span class=\"token operator\">=</span>Asia/Seoul /home/ubuntu/<span class=\"token variable\">$JAR_NAME</span> <span class=\"token operator\">></span> /dev/null <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span> <span class=\"token operator\">&amp;</span></code></pre></div>\n<p>jar 파일 실행 시 시스템 변수인 <code class=\"language-text\">server.port</code> 값을 설정해주어서 원하는 포트에서 애플리케이션이 실행되도록 설정했습니다.</p>\n<p>찾아해보면 properties 파일을 포트별로 나눠 사용하기도 합니다. 하지만 포트에 따라 properties 파일을 나누면 관리 포인트가 늘어나는 것이 마음에 들지 않았습니다. 따라서 이렇게 스크립트 실행 시 포트를 인자로 받아 설정하는 방법을 선택했습니다.</p>\n<h3>3. 새로운 포트에 애플리케이션이 잘 떴는지 확인(health check)</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">retry_count</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">$(</span>$seq <span class=\"token number\">10</span><span class=\"token variable\">)</span></span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token keyword\">if</span> <span class=\"token function\">curl</span> <span class=\"token parameter variable\">-s</span> <span class=\"token string\">\"http://<span class=\"token variable\">${BACKEND_PROD_PUBLIC_IP}</span>:<span class=\"token variable\">${target_port}</span>\"</span> <span class=\"token operator\">></span> /dev/null\n    <span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Health check success ✅ port number: <span class=\"token variable\">${target_port}</span>\"</span>\n        <span class=\"token builtin class-name\">break</span>\n    <span class=\"token keyword\">fi</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$retry_count</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">10</span> <span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Health check failed ❌ port number: <span class=\"token variable\">${target_port}</span>\"</span>\n        <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">fi</span>\n\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The server is not alive yet. Retry health check in 20 seconds... retry count: <span class=\"token variable\">${retry_count}</span>\"</span>\n    <span class=\"token function\">sleep</span> <span class=\"token number\">20</span>\n<span class=\"token keyword\">done</span></code></pre></div>\n<p>20초 단위로 최대 10번 <code class=\"language-text\">target_port</code> 에 애플리케이션이 잘 떴는지 health check를 실시합니다. 지금은 20초 단위로 확인하고 있어 애플리케이션이 제대로 뜨지 않은 경우 3분 20초나 기다리게 됩니다. health check의 텀이 너무 긴 것 같긴 하네요😅. 10초나 그 이하로 줄여도 괜찮을 것 같습니다.</p>\n<p>다시 스크립트로 돌아와서 health check에 성공한다면 for 문을 빠져 나갑니다. 만약 10번의 시도가 모두 실패한다면 exit으로 스크립트를 종료합니다.</p>\n<h3>4. nginx 설정에서 포트 번호 수정 후 reload</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ssh</span> <span class=\"token parameter variable\">-o</span> <span class=\"token assign-left variable\">StrictHostKeyChecking</span><span class=\"token operator\">=</span>no ubuntu@<span class=\"token variable\">${BACKEND_WS_IP}</span> <span class=\"token string\">\"echo 'set <span class=\"token entity\" title=\"\\\\\">\\\\</span>\\<span class=\"token variable\">$service_port</span> <span class=\"token variable\">${target_port}</span>;' | sudo tee /etc/nginx/conf.d/service-port.inc &amp;&amp; sudo service nginx reload\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Switch the reverse proxy direction of nginx to <span class=\"token variable\">${target_port}</span> 🔄\"</span></code></pre></div>\n<p>nginx가 떠있는 백엔드 WS 서버에 service할 포트 번호를 설정하는 파일을 만들어 줍니다. <code class=\"language-text\">tee</code>는 명령어의 출력 결과를 파일과 화면에 동시에 출력하는 명령어입니다.</p>\n<p>즉, <code class=\"language-text\">echo 'set \\\\\\$service_port ${target_port};'</code> 이 명령의 결과를 화면과 <code class=\"language-text\">/etc/nginx/conf.d/service-port.inc</code> 이 위치에 출력하라는 것입니다. <code class=\"language-text\">$service_port</code> 앞에 역슬래시가 3번 붙는 이유는 <code class=\"language-text\">$</code> 로 한 번, 작은 따옴표에서 한 번, <code class=\"language-text\">ssh</code> 명령어에서 한 번 escape가 일어나기 때문입니다. 우리는 <code class=\"language-text\">service_port</code> 의 실제 변수 값을 쓰고 싶은 게 아니라 <code class=\"language-text\">$service_port</code> 이 단어 자체를 쓰고 싶은 것이기 때문에 역슬래시를 3번 붙여주어야 합니다.</p>\n<p>이 명령어를 통해 만들어진 파일의 결과는 아래와 같습니다. 실행할 포트 번호가 8081인 경우엔 8081로 쓰이겠죠?</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># /etc/nginx/conf.d/service-port.inc</span>\n<span class=\"token builtin class-name\">set</span> <span class=\"token variable\">$service_port</span> <span class=\"token number\">8080</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 작업이 끝나면 nginx를 reload해서 바뀐 포트 번호로 요청이 가도록 합니다. nginx의 설정 파일은 아래와 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># /etc/nginx/conf.d/default.conf</span>\nserver <span class=\"token punctuation\">{</span>\n  listen <span class=\"token number\">443</span> ssl http2<span class=\"token punctuation\">;</span>\n  server_name api.dallog.me<span class=\"token punctuation\">;</span>\n\n  ssl_certificate /etc/letsencrypt/live/api.dallog.me/fullchain.pem<span class=\"token punctuation\">;</span>\n  ssl_certificate_key /etc/letsencrypt/live/api.dallog.me/privkey.pem<span class=\"token punctuation\">;</span>\n\n  include /etc/nginx/conf.d/service-port.inc<span class=\"token punctuation\">;</span> <span class=\"token comment\"># 포트 변수 선언 파일 include</span>\n\n  location / <span class=\"token punctuation\">{</span>\n    proxy_pass http://<span class=\"token variable\">$dallog_prod_ip</span><span class=\"token builtin class-name\">:</span><span class=\"token variable\">$service_port</span><span class=\"token punctuation\">;</span> <span class=\"token comment\"># 바뀐 포트로 리버스 프록시 설정</span>\n    proxy_set_header Host <span class=\"token variable\">$http_host</span><span class=\"token punctuation\">;</span>\n    proxy_set_header X-Real-IP <span class=\"token variable\">$remote_addr</span><span class=\"token punctuation\">;</span>\n    proxy_set_header X-Forwarded-For <span class=\"token variable\">$proxy_add_x_forwarded_for</span><span class=\"token punctuation\">;</span>\n    proxy_set_header X-Forwarded-Proto <span class=\"token variable\">$scheme</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>⚠️  여기서 주의할 점!! 혹시 한 인스턴스에 nginx와 spring을 함께 띄워두셨나요? </p>\n<p>혹시 <code class=\"language-text\">http://localhos:$service_port;</code> 로 리버스 프록시를 설정했는데 동작이 안 되나요? </p>\n<p>그렇다면 이 부분을 유심히 봐주세요.</p>\n</blockquote>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/9344b830da3c9e25cda5144b40d78910/ac7a9/dallog_infra_before.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 56.470588235294116%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACXElEQVQoz12S227TQBCGewlSyTmxnfiw3vV6fYibNMHpIW2cpCoFmpQWCbiIKoQEEkKCCyTukOAReAJe9WfW4VBxMdrZteff79+Zna+fN/j54wsOpueYLS6xP1mCMYnnRYrQZTBbHtwkwew0guj6YFxhXwUwTA+hDDFKQnh05ooMDSPAjt7wIMKDBqPw0DQDVDohTFrPpzn49AqW5aHYYxhvDhFIjutFgJv3KxxJHwPaOzYHEzHqhsROpcVxr+KgPzzBbLlGteWjaSnYlg+xeIH0zTd4lg3TCXHw6TFELHE8H+Pj93dQroAIMwyTiChjIiRBjblbdzGaLLB8dF1SVumSnhvhMBIYhgqGE+F4L8aRSKC8GIpFCG2fbHNIkYL7EXp+jKYWrHdEKcLVGP39k5JQpoeQQYrrsUKRH5V2ZpGP0csJutMMT28LXL66gFG3sdsSqFCNzZN/hPerNo6LJ1jfbNCyQshkApv18TDOsCqWCAOiNCXUaoLwLMfqdo2LZyTYtFGj+nqHHJHgX8JKk8H2s5JSX6DD6EWwugKOI2G6MU4HETLDxTgaYB4HcBsWDEug2hao/RZs/G9Zxjl1WaLTU9SEpHzLGhU0SXy2x5F/KBAoH4sixPDtHG6XlYKa0L5LuFv3kI1OUZxdlZZ1mE6MKpHrN23b29HKX5N9JSGHCfLNHI5Fo9bkJMqoKXcEa22OrpvScA7KXFvueX20u4poo5LYpcakMqUGJeCUJ5T3qLsW06HgiP52sLXA9h19uo2Vgjo05R8xvWrxBp3ptVXmCu3y2/a7/l/X/QJiaj1obv5G1wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='기존 달록의 인프라 구조' title='기존 달록의 인프라 구조' src='/static/9344b830da3c9e25cda5144b40d78910/ca1dc/dallog_infra_before.png' srcset='/static/9344b830da3c9e25cda5144b40d78910/e7570/dallog_infra_before.png 170w,\n/static/9344b830da3c9e25cda5144b40d78910/f46e7/dallog_infra_before.png 340w,\n/static/9344b830da3c9e25cda5144b40d78910/ca1dc/dallog_infra_before.png 680w,\n/static/9344b830da3c9e25cda5144b40d78910/02d09/dallog_infra_before.png 1020w,\n/static/9344b830da3c9e25cda5144b40d78910/9d567/dallog_infra_before.png 1360w,\n/static/9344b830da3c9e25cda5144b40d78910/ac7a9/dallog_infra_before.png 1920w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>기존 달록의 인프라 구조</figcaption>\n  </figure></p>\n<p>기존 달록의 인프라 구조를 다시 가져왔습니다. 달록은 prod 서버와 dev 서버에 모두 무중단 배포를 적용했는데요, 위 사진에서 보이다시피 dev 서버의 경우 하나의 인스턴스에 nginx와 spring을 함께 띄워놨습니다. 따라서 nginx 설정 파일에서 <code class=\"language-text\">http://localhost:$service_port;</code> 로 주소를 설정해주었습니다.</p>\n<p>분명 스크립트도 똑같이 짰고 설정도 잘 했는데 <code class=\"language-text\">service_port</code> 변수 값을 불러오지 못하는 에러를 만났습니다🥲. 한참을 찾아보니 <code class=\"language-text\">localhost</code>를 사용하면 <code class=\"language-text\">resolver</code>를 통해 주소를 <code class=\"language-text\">127.0.0.1</code> 로 변환하는데 뒤에 <code class=\"language-text\">$service_port</code> 변수가 붙어 주소를 찾아 변환하는 과정에 문제가 생기는 것이었습니다.</p>\n<blockquote>\n<p>약간의 참고 자료 → <a href=\"https://trac.nginx.org/nginx/ticket/2335\">https://trac.nginx.org/nginx/ticket/2335</a></p>\n</blockquote>\n<p>정확한 원인까지는 파악하지 못했으나 <strong>혹시 한 인스턴스에 nginx와 spring을 함께 두었다면 꼭 주소를 <code class=\"language-text\">localhost</code> 가 아닌 <code class=\"language-text\">127.0.0.1</code> 로 설정합시다.</strong></p>\n<h3>5. 기존 포트 종료</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">${target_port}</span>\"</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"<span class=\"token variable\">${BLUE_PORT}</span>\"</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n    <span class=\"token function\">ssh</span> ubuntu@<span class=\"token variable\">${BACKEND_PROD_IP}</span> <span class=\"token string\">\"fuser -s -k <span class=\"token variable\">${GREEN_PORT}</span>/tcp\"</span>\n<span class=\"token keyword\">else</span>\n    <span class=\"token function\">ssh</span> ubuntu@<span class=\"token variable\">${BACKEND_PROD_IP}</span> <span class=\"token string\">\"fuser -s -k <span class=\"token variable\">${BLUE_PORT}</span>/tcp\"</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Kill the process on the opposite server. 🔪\"</span></code></pre></div>\n<p>기존 포트를 종료합니다.</p>\n<h1>무중단 배포 결과</h1>\n<p>포트 변경 방식의 블루그린 전략을 적용한 달록의 CI/CD 구조는 이렇습니다. 중간에 WS에 변경된 포트 번호를 설정해주는 부분은 사진에서 생략되어 있습니다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/dbf24e47117afdb8b8942178078c1508/ac7a9/dallog_cicd_after.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 56.470588235294116%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACe0lEQVQoz02SW08TQRiGmxglcupp225beqLtbre73e2ZttiT0AKBcCgmnKSIMQZRNBovCd57Zbzwyv/6OLNG5OLL7MzsPPO97zuexUABn1JkMWDgVwz6tTKbtk6jWGYymTI9uaRUqHP18Y7ro0OcbIFsxkFPW8RiopI1AmETb9BwOZ5gpMSbt185Pf/A2fSG4+lnnJzF+doG+UyZlllj0mqgJqpYWgXj0y9SxRFaOEcqXkCJlgmGrf9Af8hke3fK1s5L1HiZTK5FToD6K33sYovlfJtadUg83SQvutKsIYYm1tUCAW+OcLwiOnwAnPdpRMXtiuhUyg9FbRS1hLpUIS3g8uc5r0Y42aST1Rj3CgzWB5SbDt1hi2zCxvcQqJs99iav3YOy26gASfCCXyccc7Ar65xf3LC2eULUr3H85YgX11M2Lvd49+2KJUV0qtqujy5QkpOpGkrIcIERIVtuyEqkGwTlz6L7OZ9O0Jdm9HxCr7tD/9kO2+MD8imTeb/Bo5mE24THq5jM6PvMxtoEQkVXqpT4ZDYjvqtEIgZq1OTq5pbd0Ta1ZA49ZYuky+SXK4QjRSr1TW7vvrOsdfD4AhqJ5imp1hlBAZSpF6yBG5Td2KJRsBlX61jVDbpWjdphHb3bwLugMReQvpms9vb58fM3hjjnpnxx8Z7J4StXckhITGQalOtjNHNASSS93hrgFRaoio59NKQ+6uBbyLMo7ApGLBc03johtbzy10NZclMC5UOVo0x/SXholIYUnTUy+Q5ZrU3THuBYPTFvuxKz+iqd7h67B5fumudfALK87o0lN10ZTijq3D8juSZLJqpEnfu5LOn546dpd/wDvrVMrq5/IVcAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='무중단 배포를 적용한 달록의 CI/CD 구조' title='무중단 배포를 적용한 달록의 CI/CD 구조' src='/static/dbf24e47117afdb8b8942178078c1508/ca1dc/dallog_cicd_after.png' srcset='/static/dbf24e47117afdb8b8942178078c1508/e7570/dallog_cicd_after.png 170w,\n/static/dbf24e47117afdb8b8942178078c1508/f46e7/dallog_cicd_after.png 340w,\n/static/dbf24e47117afdb8b8942178078c1508/ca1dc/dallog_cicd_after.png 680w,\n/static/dbf24e47117afdb8b8942178078c1508/02d09/dallog_cicd_after.png 1020w,\n/static/dbf24e47117afdb8b8942178078c1508/9d567/dallog_cicd_after.png 1360w,\n/static/dbf24e47117afdb8b8942178078c1508/ac7a9/dallog_cicd_after.png 1920w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>무중단 배포를 적용한 달록의 CI/CD 구조</figcaption>\n  </figure></p>\n<p>그린블루 전략으로 무중단 배포를 적용한 결과 downtime이 <code class=\"language-text\">8초</code>에서 <code class=\"language-text\">0.03초</code>로 크게 줄었습니다. nginx reload하는 이 짧은 시간까지도 없애는 방법이 있는지 궁금하네요. 아시는 분은 댓글로 남겨주시면 감사하겠습니다.</p>\n<h3>References</h3>\n<p><a href=\"https://hudi.blog/zero-downtime-deployment-with-jenkins-and-nginx/\">Jenkins와 Nginx로 스프링부트 애플리케이션 무중단 배포하기</a></p>\n<p><a href=\"https://ecsimsw.tistory.com/940\">무중단 배포 적용기</a></p>\n<p><a href=\"https://recordsoflife.tistory.com/325\">Spring Boot에서 기본 포트를 변경하는 방법</a></p>\n<p><a href=\"https://www.samsungsds.com/kr/insights/1256264_4627.html\">무중단 배포 아키텍처(Zero Downtime Deployment)- 글로벌 서비스 운영의 필수 요소</a></p>","frontmatter":{"title":"달록 무중단 배포 도입기","date":"October 26, 2022","update":"October 26, 2022","tags":["deploy","DevOps","파랑"],"series":null},"fields":{"slug":"/zero-downtime-deployment/","readingTime":{"minutes":14.875}}},"seriesList":{"edges":[{"node":{"id":"a621dc7b-8590-5ec6-9b52-3d9e5182486d","fields":{"slug":"/appearance-background-of-jpa/"},"frontmatter":{"title":"JPA 등장배경"}}},{"node":{"id":"9d2a87b6-2b9c-5b87-b790-3426d17c2d8e","fields":{"slug":"/intellij-final-keyword/"},"frontmatter":{"title":"IntelliJ에서 메소드 추출한 메소드의 파라미터에 final 키워드 자동 추가하기"}}},{"node":{"id":"251e9767-1c92-5cf5-9cef-2c4a42c10df2","fields":{"slug":"/git-branch-strategy/"},"frontmatter":{"title":"달록팀의 git 브랜치 전략을 소개합니다."}}},{"node":{"id":"5090cce3-0c1f-5376-badc-1d25e44c1bd9","fields":{"slug":"/infinite-scroll/"},"frontmatter":{"title":"React에서 무한 스크롤 구현하기"}}},{"node":{"id":"bcb53ba5-0286-5d10-96c2-fdcb88e2cc60","fields":{"slug":"/package-structure/"},"frontmatter":{"title":"달록에 적절한 패키지 구조 고민하기"}}},{"node":{"id":"a7fc89de-f37c-596e-a81d-3d4fe5a795b8","fields":{"slug":"/data-jpa-slice-page/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"e1ba92ee-0cf0-50c8-80bd-5da5075df8d1","fields":{"slug":"/data-jpa-auditing/"},"frontmatter":{"title":"Spring Data JPA의 Auditing"}}},{"node":{"id":"3e036508-c916-504e-9e8d-89f69332471e","fields":{"slug":"/separated-interface/"},"frontmatter":{"title":"외부와 의존성 분리하기"}}},{"node":{"id":"cade544a-16ef-58a3-b97c-824986a8395f","fields":{"slug":"/apply-rest-docs/"},"frontmatter":{"title":"MockMvc를 사용한 Spring RestDocs"}}},{"node":{"id":"87649d54-d59e-58a6-afd5-8491eb4113a8","fields":{"slug":"/properties-to-object/"},"frontmatter":{"title":"properties 객체로 다루기"}}},{"node":{"id":"eb380f6d-5a00-5a9e-a916-003fb292cc8a","fields":{"slug":"/test-fixture-constant/"},"frontmatter":{"title":"테스트에서 Entity 객체를 상수로 두면 안 되는 이유"}}},{"node":{"id":"9734e30a-b430-5922-919d-f53808a56eb9","fields":{"slug":"/what_is_nginx/"},"frontmatter":{"title":"NGINX 란?"}}},{"node":{"id":"9ebc6e21-2a76-5d42-be33-c2dae8c849b2","fields":{"slug":"/ssl_protocol/"},"frontmatter":{"title":"SSL을 통한 HTTPS통신 과정"}}},{"node":{"id":"fa5ad595-1f81-5a20-a884-2da69adee3c5","fields":{"slug":"/integration-test-slice-test/"},"frontmatter":{"title":"통합 테스트와 슬라이스 테스트"}}},{"node":{"id":"d8c66823-bb05-5e83-a6a1-2fd9af450b6f","fields":{"slug":"/query-invalidation/"},"frontmatter":{"title":"React-Query에서의 데이터 최신화 (Query Invalidation)"}}},{"node":{"id":"f5187517-342f-52a1-9092-d12c1a80d132","fields":{"slug":"/seperate-components/"},"frontmatter":{"title":"컴포넌트 분리 기준"}}},{"node":{"id":"d6249c8b-bea6-5c91-8477-d3dd15ad9b39","fields":{"slug":"/test-isolation/"},"frontmatter":{"title":"테스트 격리"}}},{"node":{"id":"98e390ef-fb19-5d01-a3ef-d14bc0e65176","fields":{"slug":"/dallog-jacoco/"},"frontmatter":{"title":"달록의 Jacoco 적용기 (feat. Gradle)"}}},{"node":{"id":"ab7073d6-575f-55b8-8b1d-fec1ea27916f","fields":{"slug":"/cannot-scroll-to-top-of-flex-element/"},"frontmatter":{"title":"스크롤을 했더니 윗부분이 안 보여요!"}}},{"node":{"id":"33d19946-de0c-5b41-bfa0-d7c3fd80f10b","fields":{"slug":"/google-refresh-token/"},"frontmatter":{"title":"Google은 Refresh Token을 쉽게 내주지 않는다."}}},{"node":{"id":"8168857d-a82c-5608-bd40-cea4b917d17d","fields":{"slug":"/submodule/"},"frontmatter":{"title":"달록 서브모듈 도입기"}}},{"node":{"id":"836fc724-7e2f-5c7a-a42b-c0cc9163167a","fields":{"slug":"/dallog-flyway/"},"frontmatter":{"title":"달록의 데이터베이스 마이그레이션을 위한 Flyway 적용기"}}},{"node":{"id":"7a3bde6d-746b-56fd-8d91-0d8059ebf1f8","fields":{"slug":"/json-property-json-naming/"},"frontmatter":{"title":"@JsonProperty, @JsonNaming"}}},{"node":{"id":"50673f5c-f835-5982-b70c-b77e5a352a2c","fields":{"slug":"/servlet-life-cycle/"},"frontmatter":{"title":"서블릿 생명주기와 직접만든 톰캣을 통한 의문점"}}},{"node":{"id":"61e7f4d1-7b3a-5968-bfe8-c3f6efb88748","fields":{"slug":"/preparing-for-performance-test/"},"frontmatter":{"title":"톰캣 튜닝을 위한 달록의 서버 성능 테스트 준비 과정"}}},{"node":{"id":"9272061d-68c6-5f82-a961-0e2efe0fd6be","fields":{"slug":"/cyclic-dependency/"},"frontmatter":{"title":"cyclic dependency"}}},{"node":{"id":"6e779308-f266-58af-bfcc-e9fee6d39a98","fields":{"slug":"/multi-datasource-issue-with-osiv/"},"frontmatter":{"title":"대체 왜 DataSource 라우팅이 안되는거야!? (feat. OSIV)"}}},{"node":{"id":"c7bea043-345c-5f78-ae53-796a83812961","fields":{"slug":"/react-query-useMutation-trouble-shooting/"},"frontmatter":{"title":"react-query useMutation onSuccess 안 되는줄 알았던 트러블 슈팅"}}},{"node":{"id":"cf403487-1c48-5ca7-b5c2-ef0d8fefe3c4","fields":{"slug":"/jenkins-distributed-build-architecture/"},"frontmatter":{"title":"젠킨스 분산 빌드 아키텍처 구축"}}},{"node":{"id":"24c152c7-4e94-5b84-aaea-a5a9a8357693","fields":{"slug":"/zero-downtime-deployment/"},"frontmatter":{"title":"달록 무중단 배포 도입기"}}},{"node":{"id":"623f9105-974d-51b9-84c7-f6298a8d1c19","fields":{"slug":"/get-valid-accessToken/"},"frontmatter":{"title":"refreshToken으로 accessToken 재발급하기"}}},{"node":{"id":"d34299f0-eb49-5aef-a38f-963200d5fd6d","fields":{"slug":"/test-readability/"},"frontmatter":{"title":"어떻게 테스트 코드 가독성을 개선할 수 있을까??"}}},{"node":{"id":"fe27c1ec-d040-5cf4-934a-a5eeb2131dfb","fields":{"slug":"/troubleshooting-of-category-role-concurrency-issue/"},"frontmatter":{"title":"JPA의 낙관적 락을 사용한 동시성 이슈 해결"}}}]},"previous":{"fields":{"slug":"/jenkins-distributed-build-architecture/"},"frontmatter":{"title":"젠킨스 분산 빌드 아키텍처 구축"}},"next":{"fields":{"slug":"/get-valid-accessToken/"},"frontmatter":{"title":"refreshToken으로 accessToken 재발급하기"}}},"pageContext":{"id":"24c152c7-4e94-5b84-aaea-a5a9a8357693","series":null,"previousPostId":"cf403487-1c48-5ca7-b5c2-ef0d8fefe3c4","nextPostId":"623f9105-974d-51b9-84c7-f6298a8d1c19"}},"staticQueryHashes":[]}