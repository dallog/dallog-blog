{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"이 글은 우테코 달록팀 크루 '후디'가 작성했습니다. 배경 우테코 레벨3 달록 팀에서 메소드의 파라미터에는 반드시  키워드를 붙이도록 컨벤션을 정했습니다. 이유는 무엇일까요? 일반적으로 가변적인 변수는 프로그램의 흐름을 예측하기 어렵게 만든다. 따라서 변수를 가변적으로 만드는 것이 중요한데, 자바에서는 변수의 재할당을 막기 위해  키워드를 사용합니다. 물…","fields":{"slug":"/intellij-final-keyword/"},"frontmatter":{"date":"July 12, 2022","title":"IntelliJ에서 메소드 추출한 메소드의 파라미터에 final 키워드 자동 추가하기","tags":["intellij"]},"rawMarkdownBody":"\n> 이 글은 우테코 달록팀 크루 '[후디](https://github.com/devHudi)'가 작성했습니다.\n\n## 배경\n\n우테코 레벨3 달록 팀에서 메소드의 파라미터에는 반드시 `final` 키워드를 붙이도록 컨벤션을 정했습니다. 이유는 무엇일까요? 일반적으로 가변적인 변수는 프로그램의 흐름을 예측하기 어렵게 만든다. 따라서 변수를 가변적으로 만드는 것이 중요한데, 자바에서는 변수의 재할당을 막기 위해 `final` 키워드를 사용합니다. 물론 `final` 키워드 하나만으로 완전한 불변을 보장하도록 만들수는 없지만, 어느정도 예측 가능한 코드를 만드는데에는 도움이 됩니다.\n\n이는 메소드의 파라미터에도 적용됩니다. 아래의 코드는 `Memo` 객체를 생성하기 위한 생성자입니다. `value` 라는 String 값을 전달받아 객체 필드에 할당합니다.\n\n```java\npublic Memo(String value) {\n    validateLength(value);\n\n    value = \"hello\"; // 예상치 못한 코드\n\n    this.value = value;\n}\n```\n\n하지만 위처럼 예상치 못한 코드가 추가되면 어떻게 될까요? `value` 필드에는 개발자가 의도하지 못한 값이 할당될 것 입니다.\n\n```java\npublic Memo(final String value) {\n    validateLength(value);\n\n    value = 1; // error: final parameter value may not be assigned\n\n    this.value = value;\n}\n```\n\n이를 보완하기 위해서 위처럼 메소드 파라미터에 `final` 키워드를 붙이면, 재할당 시 컴파일 에러가 발생하여 예상치 못한 동작을 사전에 방지할 수 있을 것 입니다.\n\n## IntelliJ 설정하기\n\n하지만, 저희는 아직 메소드 파라미터에 `final` 키워드를 붙이는 습관이 들어있지 않았습니다. 따라서 IDE의 도움이 필요한데요, 다행히도 IntelliJ에서 메소드 추출 리팩토링을 할 때 생성되는 메소드 파라미터에 자동으로 `final` 키워드를 붙여주는 옵션을 발견하였습니다.\n\n![IntelliJ 설정 화면](./intellij.png)\n\n맥 기준으로 Preferences → Editor → Code Style → Java 페이지에서 Code Generation 탭을 클릭합니다. 해당 탭의 하단에 ‘Final Modifier’ 에서 ‘Make generated parameters final’ 을 체크해줍니다. 위와 같이 옵션을 변경하면 메소드 추출 시 파라미터에 자동으로 `final` 키워드가 생성되는 모습을 확인할 수 있습니다 😊\n"},{"excerpt":"이 글은 우테코 달록팀 크루 '리버'가 작성했습니다. JPA 등장배경 1990년대 인터넷이 보급되면서 온라인 비지니스가 활성화 되었다.\n자연스럽게, 온라인 비지니스에서 DB에 데이터를 저장하고 가져올때 사용할 Connection Connector에 대한 니즈가 높아졌다.\n그래서 각 언어들에서 DB Connection을 지원하는 API 기술들이 등장하였다.…","fields":{"slug":"/appearance-background-of-jpa/"},"frontmatter":{"date":"July 07, 2022","title":"JPA 등장배경","tags":["JPA"]},"rawMarkdownBody":"\n> 이 글은 우테코 달록팀 크루 '[리버](https://github.com/gudonghee2000)'가 작성했습니다.\n\n## JPA 등장배경\n\n1990년대 인터넷이 보급되면서 온라인 비지니스가 활성화 되었다.\n자연스럽게, 온라인 비지니스에서 DB에 데이터를 저장하고 가져올때 사용할 Connection Connector에 대한 니즈가 높아졌다.\n그래서 각 언어들에서 DB Connection을 지원하는 API 기술들이 등장하였다. 이후에 Spring에서는 DB Connection을 좀 더 쉽게 관리하는 Spring JDBC API를 만들고 지원하였다. (이외에도 Query문을 XML파일을 통해 관리하게끔 도와주는 Mybatis도 등장하였음)\n하지만, 여전히 쿼리문을 개발자가 직접 작성해야하는 등 다양한 문제를 가지고 있었다.\n그래서 JAVA 진영에서는 개발자가 쿼리문을 직접 작성하지 않아도 프레임워크 내부에서 지원해주는 ORM(Object Relational Model)기술인 JPA가 등장하였다.\n그렇다면, JPA 이전에 개발자들이 직접 쿼리문을 작성하던 SQL 중심적인 개발의 단점은 무엇이 있을까?\n아래에서 살펴보자.\n\n## SQL 중심적인 개발의 단점\n\n#### 1. 쿼리문 무한 반복과 지루한 코딩\n\nJDBC API는 쿼리문을 개발자들이 직접 작성 해야한다.\n그래서 개발자들은 쿼리문을 작성하는 지루한 작업을 개발 과정에서 무한반복해야한다.\n\n#### 2. 객체의 필드가 추가되면 모든 쿼리문을 수정해야한다.\n\n![](https://velog.velcdn.com/images/gudonghee2000/post/488a7899-d55b-4447-aafc-bada8d840192/image.jpg)\n위 그림과 같이 SQL 중심적인 개발에서는 객체의 필드가 변경되면 해당하는 모든 쿼리문을 찾아 개발자가 수정해야한다.\n\n#### 3. 객체와 관계형 DB의 패러다임의 불일치\n\n객체라고 하면 떠오르는 키워드는 무엇이 있을까?\n캡슐화, 협력, 의존, 상속, 참조 등의 기술이 있다. 그런데, DB에서는 이러한 기술들이 없다.\n적용되는 기술들의 패러다임 불일치로 인해 개발자들은 SQL 지향적인 개발을 할 수 밖에 없다.\n아래에서 자세히 살펴보자.\n\n## 객체와 관계형 DB의 패러다임 차이\n\n객체와 관계형 DB는 연관관계를 통해 작업을 수행한다는 공통점을 가진다.\n하지만 연관관계를 맺는 패러다임의 차이를 가진다.\n\n객체는 상속, 참조를 통해 연관관계를 맺는다.\n반면 관계형 DB는 PK, FK를 통해 연관관계를 맺는다.\n이때, 연관관계를 맺는 방식의 차이로 발생하는 문제점을 코드와 함께 살펴보자.\n\n```java\npublic class Crew {\n   private Long id;\n    private String name;\n    private String nickName;\n    private Team team;\n}\n\npublic class Team {\n   private Long id;\n    private String team_name;\n}\n```\n\n위와 같이 `Crew` 객체가 `Team` 객체를 필드로 가지고 참조한다고 하자.\n객체지향적인 관점에서, `Crew`와 `Team`의 관계를 위와 같이 표현하는것은 자연스럽다.\n\n하지만, DB에서는 `Crew`가 `Team`을 참조한다는 개념이 없다.\n그래서 위 객체들을 가지고 DB의 `Crew`테이블과 `Team`테이블의 관계를 맺을때, 아래와 같이 `PK` 값인 id를 `FK`로 가지도록 구현 하여야한다.\n![ERD](./erd.png)\n\n연관관계에 대해서 객체의 구조와 DB의 구조가 달라진다는 것이다.\n\n그렇다면 객체지향적인 연관관계를 가진 객체들을 DB에 저장 할 때,\nDB의 연관관계로 변경하는 것이 왜 문제가 될까?\n\n## 객체와 RDB의 연관관계 차이가 가져오는 문제\n\n위에서 봤던 `Crew`와 `Team`의 객체 모델링을 다시한번 살펴보자.\n\n```java\npublic class Crew {\n   private Long id;\n    private String name;\n    private String nickName;\n    private Team team;\n}\n\npublic class Team {\n   private Long id;\n    private String team_name;\n}\n```\n\n위와 같이 모델링된 `Crew`와 `Team`을 DB에 저장한다고 한다면 다음의 과정이 필요하다.\nDB에 접근하고자 하는 Dao 객체는 `Crew`객체를 분해하고 각자 `Crew` 테이블과 `Team` 테이블에 대한 쿼리를 작성해야한다. 단순히 `Crew`의 객체정보를 저장하는데 3가지 과정을 거쳐야한다.\n\n이러한 복잡한 과정을 피하는 방법은 없을까?\n아래 코드를 살펴보자.\n\n```java\npublic class Crew {\n   private Long id;\n    private String name;\n    private String nickName;\n    private Long team_id;\n}\n\npublic class Team {\n   private Long id;\n    private String team_name;\n}\n```\n\n위와 같이 DB 테이블 구조에 맞추어 `Crew`와 `Team` 객체를 설계하는 방법이있다.\n이러한 객체 모델링은 Dao 객체를 통해 데이터를 DB에 저장 할 때, `Crew` 객체를 분해하는 과정을 삭제 할 수 있다.\n객체가 DB 구조에 맞추어 설계되어 있기 때문이다.\n\n**하지만, 객체 모델링을 할 때 객체가 서로 참조하는 객체지향적인 개발이 아닌\nDB 테이블구조에 맞추어 개발하는 SQL 중심적인 개발을 하게 된다는 문제를 가진다.**\n\n객체와 관계형 DB의 연관관계의 패러다임 차이는 객체를 객체답지 못하게 만든다는 것이다.\n그렇다면, 패러다임의 차이를 해결하는 방법은 없을까?\n\n## JPA\n\n객체와 관계형 DB의 패러다임의 차이로 인해 우리는 객체지향적인 프로그래밍을 하지못하고 DB에 종속적인 개발을 하게된다.\n이러한 문제를 해결하기 위해 JAVA진영에서는 JPA를 제공한다.\n\nJPA를 통해 개발자는 더이상 쿼리문을 반복적으로 작성하거나 유지보수하는 것을 신경쓰지 않아도 된다.\n왜냐하면 JPA가 쿼리문을 작성해주기 때문이다.\n그리고 SQL 중심적인 개발에서 벗어나 객체지향적인 개발을 할 수 있게 된다.\n왜냐하면 패러다임의 불일치를 JPA가 내부적으로 맵핑해주기 때문이다.\n\n다음 포스팅에서는 JPA의 작동 메커니즘을 자세히 살펴보자.\n"}]}},"pageContext":{}},"staticQueryHashes":[]}