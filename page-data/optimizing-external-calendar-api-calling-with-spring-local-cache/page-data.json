{"componentChunkName":"component---src-templates-post-jsx","path":"/optimizing-external-calendar-api-calling-with-spring-local-cache/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"42182b6e-f280-51b7-b3d2-abe2fb39e666","excerpt":"이 글은 우테코 달록팀 크루 후디가 작성했습니다. 구글 캘린더 연동 기능의 성능 저하  저희 달록은 유저의 구글 캘린더를 가져와 달록의 일정과 함께 볼 수 있는 기능을 제공합니다. 그리고 유저가 일정을 요청하면, 달록 서버가 직접 구글 캘린더의 API를 호출하여 달록 일정과 구글 캘린더 일정을 함께 응답하는 구죠이죠. 편리한 기능이지만, 말만 들어도 성능…","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 <a href=\"https://github.com/devHudi\">후디</a>가 작성했습니다.</p>\n</blockquote>\n<h2>구글 캘린더 연동 기능의 성능 저하</h2>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/a6b15b3210fa492aab8df5cc6a6f8de9/98c82/1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 74.11764705882352%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACBklEQVQ4y5WU227aQBCGeSoaYSQEGG4RFw28QHPRvACI03P0SYJJqVQphWJEFbWqKvWgVqGBkKRJsTGJj393xjaYghJlpJ9dm51v598diMmyDFI6ncbh4Us0m01UKhVUq1U06nU0Gg1WPZjTSKrVami1WnhxcMC5ISdGH7lcDpIkYTQa4anR7XaRSCSYIctZxLLZ7Ao4HA5hOw5671W866t4e9LD12/f8eH0Iz9/+vwFtm3D8zweKRRF4VwfGKkwmUxiMBjwor/zOUvTdDhiA0q2LIvnBCPRnKLdbiMej7PtVCq1CVRVlRfNLq9w/eeGgZ549jzfHoFckruusNPprCyT201gUGFoi2K5vMNkesGbmKbF8KhlAm5YDs8wajmEhcGVuS5XF1reBeQKo5cSWp5rGnRdx8IwYAiFyb53X+EZbgGjbaOKW6Y4+/UDk/MzTM/HYhxD124FQxyDYwYSF2Qtd1ten6GEQVDh1fgnrmdTzC4muBQy9LkAOgzyXJINx1wEwGMBTDzcNpQAuGsRjN6J0ZfH3/hAZfelSNIaGO03X34yXYxpu6I6Hfe/e+KNCaXz+oG2CSxT4q6gjTTjHtZihsXpK1HpLZTjN9jbe4Z8Pr8N7Pf7nEi/Cm6T/+Q4LkMd0dhWUHX76Gj7UkhELxaLKJfLKJVKj2v/Oa8tFArIZDKrf5t/uASSwi0/MQUAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='1' title='1' src='/static/a6b15b3210fa492aab8df5cc6a6f8de9/ca1dc/1.png' srcset='/static/a6b15b3210fa492aab8df5cc6a6f8de9/e7570/1.png 170w,\n/static/a6b15b3210fa492aab8df5cc6a6f8de9/f46e7/1.png 340w,\n/static/a6b15b3210fa492aab8df5cc6a6f8de9/ca1dc/1.png 680w,\n/static/a6b15b3210fa492aab8df5cc6a6f8de9/02d09/1.png 1020w,\n/static/a6b15b3210fa492aab8df5cc6a6f8de9/9d567/1.png 1360w,\n/static/a6b15b3210fa492aab8df5cc6a6f8de9/98c82/1.png 1456w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>저희 달록은 유저의 구글 캘린더를 가져와 달록의 일정과 함께 볼 수 있는 기능을 제공합니다. 그리고 유저가 일정을 요청하면, 달록 서버가 직접 구글 캘린더의 API를 호출하여 달록 일정과 구글 캘린더 일정을 함께 응답하는 구죠이죠.</p>\n<p>편리한 기능이지만, 말만 들어도 성능상의 이슈가 발생할 것 같습니다. 로컬에서 테스트한 결과 구글 캘린더에 한번 API 요청을 보내고, 응답을 받기까지 대략 <strong>700ms 정도의 시간이 소요</strong>됩니다. 그런데 달록에서는 하나가 아닌 <strong>여러개의 구글 캘린더</strong>를 연동할 수 있습니다. 3개의 구글 캘린더를 연동했다면, 일정을 불러오는데만 2000ms 이상이 걸리는 것이죠. <strong>사용자 경험 측면에서 굉장히 좋지 않은 상황</strong>입니다.</p>\n<p>이런 문제를 해결하기 위해 프론트엔드에서는 React Query를 사용하여 백엔드 서버의 응답을 캐싱해두고 있습니다. 어느정도의 성능 저하는 해소되었지만, 문제는 <strong>재방문 시점</strong>입니다. 새로고침을 하면 React Query의 캐시가 비워지고, 다시 백엔드 서버로 요청을 하게 됩니다. 그러면 백엔드 서버도 구글 캘린더 서버로 요청을 보내게 되겠죠. 프론트엔드에서의 캐싱은 완벽한 해결책은 아닙니다.</p>\n<p>그렇다면 서버에서 캐싱하는 것은 어떨까요? 구글 캘린더 API 요청에 대한 응답을 서버가 일정 시간 동안 보관하면서, 클라이언트에는 <strong>캐싱된 구글 캘린더 데이터를 보내준다면 성능이 많이 개선</strong>되겠죠? 이를 위해 달록은 <strong>스프링 캐시 추상화</strong>를 이용했습니다.</p>\n<h2>스프링 캐시 추상화와 ConcurrentMapCache의 문제점</h2>\n<p>스프링은 빈 메소드에 캐시 서비스를 적용할 수 있는 기능을 어노테이션과 AOP를 통해 제공합니다. AOP를 사용하기 때문에 내부 구현에 영향을 주지 않고, 특정 캐시 기술에 종속되지 않도록 구현할 수 있습니다.</p>\n<p>스프링에서 기본으로 사용되는 캐시는 <code class=\"language-text\">ConcurrentMapCache</code> 입니다. 자바의 <code class=\"language-text\">ConcurrentHashMap</code> 을 사용한 간단한 캐시 구현체이죠. 덕분에 별도의 설정 없이 간단히 세팅할 수 있습니다. 다만 캐시 용량 제한, 다양한 저장방식, 다중 서버 분산과 같은 고급 설정을 할 수 없습니다. 특히 캐시 데이터에 대해 <strong>TTL(time-to-live)</strong>를 설정할수도 없습니다. 캐시된 데이터의 만료 기한을 설정할 수 없고, 한번 캐시된 데이터를 지우려면 스케줄링을 돌려서 일괄 삭제해야합니다.</p>\n<p>모든 유저에게 동일하게 보이는 데이터에 대해서는 이렇게 일정 주기로 전체 캐시를 지우는 만료 정책을 설정해도 괜찮습니다. 그런데 저희가 캐시하려고 하는 데이터는 각 유저별 고유한 데이터입니다. 일정 주기로 일괄삭제할 수 없어요. 따라서 캐시가 개별적인 만료 기한을 가져야합니다.</p>\n<p>이런 기능을 하려면 <code class=\"language-text\">EhCache</code> 나 <code class=\"language-text\">CaffeinCache</code> 같은 서드파티 로컬 캐시 구현체를 사용하거나 <code class=\"language-text\">Redis</code> 같은 캐시를 별도로 사용해야합니다. 그런데, 겨우 TTL 기능 하나 때문에 라이브러리를 사용하고 싶지는 않았습니다.</p>\n<h2>ExpiringConcurrentMapCache 구현</h2>\n<p>이런 문제를 해결하기 위해 <code class=\"language-text\">ConcurrentMapCache</code> 를 상속받은 <code class=\"language-text\">ExpiringConcurrentMapCache</code> 라는 구현체를 직접 만들었습니다. <code class=\"language-text\">ExpiringConcurrentMapCache</code> 는 데이터가 캐시에 등록되면 캐시 키와 <code class=\"language-text\">LocalDateTime.now()</code> 쌍을 별도의 해시맵에 저장합니다. 그리고 해당 캐시 데이터가 조회될 때 마다 저장된 LocalDateTime과 현재 시각을 비교하여 만료 여부를 판단합니다. 코드를 한번 살펴볼까요?</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ExpiringConcurrentMapCache</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ConcurrentMapCache</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">LocalDateTime</span><span class=\"token punctuation\">></span></span> expires <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> expireAfter<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ExpiringConcurrentMapCache</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> expireAfter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>expireAfter <span class=\"token operator\">=</span> expireAfter<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">lookup</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">Object</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">LocalDateTime</span> expiredDate <span class=\"token operator\">=</span> expires<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNull</span><span class=\"token punctuation\">(</span>expiredDate<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token class-name\">LocalDateTime</span><span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">isBefore</span><span class=\"token punctuation\">(</span>expiredDate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">lookup</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        expires<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">evict</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">Object</span> key<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Object</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">LocalDateTime</span> expiredAt <span class=\"token operator\">=</span> <span class=\"token class-name\">LocalDateTime</span><span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">plusSeconds</span><span class=\"token punctuation\">(</span>expireAfter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        expires<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> expiredAt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>사실 이야기에 비해 굉장히 간단합니다. 필드로 캐시 키와 만료 시점을 관리하는 <code class=\"language-text\">expires</code> 라는 <code class=\"language-text\">HashMap</code> 을 가지고 있습니다. 그리고 캐시 데이터의 만료 기한을 초 단위로 <code class=\"language-text\">expireAfter</code> 라는 변수로 관리합니다.</p>\n<p><code class=\"language-text\">put()</code> 은 캐시에 데이터를 저장하는 시점에 <code class=\"language-text\">expires</code> 에 캐시 키와 만료 시점을 저장합니다. 만료 시점은 현재 시간 + <code class=\"language-text\">expireAfter</code> 입니다.</p>\n<p><code class=\"language-text\">lookup()</code> 은 캐시 키로 캐시된 데이터를 조회할 때 사용합니다. <strong>캐시 히트(cache hit)라면 캐시된 데이터를, 캐시 미스(cache miss)라면 <code class=\"language-text\">null</code> 을 반환</strong>합니다. 이 메소드를 오버라이드하여 요청한 데이터가 만료되었다면 <code class=\"language-text\">null</code> 을 반환하고 해당 데이터의 캐시 키를 <code class=\"language-text\">expires</code> 에서 제거합니다.</p>\n<p>이렇게 간단히 만료되는 <code class=\"language-text\">ConcurrentMapCache</code> 를 사용할 수 있었습니다.</p>\n<h2>캐시 만료 정책</h2>\n<p>캐시 만료 정책에 대해 고민끝에 일단 달록은 <strong>15분으로 설정</strong>하였습니다. 구글 캘린더는 저희가 통제하고 있는 데이터베이스와 같은 리소스가 아닙니다. 따라서 실제 구글 캘린더 일정이 변경되었는지, 변경되지 않았는지는 실제 요청을 하지 않는 이상 알 수가 없습니다 (만약 캘린더가 Webhook을 지원하면 가능할수도 있죠).</p>\n<p>따라서 만료 기한을 너무 길게 잡아두면 유저가 최신 구글 캘린더 정보를 볼 수 없습니다. 그렇다고 너무 짧게 만료 기한을 잡아버리면 너무 자주 캐시 미스가 발생해서 성능이 저하될 수 있습니다. 적절한 만료 기한이 필요했습니다.</p>\n<p>15분으로 설정한 이유는 다음과 같습니다. 우선 달력 도메인 특성상 <strong>유저가 매우 오래 머물며 활동하지 않습니다</strong>. 일정을 확인하거나 등록하기 위해 잠깐 방문하는 것이 대부분입니다. 다만 일정을 확인하기 위해 <strong>접속 빈도는 높겠죠</strong>. 이때, 한번 접속하고 일정을 확인하고 관리하고 이탈하는데 시간을 15분가량으로 어림잡았습니다. 정확한 분석은 나중에 GA, Hotjar 같은 유저 행동 분석 도구를 사용하면 좋을 것 같습니다.</p>\n<h2>성능 개선</h2>\n<p>성능 개선 정도를 확인하기 위해 Jmeter를 사용하여 실제 API의 평균 응답 시간을 분석했습니다. 실제 구글 캘린더 API를 호출해야 의미가 있으므로 요청과 요청간 간격은 1초정도로 설정해서 서드 파티 쪽에 부하가 없게끔 설정했습니다. 1초 간격으로 100번의 요청을 보내 평균 응답 시간을 냈습니다.</p>\n<p>성능 테스트는 구글 캘린더 1개를 연동해 둔 상태로 진행했습니다.</p>\n<h3>캐시 적용 전</h3>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/bd42966a665f0a233fdb6a2ef97989d5/994d6/2.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 7.647058823529412%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAW0lEQVQI1z1OWw6AMAza7eZe3cOp9z8JQhP9IAVKSUNqHZlY1wNbG8UG5LWxMPaNTO2gZ/N0XvpEqua6kv831OHgQpChqZKPCwpVlsfSXKtQGdfMRXqTz8jX/gUPW0xj5ViAjAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='2' title='2' src='/static/bd42966a665f0a233fdb6a2ef97989d5/ca1dc/2.png' srcset='/static/bd42966a665f0a233fdb6a2ef97989d5/e7570/2.png 170w,\n/static/bd42966a665f0a233fdb6a2ef97989d5/f46e7/2.png 340w,\n/static/bd42966a665f0a233fdb6a2ef97989d5/ca1dc/2.png 680w,\n/static/bd42966a665f0a233fdb6a2ef97989d5/02d09/2.png 1020w,\n/static/bd42966a665f0a233fdb6a2ef97989d5/994d6/2.png 1093w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>캐시를 적용하지 않은 상태에서는 <code class=\"language-text\">734ms</code> 의 응답 시간을 보였습니다. 꽤나 느립니다. 구글 캘린더가 1개만 연동되어 있는 상황이므로 2개 연동하면 약 2배, 3개 연동하면 약 3배로 늘어날 것입니다. 사용자 경험이 굉장히 안좋을 겁니다.</p>\n<h3>캐시 적용 후</h3>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/d0f204538d9f27f121f0ea2a7cb0dd35/0c7a1/3.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 7.647058823529412%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAWUlEQVQI102M2Q2AMAxDOx3QpvcB+09i4pZKfFjyi2MbFxKoOh6k2uFTmRxLQ+k3RFliXjfNnXr+WGX+M/+zuXzEuSVhlhjSUz5XiOr42M7htnLtsM/O3nkBFDRMR+d/jvgAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='3' title='3' src='/static/d0f204538d9f27f121f0ea2a7cb0dd35/ca1dc/3.png' srcset='/static/d0f204538d9f27f121f0ea2a7cb0dd35/e7570/3.png 170w,\n/static/d0f204538d9f27f121f0ea2a7cb0dd35/f46e7/3.png 340w,\n/static/d0f204538d9f27f121f0ea2a7cb0dd35/ca1dc/3.png 680w,\n/static/d0f204538d9f27f121f0ea2a7cb0dd35/02d09/3.png 1020w,\n/static/d0f204538d9f27f121f0ea2a7cb0dd35/0c7a1/3.png 1090w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>최초에 캐시 미스가 발생해서 실제 API를 호출하는 요청에 대한 응답 시간은 제외하고, 캐시된 이후의 평균 응답시간만 측정했습니다. <code class=\"language-text\">156ms</code> 정도가 나오네요. 캘린더 1개 연동 기준 <strong>약 4.7배 성능이 개선</strong>되었습니다.</p>\n<h2>마치며</h2>\n<p>외부 API 요청에 대한 캐싱은 성능 개선 말고도 다른 이점이 존재합니다. 현재 상황은 아니지만, 만약에 외부 API 서비스가 호출 건당 요금을 지불해야하는 유료 서비스라면, 캐싱은 이때 발생하는 비용을 많이 절약할 수 있게 해줍니다.</p>\n<p>다만 지금의 캐싱 구조가 완벽한 구조는 아닙니다. 지금 달록의 서버는 스케일 아웃하지 않아 단일 서버입니다. 만약 서버를 다중화 하고, 그대로 로컬 캐시를 사용한다면 서버간 데이터의 불일치가 발생합니다. 따라서 만약 스케일 아웃해야하는 상황이 온다면 <strong>Redis나 Memcached 같은 도구를 사용하여 별도의 캐시 서버를 성하여 다중 환경에 대응</strong>해야할 것입니다.</p>","frontmatter":{"title":"스프링 로컬 캐시를 사용한 외부 캘린더 API 호출 최적화","date":"November 10, 2022","update":null,"tags":["캐시","성능개선"],"series":null},"fields":{"slug":"/optimizing-external-calendar-api-calling-with-spring-local-cache/","readingTime":{"minutes":11.935}}},"seriesList":{"edges":[{"node":{"id":"a621dc7b-8590-5ec6-9b52-3d9e5182486d","fields":{"slug":"/appearance-background-of-jpa/"},"frontmatter":{"title":"JPA 등장배경"}}},{"node":{"id":"9d2a87b6-2b9c-5b87-b790-3426d17c2d8e","fields":{"slug":"/intellij-final-keyword/"},"frontmatter":{"title":"IntelliJ에서 메소드 추출한 메소드의 파라미터에 final 키워드 자동 추가하기"}}},{"node":{"id":"251e9767-1c92-5cf5-9cef-2c4a42c10df2","fields":{"slug":"/git-branch-strategy/"},"frontmatter":{"title":"달록팀의 git 브랜치 전략을 소개합니다."}}},{"node":{"id":"5090cce3-0c1f-5376-badc-1d25e44c1bd9","fields":{"slug":"/infinite-scroll/"},"frontmatter":{"title":"React에서 무한 스크롤 구현하기"}}},{"node":{"id":"bcb53ba5-0286-5d10-96c2-fdcb88e2cc60","fields":{"slug":"/package-structure/"},"frontmatter":{"title":"달록에 적절한 패키지 구조 고민하기"}}},{"node":{"id":"a7fc89de-f37c-596e-a81d-3d4fe5a795b8","fields":{"slug":"/data-jpa-slice-page/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"e1ba92ee-0cf0-50c8-80bd-5da5075df8d1","fields":{"slug":"/data-jpa-auditing/"},"frontmatter":{"title":"Spring Data JPA의 Auditing"}}},{"node":{"id":"3e036508-c916-504e-9e8d-89f69332471e","fields":{"slug":"/separated-interface/"},"frontmatter":{"title":"외부와 의존성 분리하기"}}},{"node":{"id":"cade544a-16ef-58a3-b97c-824986a8395f","fields":{"slug":"/apply-rest-docs/"},"frontmatter":{"title":"MockMvc를 사용한 Spring RestDocs"}}},{"node":{"id":"87649d54-d59e-58a6-afd5-8491eb4113a8","fields":{"slug":"/properties-to-object/"},"frontmatter":{"title":"properties 객체로 다루기"}}},{"node":{"id":"eb380f6d-5a00-5a9e-a916-003fb292cc8a","fields":{"slug":"/test-fixture-constant/"},"frontmatter":{"title":"테스트에서 Entity 객체를 상수로 두면 안 되는 이유"}}},{"node":{"id":"9734e30a-b430-5922-919d-f53808a56eb9","fields":{"slug":"/what_is_nginx/"},"frontmatter":{"title":"NGINX 란?"}}},{"node":{"id":"9ebc6e21-2a76-5d42-be33-c2dae8c849b2","fields":{"slug":"/ssl_protocol/"},"frontmatter":{"title":"SSL을 통한 HTTPS통신 과정"}}},{"node":{"id":"fa5ad595-1f81-5a20-a884-2da69adee3c5","fields":{"slug":"/integration-test-slice-test/"},"frontmatter":{"title":"통합 테스트와 슬라이스 테스트"}}},{"node":{"id":"d8c66823-bb05-5e83-a6a1-2fd9af450b6f","fields":{"slug":"/query-invalidation/"},"frontmatter":{"title":"React-Query에서의 데이터 최신화 (Query Invalidation)"}}},{"node":{"id":"f5187517-342f-52a1-9092-d12c1a80d132","fields":{"slug":"/seperate-components/"},"frontmatter":{"title":"컴포넌트 분리 기준"}}},{"node":{"id":"d6249c8b-bea6-5c91-8477-d3dd15ad9b39","fields":{"slug":"/test-isolation/"},"frontmatter":{"title":"테스트 격리"}}},{"node":{"id":"98e390ef-fb19-5d01-a3ef-d14bc0e65176","fields":{"slug":"/dallog-jacoco/"},"frontmatter":{"title":"달록의 Jacoco 적용기 (feat. Gradle)"}}},{"node":{"id":"ab7073d6-575f-55b8-8b1d-fec1ea27916f","fields":{"slug":"/cannot-scroll-to-top-of-flex-element/"},"frontmatter":{"title":"스크롤을 했더니 윗부분이 안 보여요!"}}},{"node":{"id":"33d19946-de0c-5b41-bfa0-d7c3fd80f10b","fields":{"slug":"/google-refresh-token/"},"frontmatter":{"title":"Google은 Refresh Token을 쉽게 내주지 않는다."}}},{"node":{"id":"8168857d-a82c-5608-bd40-cea4b917d17d","fields":{"slug":"/submodule/"},"frontmatter":{"title":"달록 서브모듈 도입기"}}},{"node":{"id":"836fc724-7e2f-5c7a-a42b-c0cc9163167a","fields":{"slug":"/dallog-flyway/"},"frontmatter":{"title":"달록의 데이터베이스 마이그레이션을 위한 Flyway 적용기"}}},{"node":{"id":"7a3bde6d-746b-56fd-8d91-0d8059ebf1f8","fields":{"slug":"/json-property-json-naming/"},"frontmatter":{"title":"@JsonProperty, @JsonNaming"}}},{"node":{"id":"50673f5c-f835-5982-b70c-b77e5a352a2c","fields":{"slug":"/servlet-life-cycle/"},"frontmatter":{"title":"서블릿 생명주기와 직접만든 톰캣을 통한 의문점"}}},{"node":{"id":"61e7f4d1-7b3a-5968-bfe8-c3f6efb88748","fields":{"slug":"/preparing-for-performance-test/"},"frontmatter":{"title":"톰캣 튜닝을 위한 달록의 서버 성능 테스트 준비 과정"}}},{"node":{"id":"9272061d-68c6-5f82-a961-0e2efe0fd6be","fields":{"slug":"/cyclic-dependency/"},"frontmatter":{"title":"cyclic dependency"}}},{"node":{"id":"6e779308-f266-58af-bfcc-e9fee6d39a98","fields":{"slug":"/multi-datasource-issue-with-osiv/"},"frontmatter":{"title":"대체 왜 DataSource 라우팅이 안되는거야!? (feat. OSIV)"}}},{"node":{"id":"c7bea043-345c-5f78-ae53-796a83812961","fields":{"slug":"/react-query-useMutation-trouble-shooting/"},"frontmatter":{"title":"react-query useMutation onSuccess 안 되는줄 알았던 트러블 슈팅"}}},{"node":{"id":"cf403487-1c48-5ca7-b5c2-ef0d8fefe3c4","fields":{"slug":"/jenkins-distributed-build-architecture/"},"frontmatter":{"title":"젠킨스 분산 빌드 아키텍처 구축"}}},{"node":{"id":"24c152c7-4e94-5b84-aaea-a5a9a8357693","fields":{"slug":"/zero-downtime-deployment/"},"frontmatter":{"title":"달록 무중단 배포 도입기"}}},{"node":{"id":"623f9105-974d-51b9-84c7-f6298a8d1c19","fields":{"slug":"/get-valid-accessToken/"},"frontmatter":{"title":"refreshToken으로 accessToken 재발급하기"}}},{"node":{"id":"d34299f0-eb49-5aef-a38f-963200d5fd6d","fields":{"slug":"/test-readability/"},"frontmatter":{"title":"어떻게 테스트 코드 가독성을 개선할 수 있을까??"}}},{"node":{"id":"fe27c1ec-d040-5cf4-934a-a5eeb2131dfb","fields":{"slug":"/troubleshooting-of-category-role-concurrency-issue/"},"frontmatter":{"title":"JPA의 낙관적 락을 사용한 동시성 이슈 해결"}}},{"node":{"id":"9df1e141-0451-5e3c-a777-0efe8817dcf3","fields":{"slug":"/prevent-useless-rerendering/"},"frontmatter":{"title":"컴포넌트의 불필요한 리렌더링 막기: 달력 페이지 리팩토링"}}},{"node":{"id":"42182b6e-f280-51b7-b3d2-abe2fb39e666","fields":{"slug":"/optimizing-external-calendar-api-calling-with-spring-local-cache/"},"frontmatter":{"title":"스프링 로컬 캐시를 사용한 외부 캘린더 API 호출 최적화"}}}]},"previous":{"fields":{"slug":"/prevent-useless-rerendering/"},"frontmatter":{"title":"컴포넌트의 불필요한 리렌더링 막기: 달력 페이지 리팩토링"}},"next":null},"pageContext":{"id":"42182b6e-f280-51b7-b3d2-abe2fb39e666","series":null,"previousPostId":"9df1e141-0451-5e3c-a777-0efe8817dcf3","nextPostId":null}},"staticQueryHashes":[]}