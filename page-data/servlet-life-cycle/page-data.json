{"componentChunkName":"component---src-templates-post-jsx","path":"/servlet-life-cycle/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"50673f5c-f835-5982-b70c-b77e5a352a2c","excerpt":"이 글은 우테코 달록팀 크루 '리버'가 작성했습니다. 글을 쓰게된 계기 우아한 테크코스 레벨4 Tomcat 구현하기 미션을 진행하면서 직접만든 Tomcat과 실제 Tomcat이 다르게 작동하는 부분이 있었다.\nServlet과 ServletContainer, ServletLifeCycle를 알아보고\n왜 다르게 작동하는지에 대한 의문점을 공유하고자 글을 작성…","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 '<a href=\"https://github.com/gudonghee2000\">리버</a>'가 작성했습니다.</p>\n</blockquote>\n<h2>글을 쓰게된 계기</h2>\n<p>우아한 테크코스 레벨4 Tomcat 구현하기 미션을 진행하면서 직접만든 Tomcat과 실제 Tomcat이 다르게 작동하는 부분이 있었다.\nServlet과 ServletContainer, ServletLifeCycle를 알아보고\n왜 다르게 작동하는지에 대한 의문점을 공유하고자 글을 작성해본다.</p>\n<h2>Servlet이란?</h2>\n<p>자바로 HTTP 요청을 처리하는 프로그램을 만들 때 사용하는 인터페이스이다.\nServlet은 자바 표준으로 <code class=\"language-text\">Jakarta EE</code>의 표준 API이다.\nServlet은 클라이언트의 <code class=\"language-text\">Request</code>를 받아서 일련의 작업을 처리하고 <code class=\"language-text\">Response</code>에 작업의 결과물을 담아준다.</p>\n<h2>Servlet Container란?</h2>\n<p>서버에서 만들어진 <code class=\"language-text\">Servlet</code>들을 <strong>관리</strong>하고 <strong>중계</strong>하는 역할을 한다.</p>\n<p>ServletContainer는 클라이언트의 <strong>요청</strong>을 받았을 때, 요청에 대응할 수 있는 Servlet을 인스턴스화 해주고 <strong>요청</strong>에 대한 <strong>응답</strong>을 해준다.</p>\n<h2>ServletContainer의 역할</h2>\n<blockquote>\n<ol>\n<li>웹서버와의 통신 지원\nServletContainer는 <code class=\"language-text\">Servlet</code>과 <code class=\"language-text\">WebServer</code>가 손쉽게 통신 할 수 있게 중계 해준다.\nServletContainer는 <code class=\"language-text\">ServerSoket</code>을 만들고 <code class=\"language-text\">listen()</code>, <code class=\"language-text\">accept()</code> 등의 API로 클라이언트 요청이 오면 적절한 <code class=\"language-text\">Servlet</code>에게 요청을 처리하게끔 한다.</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>Servlet 생명주기 관리\nServletContainer는 <code class=\"language-text\">Servlet</code>을 관리한다.</li>\n</ol>\n</blockquote>\n<ul>\n<li>Servlet 클래스를 로딩하여 인스턴스화</li>\n<li>Servlet 초기화</li>\n<li>요청에 적절한 Servlet 할당</li>\n<li>Servlet 제거</li>\n</ul>\n<p>Servlet 생명주기를 어떻게 관리하는지 좀 더 자세히 살펴보자.</p>\n<h2>Servlet 생명주기를 관리하는 메서드</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ExampleServlet</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">HttpServlet</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> 인코딩 <span class=\"token operator\">=</span> <span class=\"token string\">\"인코딩\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">ServletConfig</span> config<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ServletException</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">service</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">HttpServletResponse</span> response<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">destroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>ServletContainer는 <code class=\"language-text\">Servlet</code>들의 생명주기를 그림과 같이 <code class=\"language-text\">init()</code>, <code class=\"language-text\">service()</code>, <code class=\"language-text\">destroy()</code> 메서드를 통해 관리해준다.\n아래에서 전체적인 과정을 간략하게 살펴보고 <code class=\"language-text\">Servlet 생명주기</code>를 자세히 살펴보자.</p>\n<h2>Servlet 생명주기 과정 알아보기</h2>\n<p>ServletContainer가 <code class=\"language-text\">Servlet</code>을 어떻게 사용하고 관리하는지 그림을 통해 정리해보자.</p>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/1993301b-561f-419d-9082-a5e668e0c13f/image.png\"></p>\n<ol>\n<li>톰캣이 가지고 있는 Connector 중 하나를 통해 <code class=\"language-text\">Request</code>를 전달 받는다.</li>\n<li>톰캣은 <code class=\"language-text\">Request</code>의 <code class=\"language-text\">url</code>을 기반으로 적절한 <code class=\"language-text\">Servlet</code>을 찾아내 매핑한다.</li>\n<li>요청이 적절한 <code class=\"language-text\">Servlet</code>에게 매핑되면 메모리에 해당 <code class=\"language-text\">Servlet</code> 인스턴스가 올라와있는지 확인한다. 만약 존재하지 않으면 <code class=\"language-text\">Servlet</code> 인스턴스를 생성한다.</li>\n<li>톰캣이 <code class=\"language-text\">init()</code> 메서드를 호출하여 <code class=\"language-text\">Servlet</code>을 초기화한다.</li>\n<li><code class=\"language-text\">Servlet</code>이 초기화 되면 톰캣은 <code class=\"language-text\">service()</code> 메서드를 호출하여 <code class=\"language-text\">Request</code>를 처리한다.</li>\n<li>마지막으로 톰캣을 종료하거나 <code class=\"language-text\">Servlet</code>을 수정하게되면 <code class=\"language-text\">destroy()</code> 메서드를 호출하여 메모리에 올라와있던 <code class=\"language-text\">Servlet</code>을 제거한다.</li>\n</ol>\n<h2>Servlet 생명주기 조금 더 자세히 살펴보기</h2>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/02b01768-d52a-4820-b829-9361d1328b4c/image.JPG\"></p>\n<p>Servlet은 처음 호출되어 메모리에 올라가면 해당 인스턴스를 재활용한다.\n<strong>그래서 객체가 생성되는 순간부터 자원이 해제되는 순간까지가 서블릿의 라이프사이클이다.</strong> </p>\n<p>과정을 하나씩 자세히 살펴보자.</p>\n<h4>1. Servlet 객체 생성</h4>\n<p>먼저 Servlet이 최초에 호출되면 톰캣에서 서블릿 파일(.java)을 불러와 컴파일한 후 메모리에 로드시킨다. 톰캣은 서블릿 파일이 변경되지 않는 이상 서버가 종료될 때까지 계속해서 해당 객체를 재활용한다.</p>\n<h4>2. init() 메서드 호출 (객체 생성시 최초 1회만 실행)</h4>\n<p>Servlet에서 기본 상속받는 HttpServlet의 부모 추상 클래스인 GenericServlet에 아래와 같이 정의하고 있는 메서드이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GenericServlet</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Servlet</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ServletConfig</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span>Serializable</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    \n\t<span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ServletConfig</span> config<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ServletException</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>config <span class=\"token operator\">=</span> config<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Servlet 객체 생성시 초기화 작업을 수행하는데, <code class=\"language-text\">ServerConfig</code> 객체를 넣어 실행한다.</p>\n<p><code class=\"language-text\">ServerConfig</code>객체는 아래에서 다시살펴보자.</p>\n<h4>3. service() 메서드 호출</h4>\n<p>클라이언트의 요청에 따라 생성된 <code class=\"language-text\">Request</code>객체를 통해 요청을 처리하고 <code class=\"language-text\">Response</code> 객체에 적절한 응답을 추가해준다.\n이때, 쓰레드풀의 쓰레드 하나를 사용한다.</p>\n<h4>4. destroy() 메서드 호출 (자원 해제시에 1번만 실행)</h4>\n<p>Servlet에 수정사항이 생겨 Servlet을 다시 로드해야하거나 서버가 정상적으로 종료되는 경우에 호출된다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/93a0c18e-4db4-4538-ad85-4b291322b430/image.JPG\">\n실제 톰캣의 Servlet을 호출할 때의 로그이다.\n처음 Servlet이 호출됬을 때만 <code class=\"language-text\">init()</code> 메서드가 호출됨을 알 수 있다.</p>\n<h2>직접 구현한 톰캣과 달랐던 의문점들</h2>\n<p>우아한 테크코스 레벨4 저번미션을 진행하면서 직접 Tomcat을 구현해보았었다.\n직접만든 Tomcat과 달랐던 부분이있어서 이를 공유하고자 한다.</p>\n<h3>1. Servlet 실행시점에 Servlet 객체 생성</h3>\n<p>직접 구현해본 톰캣에서는 다음과 같이 <code class=\"language-text\">Tomcat</code> 실행시점에 <code class=\"language-text\">Servlet</code> 인스턴스를 생성하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Tomcat</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">ControllerContainer</span> container <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ControllerContainer</span><span class=\"token punctuation\">(</span>configuration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> connector <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Connector</span><span class=\"token punctuation\">(</span>container<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      \t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">ControllerContainer</code>가 ServletCotainer이고 <code class=\"language-text\">ControllerContainer</code> 생성자 파라미터의 <code class=\"language-text\">Configuration</code> 객체에 <code class=\"language-text\">Servlet</code>\n인스턴스 생성에 대한 코드가 담겨있다.</p>\n<p>그런데, 실제 톰캣은 클라이언트의 <code class=\"language-text\">Request</code>가 들어오고 매핑할 <code class=\"language-text\">Servlet</code>이 필요해질 때 <code class=\"language-text\">Servlet</code> 인스턴스를 생성한다😮😮</p>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/93a0c18e-4db4-4538-ad85-4b291322b430/image.JPG\"></p>\n<p>실제 테스트 코드에서 <code class=\"language-text\">쉐어드 서블릿</code>이라는 객체에 요청을 보냈을 때 확인해 본 결과이다.</p>\n<p>이런 결과를 보고 </p>\n<p><strong>톰캣을 실행 할 때, Servlet 객체를 모두 생성 해놓으면 클라이언트 요청이 들어올때 더 빨리 응답을 해줄 수 있지않나? 라는 의문이 들었다.</strong></p>\n<p>아마, <code class=\"language-text\">Servlet</code>에 변경사항이 있을 때, 실제 Server를 종료시키지 않고 <code class=\"language-text\">Servlet</code> 변경사항을 적용하기 위해서 클라이언트 <strong>요청</strong>이 들어올 때, <code class=\"language-text\">Servlet</code> 인스턴스를 생성하도록 구현 한게 아닐까 조심스럽게 추측한다🙄 </p>\n<h3>2. Servlet 객체 생성과 init()을 따로하는 이유</h3>\n<p>두번째는 <code class=\"language-text\">Servlet</code>을 생성 하고 <code class=\"language-text\">init()</code> 메서드를 호출한다는 점이다.\n<strong>Servlet을 생성 할 때 초기화도 같이 하면 되는거 아닌가? 왜 과정을 나눠놨지? 라는 의문이 들었다.</strong></p>\n<p>찾아본 자료에서 몇가지 이유를 보았는데 일리가 있다고 생각하는 이유는 다음과 같다.</p>\n<ul>\n<li>\n<p>Interface는 생성자를 가질수 없기 때문이다.\n<code class=\"language-text\">Servlet</code> 초기화를 위해서는 앞에서 이야기한 <code class=\"language-text\">ServletConfig</code> 객체를 <code class=\"language-text\">Servlet</code>에게 전달해주어야 하는데 Interface는 생성자를 가질 수 없다.\n그래서 <code class=\"language-text\">Java EE Servlet API</code> 표준에 <code class=\"language-text\">Servlet</code> 객체를 초기화하기 위해서는 <code class=\"language-text\">ServletConfig</code> 객체가 필요함을 명시해주기 위해서 <code class=\"language-text\">init()</code>메서드를 통해 초기화 하도록 한것이 아닐까 한다.   </p>\n<blockquote>\n<p><strong>💡ServletConfig란?</strong>\n하나의 Servlet 초기화에 필요한 정보를 전달하기 위한 Config 객체를 의미한다.</p>\n</blockquote>\n</li>\n<li>생성자는 복잡한 논리/비즈니스 처리가 없어야 하기때문이다. <code class=\"language-text\">ServletConfig</code>객체를 생성하는 것은 비용이 비싼작업이기 때문에 생성자가 아닌 <code class=\"language-text\">init()</code> 메서드를 통해 처리해야 한다는 의견도 있다.</li>\n</ul>\n<h2>마치면서</h2>\n<p><code class=\"language-text\">Servlet</code>과 <code class=\"language-text\">ServletContainer</code>, <code class=\"language-text\">Servlet</code> 생명주기에 대해서 살표보았다.\n<code class=\"language-text\">Servlet</code> 생명주기에 대해서 같은 의문점이 있었다면 의문을 해소하는데 도움이 되었으면 좋겠다😊</p>\n<h2>참고한 자료</h2>\n<p><a href=\"https://stackoverflow.com/questions/7580771/can-we-replace-the-purpose-of-init-method-to-the-servlet-constructor\">https://stackoverflow.com/questions/7580771/can-we-replace-the-purpose-of-init-method-to-the-servlet-constructor</a></p>\n<p><a href=\"https://codevang.tistory.com/193\">https://codevang.tistory.com/193</a></p>\n<p><a href=\"https://velog.io/@jihoson94/Servlet-Container-%EC%A0%95%EB%A6%AC\">https://velog.io/@jihoson94/Servlet-Container-%EC%A0%95%EB%A6%AC</a></p>\n<p><a href=\"https://bashbeta.com/ko/%EC%84%9C%EB%B8%94%EB%A6%BF%EC%97%90%EC%84%9C-%EC%83%9D%EC%84%B1%EC%9E%90%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9E%85%EB%8B%88%EA%B9%8C/\">https://bashbeta.com/ko/%EC%84%9C%EB%B8%94%EB%A6%BF%EC%97%90%EC%84%9C-%EC%83%9D%EC%84%B1%EC%9E%90%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9E%85%EB%8B%88%EA%B9%8C/</a></p>","frontmatter":{"title":"서블릿 생명주기와 직접만든 톰캣을 통한 의문점","date":"September 17, 2022","update":"September 17, 2022","tags":["tomcat","servlet"],"series":null},"fields":{"slug":"/servlet-life-cycle/","readingTime":{"minutes":10.085}}},"seriesList":{"edges":[{"node":{"id":"a621dc7b-8590-5ec6-9b52-3d9e5182486d","fields":{"slug":"/appearance-background-of-jpa/"},"frontmatter":{"title":"JPA 등장배경"}}},{"node":{"id":"9d2a87b6-2b9c-5b87-b790-3426d17c2d8e","fields":{"slug":"/intellij-final-keyword/"},"frontmatter":{"title":"IntelliJ에서 메소드 추출한 메소드의 파라미터에 final 키워드 자동 추가하기"}}},{"node":{"id":"251e9767-1c92-5cf5-9cef-2c4a42c10df2","fields":{"slug":"/git-branch-strategy/"},"frontmatter":{"title":"달록팀의 git 브랜치 전략을 소개합니다."}}},{"node":{"id":"5090cce3-0c1f-5376-badc-1d25e44c1bd9","fields":{"slug":"/infinite-scroll/"},"frontmatter":{"title":"React에서 무한 스크롤 구현하기"}}},{"node":{"id":"bcb53ba5-0286-5d10-96c2-fdcb88e2cc60","fields":{"slug":"/package-structure/"},"frontmatter":{"title":"달록에 적절한 패키지 구조 고민하기"}}},{"node":{"id":"a7fc89de-f37c-596e-a81d-3d4fe5a795b8","fields":{"slug":"/data-jpa-slice-page/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"e1ba92ee-0cf0-50c8-80bd-5da5075df8d1","fields":{"slug":"/data-jpa-auditing/"},"frontmatter":{"title":"Spring Data JPA의 Auditing"}}},{"node":{"id":"3e036508-c916-504e-9e8d-89f69332471e","fields":{"slug":"/separated-interface/"},"frontmatter":{"title":"외부와 의존성 분리하기"}}},{"node":{"id":"cade544a-16ef-58a3-b97c-824986a8395f","fields":{"slug":"/apply-rest-docs/"},"frontmatter":{"title":"MockMvc를 사용한 Spring RestDocs"}}},{"node":{"id":"87649d54-d59e-58a6-afd5-8491eb4113a8","fields":{"slug":"/properties-to-object/"},"frontmatter":{"title":"properties 객체로 다루기"}}},{"node":{"id":"eb380f6d-5a00-5a9e-a916-003fb292cc8a","fields":{"slug":"/test-fixture-constant/"},"frontmatter":{"title":"테스트에서 Entity 객체를 상수로 두면 안 되는 이유"}}},{"node":{"id":"9734e30a-b430-5922-919d-f53808a56eb9","fields":{"slug":"/what_is_nginx/"},"frontmatter":{"title":"NGINX 란?"}}},{"node":{"id":"9ebc6e21-2a76-5d42-be33-c2dae8c849b2","fields":{"slug":"/ssl_protocol/"},"frontmatter":{"title":"SSL을 통한 HTTPS통신 과정"}}},{"node":{"id":"fa5ad595-1f81-5a20-a884-2da69adee3c5","fields":{"slug":"/integration-test-slice-test/"},"frontmatter":{"title":"통합 테스트와 슬라이스 테스트"}}},{"node":{"id":"d8c66823-bb05-5e83-a6a1-2fd9af450b6f","fields":{"slug":"/query-invalidation/"},"frontmatter":{"title":"React-Query에서의 데이터 최신화 (Query Invalidation)"}}},{"node":{"id":"f5187517-342f-52a1-9092-d12c1a80d132","fields":{"slug":"/seperate-components/"},"frontmatter":{"title":"컴포넌트 분리 기준"}}},{"node":{"id":"d6249c8b-bea6-5c91-8477-d3dd15ad9b39","fields":{"slug":"/test-isolation/"},"frontmatter":{"title":"테스트 격리"}}},{"node":{"id":"98e390ef-fb19-5d01-a3ef-d14bc0e65176","fields":{"slug":"/dallog-jacoco/"},"frontmatter":{"title":"달록의 Jacoco 적용기 (feat. Gradle)"}}},{"node":{"id":"33d19946-de0c-5b41-bfa0-d7c3fd80f10b","fields":{"slug":"/google-refresh-token/"},"frontmatter":{"title":"Google은 Refresh Token을 쉽게 내주지 않는다."}}},{"node":{"id":"8168857d-a82c-5608-bd40-cea4b917d17d","fields":{"slug":"/submodule/"},"frontmatter":{"title":"달록 서브모듈 도입기"}}},{"node":{"id":"836fc724-7e2f-5c7a-a42b-c0cc9163167a","fields":{"slug":"/dallog-flyway/"},"frontmatter":{"title":"달록의 데이터베이스 마이그레이션을 위한 Flyway 적용기"}}},{"node":{"id":"7a3bde6d-746b-56fd-8d91-0d8059ebf1f8","fields":{"slug":"/json-property-json-naming/"},"frontmatter":{"title":"@JsonProperty, @JsonNaming"}}},{"node":{"id":"50673f5c-f835-5982-b70c-b77e5a352a2c","fields":{"slug":"/servlet-life-cycle/"},"frontmatter":{"title":"서블릿 생명주기와 직접만든 톰캣을 통한 의문점"}}},{"node":{"id":"61e7f4d1-7b3a-5968-bfe8-c3f6efb88748","fields":{"slug":"/preparing-for-performance-test/"},"frontmatter":{"title":"톰캣 튜닝을 위한 달록의 서버 성능 테스트 준비 과정"}}},{"node":{"id":"9272061d-68c6-5f82-a961-0e2efe0fd6be","fields":{"slug":"/cyclic-dependency/"},"frontmatter":{"title":"cyclic dependency"}}},{"node":{"id":"6e779308-f266-58af-bfcc-e9fee6d39a98","fields":{"slug":"/multi-datasource-issue-with-osiv/"},"frontmatter":{"title":"대체 왜 DataSource 라우팅이 안되는거야!? (feat. OSIV)"}}},{"node":{"id":"c7bea043-345c-5f78-ae53-796a83812961","fields":{"slug":"/react-query-useMutation-trouble-shooting/"},"frontmatter":{"title":"react-query useMutation onSuccess 안 되는줄 알았던 트러블 슈팅"}}},{"node":{"id":"cf403487-1c48-5ca7-b5c2-ef0d8fefe3c4","fields":{"slug":"/jenkins-distributed-build-architecture/"},"frontmatter":{"title":"젠킨스 분산 빌드 아키텍처 구축"}}},{"node":{"id":"24c152c7-4e94-5b84-aaea-a5a9a8357693","fields":{"slug":"/zero-downtime-deployment/"},"frontmatter":{"title":"달록 무중단 배포 도입기"}}},{"node":{"id":"623f9105-974d-51b9-84c7-f6298a8d1c19","fields":{"slug":"/get-valid-accessToken/"},"frontmatter":{"title":"refreshToken으로 accessToken 재발급하기"}}},{"node":{"id":"d34299f0-eb49-5aef-a38f-963200d5fd6d","fields":{"slug":"/test-readability/"},"frontmatter":{"title":"어떻게 테스트 코드 가독성을 개선할 수 있을까??"}}}]},"previous":{"fields":{"slug":"/json-property-json-naming/"},"frontmatter":{"title":"@JsonProperty, @JsonNaming"}},"next":{"fields":{"slug":"/preparing-for-performance-test/"},"frontmatter":{"title":"톰캣 튜닝을 위한 달록의 서버 성능 테스트 준비 과정"}}},"pageContext":{"id":"50673f5c-f835-5982-b70c-b77e5a352a2c","series":null,"previousPostId":"7a3bde6d-746b-56fd-8d91-0d8059ebf1f8","nextPostId":"61e7f4d1-7b3a-5968-bfe8-c3f6efb88748"}},"staticQueryHashes":[]}