{"componentChunkName":"component---src-templates-post-jsx","path":"/test-readability/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"d34299f0-eb49-5aef-a38f-963200d5fd6d","excerpt":"이 글은 우테코 달록팀 크루 '리버'가 작성했습니다. 글을 쓴 계기 최근 4개월간 우아한 테크 코스 4기 달록 팀 프로젝트를 진행하였다.\n프로젝트 기간이 종료될 쯔음 팀원들과 프로젝트 과정에서 나온 트러블 슈팅에 대해 이야기를 나눠보았다.😮 트러블 슈팅을 이야기하던 중, 우연하게 현재 프로젝트 테스트 코드의 문제점에 대해 이야기를 나누었다. 달록팀은 약 …","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 '<a href=\"https://github.com/gudonghee2000\">리버</a>'가 작성했습니다.</p>\n</blockquote>\n<h2>글을 쓴 계기</h2>\n<p>최근 4개월간 <strong>우아한 테크 코스 4기 달록 팀 프로젝트</strong>를 진행하였다.\n프로젝트 기간이 종료될 쯔음 팀원들과 프로젝트 과정에서 나온 <strong>트러블 슈팅</strong>에 대해 이야기를 나눠보았다.😮</p>\n<p>트러블 슈팅을 이야기하던 중, 우연하게 현재 프로젝트 <strong>테스트 코드의 문제점</strong>에 대해 이야기를 나누었다.</p>\n<p>달록팀은 약 350개의 테스트 코드를 가지고 있다. 트러블 슈팅을 통해 깨달은 <strong>350개의 테스트 코드의 문제점</strong>은 아래와 같다.</p>\n<blockquote>\n<p><strong>1. <code class=\"language-text\">TestFixture</code>의 개수가 무분별하게 많다.</strong>\n<strong>2. <code class=\"language-text\">TestMethod</code>의 <code class=\"language-text\">given</code>절이 너무 방대하고 복잡하다.</strong></p>\n</blockquote>\n<p><code class=\"language-text\">TestCode</code>의 <strong>무분별하게 많아진 <code class=\"language-text\">TestFixture</code></strong>는 팀원들의 테스트 관리점만 늘렷고, <strong>복잡한 <code class=\"language-text\">given</code>절</strong>은 읽기 싫은 테스트 코드를 만들었다. </p>\n<br>\n<p>그래서 <strong>\"어떻게 하면 관리점이 적고 읽기 좋은 테스트 코드를 만들 수 있을까?\"</strong> 에 대해 고민한 생각들을 공유해보고자 한다.</p>\n<h2>기존의 달록 프로젝트 테스트 코드</h2>\n<p>우선, 위에서 언급한 <strong>두가지 문제점</strong>을 달록 프로젝트의 실제 코드를 통해 살펴보자.</p>\n<p><em>첫번째 문제점인 <code class=\"language-text\">1. TestFixture의 개수가 무분별하게 많다.</code> 부터 살펴보자.</em></p>\n<p>우리 팀은 <code class=\"language-text\">TestCode</code> 작성 시에 재활용될 만한 <code class=\"language-text\">DataSet</code>들을 <strong><code class=\"language-text\">Fixture</code>로 관리</strong>했다.\n특이한 점은 아래와 같이 <strong>객체를 생성하는 <code class=\"language-text\">Method</code></strong> 자체도 <code class=\"language-text\">Fixture</code>로 만들었다는 점이다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/fe038aac-9a54-4522-b68b-cfb235c39cdf/image.JPG\"></p>\n<p>사진을 보면 <strong><code class=\"language-text\">공통_일정()</code></strong>이라는 네이밍으로 <code class=\"language-text\">Category</code> 객체를 생성하는 <strong>메서드 자체를 <code class=\"language-text\">Fixture</code></strong>로 가져갔음을 알 수 있다.</p>\n<p>그렇다면 <code class=\"language-text\">공통_일정()</code> 메서드를 사용하는 <code class=\"language-text\">TestCode</code>를 보자.</p>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/62e3e133-3392-4266-a260-bc00c184b50f/image.JPG\"></p>\n<p><code class=\"language-text\">TestCode</code>의 208번 줄의 <code class=\"language-text\">categoryRepository.save()</code> 메서드의 파라미터인 <strong><code class=\"language-text\">공통_일정()</code></strong> 부분이 <code class=\"language-text\">Fixture</code>로 만든 <strong><code class=\"language-text\">Method</code>를 활용 한 부분이다.</strong></p>\n<p>처음에는 사진과 같이 나름 깔끔한 <code class=\"language-text\">TestCode</code>를 만들 수 있었고 팀원들의 만족도도 높았다.</p>\n<p>하지만...😥</p>\n<h3>달록의 테스트 Fixture가 만난 문제들</h3>\n<p>1달, 2달 프로젝트가 진행 될 수록, 아래와 같이 <strong>무분별하게 <code class=\"language-text\">Fixture</code> 메서드</strong>가 늘어갔다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/a6c26afd-df61-486c-9b40-e90fc0f9965e/image.JPG\"></p>\n<p>한 눈에 봐도 <code class=\"language-text\">Fixture</code>가 엄청 많다..❗❗\n<strong>(심지어 한 가지 <code class=\"language-text\">Domain</code>에 대한 <code class=\"language-text\">TestFixture</code> 이다.)</strong></p>\n<p>재활용 할 수 있는 <code class=\"language-text\">Fixture</code>들이 많을 것 같은데 <strong>모두 어디선가 사용 중</strong>이다.\n그래서 불필요한 <code class=\"language-text\">Fixture</code>를 제거하기 위한 <strong>리팩터링 비용이 꽤 많이 발생할 것이다.😔</strong></p>\n<p>만약 프로젝트 규모가 점점 거대해진다면, 산불 처럼 걷잡을수 없이 <code class=\"language-text\">Fixture</code>가 늘어날 수 도 있을 것이다.\n<strong>그때에는 리팩터링 비용은 눈더미처럼 불어날 것이다</strong>😤</p>\n<br>\n<p>이렇게 된 원인은 아래와 같다.</p>\n<p>** 1. 팀원들 모두 <code class=\"language-text\">TestCode</code>를 만들 때마다 <code class=\"language-text\">Fixture</code> 메서드를 생성함\n**<code class=\"language-text\">TestCode</code> 작성은 지루한 작업이다.\n그래서 빠르게 <code class=\"language-text\">TestCode</code> 작성을 끝내기 위해서 기존의 <code class=\"language-text\">Fixture</code>를 활용하기 보다 필요할 때마다<code class=\"language-text\">Fixture</code>를 생성하였다.\n그러다보니 점점 무분별하게 <code class=\"language-text\">Fixture</code>의 양이 늘어났다.\n심지어 메서드 자체를 <code class=\"language-text\">Fixture</code>로 만들다 보니 <code class=\"language-text\">Fixture</code>가 더 많이 불어났다..!</p>\n<br>\n<p>**2. 메서드를 <code class=\"language-text\">Fixture</code>로 만드는 방법이 효율적이지 않음\n**우리 팀은 <code class=\"language-text\">TestCode</code>의 가독성을 고려하여 객체를 생성하는 메서드 자체가 특정한 한글 이름을 가지도록했다. 사진의 <code class=\"language-text\">공통_일정()</code>, <code class=\"language-text\">BE_일정()</code>과 같이 특정한 이름을 가진 <code class=\"language-text\">Fixture</code>가 그러한 예이다.\n그러다 보니, <code class=\"language-text\">OCP</code>원칙에 어긋나면서 <code class=\"language-text\">Test</code>를 위한 새로운 객체가 필요할 때 마다\n<code class=\"language-text\">Fixture</code> 메서드도 함께 늘어나는 문제가 발생했다.</p>\n<br>\n<p>우리 팀 <code class=\"language-text\">TestCode</code>의 <code class=\"language-text\">Fixture</code>가 가져오는 <strong>단점을 살펴보았다.</strong>\n이어서 두번째 문제였던, <strong><code class=\"language-text\">2. TestMethod`의 `given`절이 너무 방대하고 복잡하다.</code>를 살펴보자.</strong></p>\n<br>\n<h3>달록의 테스트 given절이 만난 문제들</h3>\n<p>아래 사진은 <strong>달록 Service 객체</strong>인 <code class=\"language-text\">CategoryService</code>의 <code class=\"language-text\">TestCode</code> 일부이다.\n<img src=\"https://velog.velcdn.com/images/gudonghee2000/post/3ec046dc-0076-4d4d-bbca-8db07c7cee27/image.JPG\"></p>\n<p>207번 줄부터 코드를 살펴보자.\n<strong>한 눈에 보아도 굉장히 복잡한 <code class=\"language-text\">given</code>절이 우리를 맞이한다.😤</strong></p>\n<p>복잡한 비지니스 로직을 가진 기능을 개발 할 때마다, 위와 같은 <strong>복잡한 <code class=\"language-text\">given</code>절을 가진 <code class=\"language-text\">TestMethod</code>가 반복된다면 어떨까?</strong></p>\n<p>아마 <strong>Task를 맡은 사람도</strong> <code class=\"language-text\">TestCode</code>를 작성한다고 에너지를 다 쓰고, <strong>코드를 리뷰하는 우리도</strong> <code class=\"language-text\">TestCode</code>를 리뷰하다가 앓아 누울것이다!😵</p>\n<br>\n<p><strong><code class=\"language-text\">TestMethod</code>의 복잡한 <code class=\"language-text\">given</code>절의 문제는 조금 더 자세하게 살펴보면  아래와 같다.</strong></p>\n<ol>\n<li><code class=\"language-text\">TestMethod</code>의 가독성을 현저히 떨어트림\n복잡한 <code class=\"language-text\">given</code>절은 리뷰어에게 하여금 <code class=\"language-text\">TestMethod</code>의 목적인 <strong><code class=\"language-text\">when</code>절에 집중하는 것을 방해</strong>한다.\n그럼으로써, <code class=\"language-text\">TestMethod</code>의 가독성을 떨어트리고 우리는 <strong>어느순간 테스트 코드 리뷰를 안하게 된다.</strong></li>\n<li>올바른 <code class=\"language-text\">TestMethod</code>인지 인지하기가 어려움\n1번 문제에 이어지는 내용이다.\n우리가 <code class=\"language-text\">TestCode</code>를 볼 때, 일반적으로 <strong><code class=\"language-text\">given</code>절을 통해 <code class=\"language-text\">when</code>절에 필요한 <code class=\"language-text\">DataSet</code>을 파악</strong>한다.\n그런데, 복잡한 <code class=\"language-text\">given</code>절은 우리의 코드 이해를 방해하고 <code class=\"language-text\">TestMethod</code>가 <strong>정상적으로 프로덕션 코드를 검증하는 <code class=\"language-text\">TestMethod</code></strong>인지에 대한 이해를 방해한다.</li>\n</ol>\n<br>\n<h3>문제점들을 해결할 방법은?</h3>\n<p>달록 프로젝트가 가지는 <code class=\"language-text\">TestCode</code>의 문제점들을 위에서 살펴보았다.\n그렇다면 해결해야 할 부분은 아래와 같다.</p>\n<blockquote>\n<p>**1. 객체를 생성하는 <code class=\"language-text\">Method</code>는 <code class=\"language-text\">Fixture</code>로 만들어 사용하지 않는다.</p>\n</blockquote>\n<ol start=\"2\">\n<li><code class=\"language-text\">TestMethod</code>의 <code class=\"language-text\">given</code>절을 최소화 한다.**</li>\n</ol>\n<h2>TestCode 문제점 해결 방법 구체화하기</h2>\n<p>위에서 언급한 두가지 문제점을 해결하는 방법을 고민해보자!😤\n우선, 한가지씩 해결해보기위해 <strong>1번 문항과 관련하여 하나의 규칙을 정해보았다.</strong></p>\n<blockquote>\n<p><strong>💡1번 문항에 대한 규칙 **\n객체를 생성하는 <code class=\"language-text\">Method</code>는 반드시 같은 <code class=\"language-text\">TestClass</code> 내부에 <code class=\"language-text\">Static 하지 않게</code> 선언하고. **한가지로 재활용해서 사용</strong>한다.\n왜냐하면, 각 <code class=\"language-text\">TestClass</code>마다 객체의 <strong>필드 중 필요한 필드는 다를 수 있기 때문</strong>이다. </p>\n</blockquote>\n<p>위 규칙을 가지고 <code class=\"language-text\">TestCode</code>의 <code class=\"language-text\">given</code>절을 최소화 할 방법을 <strong>구체화 하기위한 몇가지 시도</strong>를 해보았다.\n<strong>(시간이 부족하여 실제 프로젝트에는 적용하지 못하고 미션 또는 개인적으로 방법으로 실험 해보았다😔)</strong></p>\n<p>이제 본론이다!\n하나씩 살펴보자!🔥</p>\n<br>\n<h2>구체화한 개선 방법들</h2>\n<h3>Builder 패턴의 활용</h3>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/20ec5320-25f3-4347-9ac7-3599e045d90f/image.JPG\"></p>\n<p>첫번째는 <strong>Builder 패턴을 활용하는 방법</strong>이다.\n만약, Builder 패턴을 통해서 <code class=\"language-text\">given</code> 절의 객체를 생성한다면 <strong>메서드체이닝을 통해</strong> 생성자를 통한 생성보다는 조금이나마 <strong>가독성을 가져 갈 수 있다.</strong>\n<strong>(만약 객체의 필드가 10 ~ 20개가 되면 상당히 유용할 수 도 있을것 같다😤)</strong></p>\n<p>그러나 아직도 63번줄의 <strong><code class=\"language-text\">menuGroupRepository.save()</code> 와 같은 로직</strong>은 우리가 <strong><code class=\"language-text\">when</code>절에만 온전히 집중하는 것을 방해</strong>하고 <code class=\"language-text\">menuGroupRepository.save()</code>에 대한 이해를 필요로 한다.</p>\n<br>\n<h3>@BeforeEach 구문의 활용</h3>\n<p>@BeforeEach 구문에 테스트 메서드의 <strong><code class=\"language-text\">given</code> 절과 관련한 로직을 가능한 최대한 넣는다면</strong> 코드를 볼 때, <code class=\"language-text\">TestMethod</code>의 <code class=\"language-text\">given</code>절을 간소화하고 우리가 <code class=\"language-text\">when</code>절에 집중 하는 것을 도울 수 있다.\n<img src=\"https://velog.velcdn.com/images/gudonghee2000/post/45b6cffb-e5e8-40c0-a68a-6a9c14f339c6/image.JPG\"></p>\n<p>그럼에도 불구하고 여전히 90번 줄의 <strong><code class=\"language-text\">orderTableRepository.save()</code> 와 같은 <code class=\"language-text\">DB 저장 로직</code></strong>은 제거 할 수 없고 우리가 <code class=\"language-text\">when</code>절에만 온전히 집중하는 것을 방해하고 있다.</p>\n<p>위 두가지 방식은 <code class=\"language-text\">orderTableRepository.save()</code> 와 같은 <code class=\"language-text\">DB 저장 로직</code>을 제거하지 못한다.\n<strong>그렇다면 <code class=\"language-text\">orderTableRepository.save()</code> 와 같은 로직을 제거 할 방법은 뭐가 있을까??</strong></p>\n<br>\n<h3>메서드 체이닝 방식의 활용</h3>\n<p>내가 찾은 방법은 <strong>메서드 체이닝 방식의 활용</strong>이다.\nBuilder 패턴의 메서드 체이닝을 보면서 힌트를 얻었다.</p>\n<p>만약, 메서드 체이닝 방식으로 <strong><code class=\"language-text\">orderTableRepository.save()</code> 와 같은 로직을 숨긴다면</strong> 더 가독성 <strong>좋은 <code class=\"language-text\">given</code> 절</strong>을 만들 수 있지 않을까 하는 생각이였다.</p>\n<p>또한, <strong>한글 네이밍의 메서드들을 병렬로 배치함</strong> 으로써 마치 소설을 읽듯이 잘 읽히는 <code class=\"language-text\">given</code>절을 만들 수 있지 않을까하는 생각이 들었다.</p>\n<p><strong>한번 코드로 자세히 살펴보자.🦾🦾</strong></p>\n<p>우선, 기존의 달록 프로젝트 테스트 코드 일부를 보자.\n<img src=\"https://velog.velcdn.com/images/gudonghee2000/post/3ec046dc-0076-4d4d-bbca-8db07c7cee27/image.JPG\"></p>\n<p>놀랍게도 하나의 테스트 메서드이다.🙄\n만약 이 코드를 본다면 <strong>넓디 넓은 <code class=\"language-text\">given</code>절</strong>에서 우리는 이미 지쳐 버릴 것이다.</p>\n<p>왜 그럴까?\n앞서 설명한 <strong>방대한 <code class=\"language-text\">given</code>절이 가져오는 문제</strong> 때문이다.</p>\n<p>이 테스트 메서드에 메서드체이닝 방식을 적용해보자.</p>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/73b98df9-d321-413a-843c-10ef43c0bc4c/image.JPG\"></p>\n<p>위 사진은 기존 테스트 메서드를 <strong>메서드체이닝 방식으로 리팩터링</strong> 한 코드이다.\n_\n<code class=\"language-text\">orderTableRepository.save()</code> 같은 메서드가 제거되면서 <code class=\"language-text\">given</code>절이 굉장히 간소화 됬다!\n그리고 한글문장이 소설처럼 이어지면서 <code class=\"language-text\">given</code>절을 통해 프로덕션의 비지니스 로직이 이해되기도 한다!\n마지막으로 <code class=\"language-text\">given</code>절 과 <code class=\"language-text\">when</code>절의 구분이 명확하게 느껴진다!_</p>\n<p>그럼 메서드 체이닝을 하는 객체를 살펴보자.\n<strong>첫번째 규칙에 따라서</strong> <code class=\"language-text\">TestClass</code> 내부의 <code class=\"language-text\">InnerClass</code>로 객체 종류에 따라 <strong>한가지 메서드만 정의</strong>해보았다. </p>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/e9020492-486c-4ccf-8894-77edbd446812/image.JPG\"></p>\n<p>사진과 같이 InnerClass에 체이닝 방식을 위한 메서드들을 만들고 <strong><code class=\"language-text\">xxxRepository.save()</code>와 같은 로직, 객체를 숨겨놓았다.</strong></p>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/3ec046dc-0076-4d4d-bbca-8db07c7cee27/image.JPG\"></p>\n<p><strong>최종적으로 다시 차이를 살펴보자! **\n위와 같이 복잡한 <code class=\"language-text\">given</code>절이 필요한 경우에도\n메서드 체이닝을 통해서 **아래와 같이 간소화</strong> 시킬 수 있다.</p>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/73b98df9-d321-413a-843c-10ef43c0bc4c/image.JPG\"></p>\n<h3>내가 느낀 메서드 체이닝 방식의 장점</h3>\n<p>직접 프로젝트 코드 일부에 <strong>메서드체이닝 방식</strong>을 실험 해보면서 느낀 장점을 정리해보자!😤</p>\n<ul>\n<li>다른 객체의 메서드 호출(<code class=\"language-text\">ex. xxxRepository.save()</code>)을 숨김으로써 <code class=\"language-text\">given</code> 절을 간소화 할 수 있다.</li>\n<li>소설을 읽듯 한글로 이어지는 <code class=\"language-text\">given</code> 절의 메서드 체이닝으로 프로덕션 비지니스 로직의 이해에 도움이 된다.</li>\n<li>코드를 읽는 입장에서 <code class=\"language-text\">when</code>절 테스트를 위해 필요한 <code class=\"language-text\">given</code>절의 <code class=\"language-text\">DataSet</code>이 한눈에 들어온다.</li>\n</ul>\n<br>\n물론 장점과 더불어 단점도 있다고 생각한다.\n<h3>내가 느낀 메서드 체이닝 방식의 단점</h3>\n<ul>\n<li><code class=\"language-text\">메서드 체이닝</code>을 위한 객체를 생성하는 비용이 발생하고 관리점이 늘어난다.</li>\n<li>도메인 객체에 변화가 생기면 <code class=\"language-text\">메서드 체이닝</code> 객체도 함께 수정 해주어야한다.</li>\n</ul>\n<p><strong>메서드 체이닝 방식을 <code class=\"language-text\">ServiceTest</code>에만 적용</strong> 해보았지만, 인수테스트, 단위 테스트 등에도 적절하게 사용할 수 있지 않을까 생각한다!</p>\n<blockquote>\n<p>**💡 <code class=\"language-text\">DynamicTest</code>와 <code class=\"language-text\">메서드체이닝</code>의 결합?\n**우연히 크루분의 코드를 보다가 <code class=\"language-text\">DynamicTest</code>를 만드신 코드를 보았다. 아직 <code class=\"language-text\">DynamicTest</code>를 공부해보지 않았지만, <code class=\"language-text\">메서드 체이닝</code> 방식과 결합한다면 가독성과 성능 두가지 측면을 개선 할 수 있지는 않을까 생각이 든다!</p>\n</blockquote>\n<h2>마치면서</h2>\n<p>이상으로 테스트 코드 가독성 개선을 위한 생각을 적어보았다!\n테스트 코드의 가독성은 굉장히 주관적인 부분이기 때문에 위에 적은 생각들이 맞다고 생각하지 않는다.</p>\n<p>하지만, <strong>포스팅을 하면서 <code class=\"language-text\">읽기 좋은 테스트 코드는 소설 같지 않을까?</code> 라는 생각이 들었다.</strong> </p>\n<p>소설을 읽듯이 재밌게 읽히는 테스트 코드는 우리가 코드를 작성하거나 리뷰할 때도 즐거움을 줄것이다!</p>\n<p>테스트 코드의 가독성을 개선하기 위한 과정에 조금이나마 도움이되는 글이 되었으면 좋겠다!😊</p>","frontmatter":{"title":"어떻게 테스트 코드 가독성을 개선할 수 있을까??","date":"November 02, 2022","update":"November 02, 2022","tags":["달록","테스트 가독성","BE"],"series":null},"fields":{"slug":"/test-readability/","readingTime":{"minutes":16.325}}},"seriesList":{"edges":[{"node":{"id":"a621dc7b-8590-5ec6-9b52-3d9e5182486d","fields":{"slug":"/appearance-background-of-jpa/"},"frontmatter":{"title":"JPA 등장배경"}}},{"node":{"id":"9d2a87b6-2b9c-5b87-b790-3426d17c2d8e","fields":{"slug":"/intellij-final-keyword/"},"frontmatter":{"title":"IntelliJ에서 메소드 추출한 메소드의 파라미터에 final 키워드 자동 추가하기"}}},{"node":{"id":"251e9767-1c92-5cf5-9cef-2c4a42c10df2","fields":{"slug":"/git-branch-strategy/"},"frontmatter":{"title":"달록팀의 git 브랜치 전략을 소개합니다."}}},{"node":{"id":"5090cce3-0c1f-5376-badc-1d25e44c1bd9","fields":{"slug":"/infinite-scroll/"},"frontmatter":{"title":"React에서 무한 스크롤 구현하기"}}},{"node":{"id":"bcb53ba5-0286-5d10-96c2-fdcb88e2cc60","fields":{"slug":"/package-structure/"},"frontmatter":{"title":"달록에 적절한 패키지 구조 고민하기"}}},{"node":{"id":"a7fc89de-f37c-596e-a81d-3d4fe5a795b8","fields":{"slug":"/data-jpa-slice-page/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"e1ba92ee-0cf0-50c8-80bd-5da5075df8d1","fields":{"slug":"/data-jpa-auditing/"},"frontmatter":{"title":"Spring Data JPA의 Auditing"}}},{"node":{"id":"3e036508-c916-504e-9e8d-89f69332471e","fields":{"slug":"/separated-interface/"},"frontmatter":{"title":"외부와 의존성 분리하기"}}},{"node":{"id":"cade544a-16ef-58a3-b97c-824986a8395f","fields":{"slug":"/apply-rest-docs/"},"frontmatter":{"title":"MockMvc를 사용한 Spring RestDocs"}}},{"node":{"id":"87649d54-d59e-58a6-afd5-8491eb4113a8","fields":{"slug":"/properties-to-object/"},"frontmatter":{"title":"properties 객체로 다루기"}}},{"node":{"id":"eb380f6d-5a00-5a9e-a916-003fb292cc8a","fields":{"slug":"/test-fixture-constant/"},"frontmatter":{"title":"테스트에서 Entity 객체를 상수로 두면 안 되는 이유"}}},{"node":{"id":"9734e30a-b430-5922-919d-f53808a56eb9","fields":{"slug":"/what_is_nginx/"},"frontmatter":{"title":"NGINX 란?"}}},{"node":{"id":"9ebc6e21-2a76-5d42-be33-c2dae8c849b2","fields":{"slug":"/ssl_protocol/"},"frontmatter":{"title":"SSL을 통한 HTTPS통신 과정"}}},{"node":{"id":"fa5ad595-1f81-5a20-a884-2da69adee3c5","fields":{"slug":"/integration-test-slice-test/"},"frontmatter":{"title":"통합 테스트와 슬라이스 테스트"}}},{"node":{"id":"d8c66823-bb05-5e83-a6a1-2fd9af450b6f","fields":{"slug":"/query-invalidation/"},"frontmatter":{"title":"React-Query에서의 데이터 최신화 (Query Invalidation)"}}},{"node":{"id":"f5187517-342f-52a1-9092-d12c1a80d132","fields":{"slug":"/seperate-components/"},"frontmatter":{"title":"컴포넌트 분리 기준"}}},{"node":{"id":"d6249c8b-bea6-5c91-8477-d3dd15ad9b39","fields":{"slug":"/test-isolation/"},"frontmatter":{"title":"테스트 격리"}}},{"node":{"id":"98e390ef-fb19-5d01-a3ef-d14bc0e65176","fields":{"slug":"/dallog-jacoco/"},"frontmatter":{"title":"달록의 Jacoco 적용기 (feat. Gradle)"}}},{"node":{"id":"ab7073d6-575f-55b8-8b1d-fec1ea27916f","fields":{"slug":"/cannot-scroll-to-top-of-flex-element/"},"frontmatter":{"title":"스크롤을 했더니 윗부분이 안 보여요!"}}},{"node":{"id":"33d19946-de0c-5b41-bfa0-d7c3fd80f10b","fields":{"slug":"/google-refresh-token/"},"frontmatter":{"title":"Google은 Refresh Token을 쉽게 내주지 않는다."}}},{"node":{"id":"8168857d-a82c-5608-bd40-cea4b917d17d","fields":{"slug":"/submodule/"},"frontmatter":{"title":"달록 서브모듈 도입기"}}},{"node":{"id":"836fc724-7e2f-5c7a-a42b-c0cc9163167a","fields":{"slug":"/dallog-flyway/"},"frontmatter":{"title":"달록의 데이터베이스 마이그레이션을 위한 Flyway 적용기"}}},{"node":{"id":"7a3bde6d-746b-56fd-8d91-0d8059ebf1f8","fields":{"slug":"/json-property-json-naming/"},"frontmatter":{"title":"@JsonProperty, @JsonNaming"}}},{"node":{"id":"50673f5c-f835-5982-b70c-b77e5a352a2c","fields":{"slug":"/servlet-life-cycle/"},"frontmatter":{"title":"서블릿 생명주기와 직접만든 톰캣을 통한 의문점"}}},{"node":{"id":"61e7f4d1-7b3a-5968-bfe8-c3f6efb88748","fields":{"slug":"/preparing-for-performance-test/"},"frontmatter":{"title":"톰캣 튜닝을 위한 달록의 서버 성능 테스트 준비 과정"}}},{"node":{"id":"9272061d-68c6-5f82-a961-0e2efe0fd6be","fields":{"slug":"/cyclic-dependency/"},"frontmatter":{"title":"cyclic dependency"}}},{"node":{"id":"6e779308-f266-58af-bfcc-e9fee6d39a98","fields":{"slug":"/multi-datasource-issue-with-osiv/"},"frontmatter":{"title":"대체 왜 DataSource 라우팅이 안되는거야!? (feat. OSIV)"}}},{"node":{"id":"c7bea043-345c-5f78-ae53-796a83812961","fields":{"slug":"/react-query-useMutation-trouble-shooting/"},"frontmatter":{"title":"react-query useMutation onSuccess 안 되는줄 알았던 트러블 슈팅"}}},{"node":{"id":"cf403487-1c48-5ca7-b5c2-ef0d8fefe3c4","fields":{"slug":"/jenkins-distributed-build-architecture/"},"frontmatter":{"title":"젠킨스 분산 빌드 아키텍처 구축"}}},{"node":{"id":"24c152c7-4e94-5b84-aaea-a5a9a8357693","fields":{"slug":"/zero-downtime-deployment/"},"frontmatter":{"title":"달록 무중단 배포 도입기"}}},{"node":{"id":"623f9105-974d-51b9-84c7-f6298a8d1c19","fields":{"slug":"/get-valid-accessToken/"},"frontmatter":{"title":"refreshToken으로 accessToken 재발급하기"}}},{"node":{"id":"d34299f0-eb49-5aef-a38f-963200d5fd6d","fields":{"slug":"/test-readability/"},"frontmatter":{"title":"어떻게 테스트 코드 가독성을 개선할 수 있을까??"}}},{"node":{"id":"fe27c1ec-d040-5cf4-934a-a5eeb2131dfb","fields":{"slug":"/troubleshooting-of-category-role-concurrency-issue/"},"frontmatter":{"title":"JPA의 낙관적 락을 사용한 동시성 이슈 해결"}}}]},"previous":{"fields":{"slug":"/hikari-cp-3-spadework/"},"frontmatter":{"title":"HikariCP와 적절한 풀 사이즈 고민하기 (3) - 삽질편"}},"next":{"fields":{"slug":"/troubleshooting-of-category-role-concurrency-issue/"},"frontmatter":{"title":"JPA의 낙관적 락을 사용한 동시성 이슈 해결"}}},"pageContext":{"id":"d34299f0-eb49-5aef-a38f-963200d5fd6d","series":null,"previousPostId":"9452f85a-2e76-5b0e-85b2-22277976f133","nextPostId":"fe27c1ec-d040-5cf4-934a-a5eeb2131dfb"}},"staticQueryHashes":[]}